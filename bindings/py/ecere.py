from EcereSDK.eC import *
from _pyecere import *

class FreeSpots(Struct):
   def __init__(self, size = 0, spots = None, nextSpot = 0, used = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_FreeSpots *", impl)
      else:
         if isinstance(size, tuple):
            __tuple = size
            size = 0
            if len(__tuple) > 0: size     = __tuple[0]
            if len(__tuple) > 1: spots    = __tuple[1]
            if len(__tuple) > 2: nextSpot = __tuple[2]
            if len(__tuple) > 3: used     = __tuple[3]
         self.impl = ffi.new("eC_FreeSpots *", { 'size' : size, 'spots' : spots, 'nextSpot' : nextSpot, 'used' : used })

   @property
   def size(self): return self.impl.size
   @size.setter
   def size(self, value): self.impl.size = value

   @property
   def spots(self): return self.impl.spots
   @spots.setter
   def spots(self, value): self.impl.spots = value

   @property
   def nextSpot(self): return self.impl.nextSpot
   @nextSpot.setter
   def nextSpot(self, value): self.impl.nextSpot = value

   @property
   def used(self): return self.impl.used
   @used.setter
   def used(self, value): self.impl.used = value

   def init(self, count):
      lib.FreeSpots_init(ffi.cast("eC_FreeSpots *", self.impl), count)

   def markFree(self, spot):
      lib.FreeSpots_markFree(ffi.cast("eC_FreeSpots *", self.impl), spot)

   def next(self):
      return lib.FreeSpots_next(ffi.cast("eC_FreeSpots *", self.impl))

   def resize(self, count):
      lib.FreeSpots_resize(ffi.cast("eC_FreeSpots *", self.impl), count)

class GLArrayTexture(Struct):
   def __init__(self, texture = 0, width = 0, height = 0, numLayers = 0, numLevels = 0, maxLevel = False, format = 0, spots = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_GLArrayTexture *", impl)
      else:
         if spots is not None:
            if not isinstance(spots, FreeSpots): spots = FreeSpots(spots)
            spots = spots.impl[0]
         else:
            spots = FreeSpots()
            spots = spots.impl[0]
         self.impl = ffi.new("eC_GLArrayTexture *", {
                                'texture' : texture,
                                'width' : width,
                                'height' : height,
                                'numLayers' : numLayers,
                                'numLevels' : numLevels,
                                'maxLevel' : maxLevel,
                                'format' : format,
                                'spots' : spots
                             })

   @property
   def texture(self): return self.impl.texture
   @texture.setter
   def texture(self, value): self.impl.texture = value

   @property
   def width(self): return self.impl.width
   @width.setter
   def width(self, value): self.impl.width = value

   @property
   def height(self): return self.impl.height
   @height.setter
   def height(self, value): self.impl.height = value

   @property
   def numLayers(self): return self.impl.numLayers
   @numLayers.setter
   def numLayers(self, value): self.impl.numLayers = value

   @property
   def numLevels(self): return self.impl.numLevels
   @numLevels.setter
   def numLevels(self, value): self.impl.numLevels = value

   @property
   def maxLevel(self): return self.impl.maxLevel
   @maxLevel.setter
   def maxLevel(self, value): self.impl.maxLevel = value

   @property
   def format(self): return self.impl.format
   @format.setter
   def format(self, value): self.impl.format = value

   @property
   def spots(self): return FreeSpots(impl = self.impl.spots)
   @spots.setter
   def spots(self, value):
      if not isinstance(value, FreeSpots): value = FreeSpots(value)
      self.impl.spots = value.impl[0]

   def _init(self, levels, w, h, count, format, setMaxLevel):
      lib.GLArrayTexture__init(ffi.cast("eC_GLArrayTexture *", self.impl), levels, w, h, count, format, setMaxLevel)

   def allocateLayer(self, targetFBO):
      return lib.GLArrayTexture_allocateLayer(ffi.cast("eC_GLArrayTexture *", self.impl), targetFBO)

   def bind(self):
      lib.GLArrayTexture_bind(ffi.cast("eC_GLArrayTexture *", self.impl))

   def copy(self, src, targetFBO):
      if src is not None and not isinstance(src, GLArrayTexture): src = GLArrayTexture(src)
      src = ffi.NULL if src is None else src.impl
      lib.GLArrayTexture_copy(ffi.cast("eC_GLArrayTexture *", self.impl), ffi.cast("eC_GLArrayTexture *", src), targetFBO)

   def free(self):
      lib.GLArrayTexture_free(ffi.cast("eC_GLArrayTexture *", self.impl))

   def freeLayer(self, layer):
      lib.GLArrayTexture_freeLayer(ffi.cast("eC_GLArrayTexture *", self.impl), layer)

   def init(self, levels, w, h, count):
      lib.GLArrayTexture_init(ffi.cast("eC_GLArrayTexture *", self.impl), levels, w, h, count)

   def initMaxLevel(self, levels, w, h, count):
      lib.GLArrayTexture_initMaxLevel(ffi.cast("eC_GLArrayTexture *", self.impl), levels, w, h, count)

   def initRGBAUShort(self, levels, w, h, count):
      lib.GLArrayTexture_initRGBAUShort(ffi.cast("eC_GLArrayTexture *", self.impl), levels, w, h, count)

   def initRGBUShort(self, levels, w, h, count):
      lib.GLArrayTexture_initRGBUShort(ffi.cast("eC_GLArrayTexture *", self.impl), levels, w, h, count)

   def initUShort(self, levels, w, h, count):
      lib.GLArrayTexture_initUShort(ffi.cast("eC_GLArrayTexture *", self.impl), levels, w, h, count)

   def resize(self, numLayers, targetFBO):
      lib.GLArrayTexture_resize(ffi.cast("eC_GLArrayTexture *", self.impl), numLayers, targetFBO)

   def set1x1Layer(self, layer, color, targetFBO):
      if color is not None and not isinstance(color, ColorAlpha): color = ColorAlpha(color)
      if color is None: color = ffi.NULL
      lib.GLArrayTexture_set1x1Layer(ffi.cast("eC_GLArrayTexture *", self.impl), layer, color, targetFBO)

   def setFilter(self, minFilter, magFilter):
      lib.GLArrayTexture_setFilter(ffi.cast("eC_GLArrayTexture *", self.impl), minFilter, magFilter)

   def setLayer(self, level, x, y, layer, c, targetFBO):
      lib.GLArrayTexture_setLayer(ffi.cast("eC_GLArrayTexture *", self.impl), level, x, y, layer, c, targetFBO)

   def setLayerCompressed(self, level, x, y, layer, c, sizeBytes, targetFBO):
      lib.GLArrayTexture_setLayerCompressed(ffi.cast("eC_GLArrayTexture *", self.impl), level, x, y, layer, c, sizeBytes, targetFBO)

   def setLayerFormat(self, level, x, y, layer, c, targetFBO, format, type):
      lib.GLArrayTexture_setLayerFormat(ffi.cast("eC_GLArrayTexture *", self.impl), level, x, y, layer, c, targetFBO, format, type)

   def setLayerRGBAUShort(self, level, x, y, layer, c, targetFBO):
      lib.GLArrayTexture_setLayerRGBAUShort(ffi.cast("eC_GLArrayTexture *", self.impl), level, x, y, layer, c, targetFBO)

   def setLayerRGBUShort(self, level, x, y, layer, c, targetFBO):
      lib.GLArrayTexture_setLayerRGBUShort(ffi.cast("eC_GLArrayTexture *", self.impl), level, x, y, layer, c, targetFBO)

   def setLayerUShort(self, level, x, y, layer, c, targetFBO):
      lib.GLArrayTexture_setLayerUShort(ffi.cast("eC_GLArrayTexture *", self.impl), level, x, y, layer, c, targetFBO)

class GLDrawCommand(Struct):
   def __init__(self, count = 0, instanceCount = 0, firstIndex = 0, baseVertex = 0, baseInstance = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_GLDrawCommand *", impl)
      else:
         if isinstance(count, tuple):
            __tuple = count
            count = 0
            if len(__tuple) > 0: count         = __tuple[0]
            if len(__tuple) > 1: instanceCount = __tuple[1]
            if len(__tuple) > 2: firstIndex    = __tuple[2]
            if len(__tuple) > 3: baseVertex    = __tuple[3]
         self.impl = ffi.new("eC_GLDrawCommand *", {
                                'count' : count,
                                'instanceCount' : instanceCount,
                                'firstIndex' : firstIndex,
                                'baseVertex' : baseVertex,
                                'baseInstance' : baseInstance
                             })

   @property
   def count(self): return self.impl.count
   @count.setter
   def count(self, value): self.impl.count = value

   @property
   def instanceCount(self): return self.impl.instanceCount
   @instanceCount.setter
   def instanceCount(self, value): self.impl.instanceCount = value

   @property
   def firstIndex(self): return self.impl.firstIndex
   @firstIndex.setter
   def firstIndex(self, value): self.impl.firstIndex = value

   @property
   def baseVertex(self): return self.impl.baseVertex
   @baseVertex.setter
   def baseVertex(self, value): self.impl.baseVertex = value

   @property
   def baseInstance(self): return self.impl.baseInstance
   @baseInstance.setter
   def baseInstance(self, value): self.impl.baseInstance = value

class GLMultiDraw(Struct):
   def __init__(self,
                indexGLMB = None,
                vertexGLMB = None,
                idsAB = None,
                commandsB = None,
                vao = 0,
                commandsCount = 0,
                drawMode = 0,
                commandsAlloced = 0,
                drawIDs = None,
                commands = None,
                type = 0,
                idsAlloced = 0,
                totalInstances = 0,
                vertexStride = 0,
                transformsAB = None,
                transformSize = 0,
                transforms = None,
                lastTransformAB = 0,
                lastIDAB = 0,
                lastVBO = 0,
                lastIBO = 0,
                ix32 = None,
                impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_GLMultiDraw *", impl)
      else:
         if indexGLMB is not None:
            if not isinstance(indexGLMB, GLMB): indexGLMB = GLMB(indexGLMB)
            indexGLMB = indexGLMB.impl
         else:
            indexGLMB = ffi.NULL
         if vertexGLMB is not None:
            if not isinstance(vertexGLMB, GLMB): vertexGLMB = GLMB(vertexGLMB)
            vertexGLMB = vertexGLMB.impl
         else:
            vertexGLMB = ffi.NULL
         if idsAB is not None:
            if not isinstance(idsAB, GLAB): idsAB = GLAB(idsAB)
            idsAB = idsAB.impl[0]
         else:
            idsAB = GLAB()
            idsAB = idsAB.impl[0]
         if commandsB is not None:
            if not isinstance(commandsB, GLCAB): commandsB = GLCAB(commandsB)
            commandsB = commandsB.impl[0]
         else:
            commandsB = GLCAB()
            commandsB = commandsB.impl[0]
         if transformsAB is not None:
            if not isinstance(transformsAB, GLAB): transformsAB = GLAB(transformsAB)
            transformsAB = transformsAB.impl[0]
         else:
            transformsAB = GLAB()
            transformsAB = transformsAB.impl[0]
         self.impl = ffi.new("eC_GLMultiDraw *", {
                                'indexGLMB' : indexGLMB,
                                'vertexGLMB' : vertexGLMB,
                                'idsAB' : idsAB,
                                'commandsB' : commandsB,
                                'vao' : vao,
                                'commandsCount' : commandsCount,
                                'drawMode' : drawMode,
                                'commandsAlloced' : commandsAlloced,
                                'drawIDs' : drawIDs,
                                'commands' : commands,
                                'type' : type,
                                'idsAlloced' : idsAlloced,
                                'totalInstances' : totalInstances,
                                'vertexStride' : vertexStride,
                                'transformsAB' : transformsAB,
                                'transformSize' : transformSize,
                                'transforms' : transforms,
                                'lastTransformAB' : lastTransformAB,
                                'lastIDAB' : lastIDAB,
                                'lastVBO' : lastVBO,
                                'lastIBO' : lastIBO
                             })
         if ix32 is not None:            self.ix32                 = ix32

   @property
   def indexGLMB(self): return pyOrNewObject(GLMB, self.impl.indexGLMB)
   @indexGLMB.setter
   def indexGLMB(self, value):
      if not isinstance(value, GLMB): value = GLMB(value)
      self.impl.indexGLMB = value.impl

   @property
   def vertexGLMB(self): return pyOrNewObject(GLMB, self.impl.vertexGLMB)
   @vertexGLMB.setter
   def vertexGLMB(self, value):
      if not isinstance(value, GLMB): value = GLMB(value)
      self.impl.vertexGLMB = value.impl

   @property
   def idsAB(self): return GLAB(impl = self.impl.idsAB)
   @idsAB.setter
   def idsAB(self, value):
      if not isinstance(value, GLAB): value = GLAB(value)
      self.impl.idsAB = value.impl[0]

   @property
   def commandsB(self): return GLCAB(impl = self.impl.commandsB)
   @commandsB.setter
   def commandsB(self, value):
      if not isinstance(value, GLCAB): value = GLCAB(value)
      self.impl.commandsB = value.impl[0]

   @property
   def vao(self): return self.impl.vao
   @vao.setter
   def vao(self, value): self.impl.vao = value

   @property
   def commandsCount(self): return self.impl.commandsCount
   @commandsCount.setter
   def commandsCount(self, value): self.impl.commandsCount = value

   @property
   def drawMode(self): return self.impl.drawMode
   @drawMode.setter
   def drawMode(self, value): self.impl.drawMode = value

   @property
   def commandsAlloced(self): return self.impl.commandsAlloced
   @commandsAlloced.setter
   def commandsAlloced(self, value): self.impl.commandsAlloced = value

   @property
   def drawIDs(self): return self.impl.drawIDs
   @drawIDs.setter
   def drawIDs(self, value): self.impl.drawIDs = value

   @property
   def commands(self): return self.impl.commands
   @commands.setter
   def commands(self, value): self.impl.commands = value

   @property
   def type(self): return self.impl.type
   @type.setter
   def type(self, value): self.impl.type = value

   @property
   def idsAlloced(self): return self.impl.idsAlloced
   @idsAlloced.setter
   def idsAlloced(self, value): self.impl.idsAlloced = value

   @property
   def totalInstances(self): return self.impl.totalInstances
   @totalInstances.setter
   def totalInstances(self, value): self.impl.totalInstances = value

   @property
   def vertexStride(self): return self.impl.vertexStride
   @vertexStride.setter
   def vertexStride(self, value): self.impl.vertexStride = value

   @property
   def transformsAB(self): return GLAB(impl = self.impl.transformsAB)
   @transformsAB.setter
   def transformsAB(self, value):
      if not isinstance(value, GLAB): value = GLAB(value)
      self.impl.transformsAB = value.impl[0]

   @property
   def transformSize(self): return self.impl.transformSize
   @transformSize.setter
   def transformSize(self, value): self.impl.transformSize = value

   @property
   def transforms(self): return self.impl.transforms
   @transforms.setter
   def transforms(self, value): self.impl.transforms = value

   @property
   def lastTransformAB(self): return self.impl.lastTransformAB
   @lastTransformAB.setter
   def lastTransformAB(self, value): self.impl.lastTransformAB = value

   @property
   def lastIDAB(self): return self.impl.lastIDAB
   @lastIDAB.setter
   def lastIDAB(self, value): self.impl.lastIDAB = value

   @property
   def lastVBO(self): return self.impl.lastVBO
   @lastVBO.setter
   def lastVBO(self, value): self.impl.lastVBO = value

   @property
   def lastIBO(self): return self.impl.lastIBO
   @lastIBO.setter
   def lastIBO(self, value): self.impl.lastIBO = value

   @property
   def ix32(self): return None
   @ix32.setter
   def ix32(self, value):
      lib.GLMultiDraw_set_ix32(self.impl, value)

   def addDrawCommand(self, indexCount, instanceCount, firstIndex, baseVertex, baseInstance):
      lib.GLMultiDraw_addDrawCommand(ffi.cast("eC_GLMultiDraw *", self.impl), indexCount, instanceCount, firstIndex, baseVertex, baseInstance)

   def addDrawCommandCustomID(self, indexCount, instanceCount, firstIndex, baseVertex, baseInstance, layer):
      lib.GLMultiDraw_addDrawCommandCustomID(ffi.cast("eC_GLMultiDraw *", self.impl), indexCount, instanceCount, firstIndex, baseVertex, baseInstance, layer)

   def allocateIx(self, nIndices, indexSize, data):
      if hasattr(data, 'impl'): data = data.impl
      if data is None: data = ffi.NULL
      return lib.GLMultiDraw_allocateIx(ffi.cast("eC_GLMultiDraw *", self.impl), nIndices, indexSize, data)

   def allocateVbo(self, nVertices, vertexSize, data):
      if hasattr(data, 'impl'): data = data.impl
      if data is None: data = ffi.NULL
      return lib.GLMultiDraw_allocateVbo(ffi.cast("eC_GLMultiDraw *", self.impl), nVertices, vertexSize, data)

   def draw(self):
      lib.GLMultiDraw_draw(ffi.cast("eC_GLMultiDraw *", self.impl))

   def free(self):
      lib.GLMultiDraw_free(ffi.cast("eC_GLMultiDraw *", self.impl))

   def freeIx(self, baseIndex, indexSize, count):
      lib.GLMultiDraw_freeIx(ffi.cast("eC_GLMultiDraw *", self.impl), baseIndex, indexSize, count)

   def freeVbo(self, baseVertex, vertexSize, count):
      lib.GLMultiDraw_freeVbo(ffi.cast("eC_GLMultiDraw *", self.impl), baseVertex, vertexSize, count)

   def init(self, mode, minAlloc):
      lib.GLMultiDraw_init(ffi.cast("eC_GLMultiDraw *", self.impl), mode, minAlloc)

   def prepare(self, vertNCoords, verticesStride):
      lib.GLMultiDraw_prepare(ffi.cast("eC_GLMultiDraw *", self.impl), vertNCoords, verticesStride)

   def printStats(self):
      lib.GLMultiDraw_printStats(ffi.cast("eC_GLMultiDraw *", self.impl))

   def resize(self, size):
      lib.GLMultiDraw_resize(ffi.cast("eC_GLMultiDraw *", self.impl), size)

   def resizeCommands(self, size):
      lib.GLMultiDraw_resizeCommands(ffi.cast("eC_GLMultiDraw *", self.impl), size)

   def resizeIDs(self, size):
      lib.GLMultiDraw_resizeIDs(ffi.cast("eC_GLMultiDraw *", self.impl), size)

class GLTextureFilter:
   nearest = lib.GLTextureFilter_nearest
   linear  = lib.GLTextureFilter_linear

def gLMultisampling(value):
   lib.eC_gLMultisampling(value)

class AnchorValue(Struct):
   def __init__(self, type = None, distance = None, percent = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_AnchorValue *", impl)
      else:
         if isinstance(type, tuple):
            __tuple = type
            type = 0
            if len(__tuple) > 0: type     = __tuple[0]
            if len(__tuple) > 1: distance = __tuple[1]
         elif isinstance(type, MinMaxValue):
            self.impl = ffi.new("eC_AnchorValue *")
            lib.AnchorValue_from_MinMaxValue(self.impl, type.impl)
            return
         elif isinstance(type, int):
            self.impl = ffi.new("eC_AnchorValue *")
            lib.AnchorValue_from_int(self.impl, type)
            return
         elif isinstance(type, float):
            self.impl = ffi.new("eC_AnchorValue *")
            lib.AnchorValue_from_double(self.impl, type)
            return
         __members = { }
         if type is not None:     __members['type']     = type
         if distance is not None: __members['distance'] = distance
         if percent is not None:  __members['percent']  = percent
         self.impl = ffi.new("eC_AnchorValue *", __members)

   @property
   def type(self): return self.impl.type
   @type.setter
   def type(self, value): self.impl.type = value

   @property
   def distance(self): return self.impl.distance
   @distance.setter
   def distance(self, value): self.impl.distance = value

   @property
   def percent(self): return self.impl.percent
   @percent.setter
   def percent(self, value): self.impl.percent = value

   # def AnchorValue_to_MinMaxValue(self): return MinMaxValue(lib.AnchorValue_to_MinMaxValue(self.impl))

   # here is an unhandled conversion: AnchorValue::MinMaxValue (StructClass 2 UnitClass)
   # AnchorValue_to_MinMaxValue
   # AnchorValue_from_MinMaxValue

   def __int__(self): return lib.AnchorValue_to_int(self.impl)

   def __float__(self): return lib.AnchorValue_to_double(self.impl)

@ffi.callback("void(eC_Window, eC_MinMaxValue *, eC_MinMaxValue *)")
def cb_Window_getDecorationsSize(__e, w, h):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_getDecorationsSize(window, w, h)

@ffi.callback("eC_bool(eC_Window, int, int)")
def cb_Window_isInside(__e, x, y):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_isInside(window, x, y)

@ffi.callback("eC_bool(eC_Window, int, int, int, int)")
def cb_Window_isMouseMoving(__e, x, y, w, h):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_isMouseMoving(window, x, y, w, h)

@ffi.callback("eC_bool(eC_Window, int, int, int, int, eC_bool *, eC_bool *, eC_bool *, eC_bool *)")
def cb_Window_isMouseResizing(__e, x, y, w, h, resizeX, resizeY, resizeEndX, resizeEndY):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_isMouseResizing(window, x, y, w, h, resizeX, resizeY, resizeEndX, resizeEndY)

@ffi.callback("eC_bool(eC_Window)")
def cb_Window_isOpaque(__e):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_isOpaque(window)

@ffi.callback("eC_bool(eC_Window, eC_Window, eC_bool, eC_Window)")
def cb_Window_notifyActivate(__e, window, active, previous):
   window = pyOrNewObject(Window, window)
   return window.fn_Window_notifyActivate(pyOrNewObject(Window, __e), window, active, pyOrNewObject(Window, previous))

@ffi.callback("void(eC_Window, eC_Window, eC_DialogResult)")
def cb_Window_notifyDestroyed(__e, window, result):
   window = pyOrNewObject(Window, window)
   window.fn_Window_notifyDestroyed(pyOrNewObject(Window, __e), window, DialogResult(impl = result))

@ffi.callback("void(eC_Window, eC_Window, const char *)")
def cb_Window_notifySaved(__e, window, filePath):
   window = pyOrNewObject(Window, window)
   window.fn_Window_notifySaved(pyOrNewObject(Window, __e), window, filePath.encode('u8'))

@ffi.callback("eC_bool(eC_Window, eC_bool, eC_Window, eC_bool *, eC_bool)")
def cb_Window_onActivate(__e, active, previous, goOnWithActivation, direct):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onActivate(window, active, pyOrNewObject(Window, previous), goOnWithActivation, direct)

@ffi.callback("void(eC_Window, eC_Window, eC_Window)")
def cb_Window_onActivateClient(__e, client, previous):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onActivateClient(window, pyOrNewObject(Window, client), pyOrNewObject(Window, previous))

@ffi.callback("void(eC_Window)")
def cb_Window_onApplyGraphics(__e):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onApplyGraphics(window)

@ffi.callback("void(eC_Window, eC_Window, eC_bool)")
def cb_Window_onChildAddedOrRemoved(__e, child, removed):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onChildAddedOrRemoved(window, pyOrNewObject(Window, child), removed)

@ffi.callback("void(eC_Window, eC_Window, int, int, int, int)")
def cb_Window_onChildResized(__e, child, x, y, w, h):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onChildResized(window, pyOrNewObject(Window, child), x, y, w, h)

@ffi.callback("void(eC_Window, eC_Window, eC_bool)")
def cb_Window_onChildVisibilityToggled(__e, child, visible):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onChildVisibilityToggled(window, pyOrNewObject(Window, child), visible)

@ffi.callback("eC_bool(eC_Window, eC_bool)")
def cb_Window_onClose(__e, parentClosing):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onClose(window, parentClosing)

@ffi.callback("eC_bool(eC_Window)")
def cb_Window_onCreate(__e):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onCreate(window)

@ffi.callback("void(eC_Window)")
def cb_Window_onDestroy(__e):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onDestroy(window)

@ffi.callback("void(eC_Window)")
def cb_Window_onDestroyed(__e):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onDestroyed(window)

@ffi.callback("void(eC_Window, eC_Surface)")
def cb_Window_onDrawOverChildren(__e, surface):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onDrawOverChildren(window, pyOrNewObject(Surface, surface))

@ffi.callback("eC_bool(eC_Window, eC_FileChange, const char *)")
def cb_Window_onFileModified(__e, fileChange, param):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onFileModified(window, FileChange(impl = fileChange), param.encode('u8'))

@ffi.callback("void(eC_Window, eC_ScrollBarAction, int, eC_Key)")
def cb_Window_onHScroll(__e, action, position, key):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onHScroll(window, ScrollBarAction(impl = action), position, Key(impl = key))

@ffi.callback("eC_bool(eC_Window, eC_Key, unichar)")
def cb_Window_onKeyDown(__e, key, ch):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onKeyDown(window, Key(impl = key), ch)

@ffi.callback("eC_bool(eC_Window, eC_Key, unichar)")
def cb_Window_onKeyHit(__e, key, ch):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onKeyHit(window, Key(impl = key), ch)

@ffi.callback("eC_bool(eC_Window, eC_Key, unichar)")
def cb_Window_onKeyUp(__e, key, ch):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onKeyUp(window, Key(impl = key), ch)

@ffi.callback("eC_bool(eC_Window, int, int, eC_Modifiers)")
def cb_Window_onLeftButtonDown(__e, x, y, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onLeftButtonDown(window, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, int, int, eC_Modifiers)")
def cb_Window_onLeftButtonUp(__e, x, y, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onLeftButtonUp(window, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, int, int, eC_Modifiers)")
def cb_Window_onLeftDoubleClick(__e, x, y, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onLeftDoubleClick(window, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window)")
def cb_Window_onLoadGraphics(__e):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onLoadGraphics(window)

@ffi.callback("eC_bool(eC_Window, int, int, eC_Modifiers)")
def cb_Window_onMiddleButtonDown(__e, x, y, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onMiddleButtonDown(window, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, int, int, eC_Modifiers)")
def cb_Window_onMiddleButtonUp(__e, x, y, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onMiddleButtonUp(window, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, int, int, eC_Modifiers)")
def cb_Window_onMiddleDoubleClick(__e, x, y, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onMiddleDoubleClick(window, x, y, Modifiers(impl = mods))

@ffi.callback("void(eC_Window)")
def cb_Window_onMouseCaptureLost(__e):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onMouseCaptureLost(window)

@ffi.callback("eC_bool(eC_Window, eC_Modifiers)")
def cb_Window_onMouseLeave(__e, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onMouseLeave(window, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, int, int, eC_Modifiers)")
def cb_Window_onMouseMove(__e, x, y, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onMouseMove(window, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, int, int, eC_Modifiers)")
def cb_Window_onMouseOver(__e, x, y, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onMouseOver(window, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, int *, int *, int, int)")
def cb_Window_onMoving(__e, x, y, w, h):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onMoving(window, x, y, w, h)

@ffi.callback("eC_bool(eC_Window, eC_TouchPointerEvent, eC_Array, eC_Modifiers)")
def cb_Window_onMultiTouch(__e, event, infos, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onMultiTouch(window, TouchPointerEvent(impl = event), Array("<TouchPointerInfo>", impl = infos), Modifiers(impl = mods))

@ffi.callback("void(eC_Window, int, int, int, int)")
def cb_Window_onPosition(__e, x, y, width, height):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onPosition(window, x, y, width, height)

@ffi.callback("eC_bool(eC_Window)")
def cb_Window_onPostCreate(__e):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onPostCreate(window)

@ffi.callback("void(eC_Window, eC_Surface)")
def cb_Window_onRedraw(__e, surface):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onRedraw(window, pyOrNewObject(Surface, surface))

@ffi.callback("void(eC_Window, int, int)")
def cb_Window_onResize(__e, width, height):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onResize(window, width, height)

@ffi.callback("eC_bool(eC_Window, int *, int *)")
def cb_Window_onResizing(__e, width, height):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onResizing(window, width, height)

@ffi.callback("eC_bool(eC_Window, int, int, eC_Modifiers)")
def cb_Window_onRightButtonDown(__e, x, y, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onRightButtonDown(window, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, int, int, eC_Modifiers)")
def cb_Window_onRightButtonUp(__e, x, y, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onRightButtonUp(window, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, int, int, eC_Modifiers)")
def cb_Window_onRightDoubleClick(__e, x, y, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onRightDoubleClick(window, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, const char *)")
def cb_Window_onSaveFile(__e, fileName):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onSaveFile(window, fileName.encode('u8'))

@ffi.callback("eC_bool(eC_Window, eC_WindowState, eC_Modifiers)")
def cb_Window_onStateChange(__e, state, mods):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onStateChange(window, WindowState(impl = state), Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_Key, unichar)")
def cb_Window_onSysKeyDown(__e, key, ch):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onSysKeyDown(window, Key(impl = key), ch)

@ffi.callback("eC_bool(eC_Window, eC_Key, unichar)")
def cb_Window_onSysKeyHit(__e, key, ch):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onSysKeyHit(window, Key(impl = key), ch)

@ffi.callback("eC_bool(eC_Window, eC_Key, unichar)")
def cb_Window_onSysKeyUp(__e, key, ch):
   window = pyOrNewObject(Window, __e)
   return window.fn_Window_onSysKeyUp(window, Key(impl = key), ch)

@ffi.callback("void(eC_Window)")
def cb_Window_onUnloadGraphics(__e):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onUnloadGraphics(window)

@ffi.callback("void(eC_Window, eC_ScrollBarAction, int, eC_Key)")
def cb_Window_onVScroll(__e, action, position, key):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_onVScroll(window, ScrollBarAction(impl = action), position, Key(impl = key))

@ffi.callback("void(eC_Window, eC_Font *, eC_Surface, const char *, eC_bool, eC_bool)")
def cb_Window_preShowDecorations(__e, captionFont, surface, name, active, moving):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_preShowDecorations(window, Font(impl = captionFont), pyOrNewObject(Surface, surface), name.encode('u8'), active, moving)

@ffi.callback("void(eC_Window, eC_Box *)")
def cb_Window_setBox(__e, box):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_setBox(window, Box(impl = box))

@ffi.callback("void(eC_Window, int *, int *, eC_MinMaxValue *, eC_MinMaxValue *, eC_MinMaxValue *, eC_MinMaxValue *)")
def cb_Window_setWindowArea(__e, x, y, w, h, cw, ch):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_setWindowArea(window, x, y, w, h, cw, ch)

@ffi.callback("void(eC_Window, eC_MinMaxValue *, eC_MinMaxValue *)")
def cb_Window_setWindowMinimum(__e, mw, mh):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_setWindowMinimum(window, mw, mh)

@ffi.callback("void(eC_Window, eC_Font *, eC_Surface, const char *, eC_bool, eC_bool)")
def cb_Window_showDecorations(__e, captionFont, surface, name, active, moving):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_showDecorations(window, Font(impl = captionFont), pyOrNewObject(Surface, surface), name.encode('u8'), active, moving)

@ffi.callback("void(eC_Window)")
def cb_Window_updateNonClient(__e):
   window = pyOrNewObject(Window, __e)
   window.fn_Window_updateNonClient(window)

class Window(Instance):
   class_members = [
                      'parent',
                      'master',
                      'caption',
                      'hotKey',
                      'background',
                      'opacity',
                      'foreground',
                      'borderStyle',
                      'minClientSize',
                      'maxClientSize',
                      'hasMaximize',
                      'hasMinimize',
                      'hasClose',
                      'nonClient',
                      'inactive',
                      'clickThrough',
                      'isRemote',
                      'noCycle',
                      'isModal',
                      'interim',
                      'tabCycle',
                      'isDefault',
                      'drawBehind',
                      'hasMenuBar',
                      'hasStatusBar',
                      'stayOnTop',
                      'menu',
                      'font',
                      'sizeAnchor',
                      'size',
                      'clientSize',
                      'initSize',
                      'anchor',
                      'position',
                      'disabled',
                      'isEnabled',
                      'state',
                      'visible',
                      'isDocument',
                      'mergeMenus',
                      'hasHorzScroll',
                      'hasVertScroll',
                      'dontHideScroll',
                      'dontScrollVert',
                      'dontScrollHorz',
                      'snapVertScroll',
                      'snapHorzScroll',
                      'scroll',
                      'modifyVirtualArea',
                      'dontAutoScrollArea',
                      'fileName',
                      'id',
                      'modifiedDocument',
                      'showInTaskBar',
                      'saveDialog',
                      'isActiveClient',
                      'cursor',
                      'name',
                      'displayDriver',
                      'autoCreate',
                      'scrollArea',
                      'is3D',
                      'fontObject',
                      'clientStart',
                      'absPosition',
                      'normalAnchor',
                      'normalSizeAnchor',
                      'active',
                      'created',
                      'destroyed',
                      'firstSlave',
                      'firstChild',
                      'lastChild',
                      'activeClient',
                      'activeChild',
                      'display',
                      'displaySystem',
                      'horzScroll',
                      'vertScroll',
                      'statusBar',
                      'rootWindow',
                      'closing',
                      'documentID',
                      'previous',
                      'next',
                      'nextSlave',
                      'menuBar',
                      'sbv',
                      'sbh',
                      'fullRender',
                      'systemHandle',
                      'minimizeButton',
                      'maximizeButton',
                      'closeButton',
                      'icon',
                      'moveable',
                      'alphaBlend',
                      'useSharedMemory',
                      'glCapabilities',
                      'creationActivation',
                      'nativeDecorations',
                      'manageDisplay',
                      'text',
                      'controller',
                      'noConsequential',
                      'getDecorationsSize',
                      'isInside',
                      'isMouseMoving',
                      'isMouseResizing',
                      'isOpaque',
                      'notifyActivate',
                      'notifyDestroyed',
                      'notifySaved',
                      'onActivate',
                      'onActivateClient',
                      'onApplyGraphics',
                      'onChildAddedOrRemoved',
                      'onChildResized',
                      'onChildVisibilityToggled',
                      'onClose',
                      'onCreate',
                      'onDestroy',
                      'onDestroyed',
                      'onDrawOverChildren',
                      'onFileModified',
                      'onHScroll',
                      'onKeyDown',
                      'onKeyHit',
                      'onKeyUp',
                      'onLeftButtonDown',
                      'onLeftButtonUp',
                      'onLeftDoubleClick',
                      'onLoadGraphics',
                      'onMiddleButtonDown',
                      'onMiddleButtonUp',
                      'onMiddleDoubleClick',
                      'onMouseCaptureLost',
                      'onMouseLeave',
                      'onMouseMove',
                      'onMouseOver',
                      'onMoving',
                      'onMultiTouch',
                      'onPosition',
                      'onPostCreate',
                      'onRedraw',
                      'onResize',
                      'onResizing',
                      'onRightButtonDown',
                      'onRightButtonUp',
                      'onRightDoubleClick',
                      'onSaveFile',
                      'onStateChange',
                      'onSysKeyDown',
                      'onSysKeyHit',
                      'onSysKeyUp',
                      'onUnloadGraphics',
                      'onVScroll',
                      'preShowDecorations',
                      'setBox',
                      'setWindowArea',
                      'setWindowMinimum',
                      'showDecorations',
                      'updateNonClient',
                   ]

   def init_args(self, args, kwArgs): init_args(Window, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def parent(self): return pyOrNewObject(Window, lib.Window_get_parent(self.impl))
   @parent.setter
   def parent(self, value):
      if not isinstance(value, Window): value = Window(value)
      lib.Window_set_parent(self.impl, value.impl)

   @property
   def master(self): return pyOrNewObject(Window, lib.Window_get_master(self.impl))
   @master.setter
   def master(self, value):
      if not isinstance(value, Window): value = Window(value)
      lib.Window_set_master(self.impl, value.impl)

   @property
   def caption(self): value = lib.Window_get_caption(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @caption.setter
   def caption(self, value):
      lib.Window_set_caption(self.impl, value.encode('u8'))

   @property
   def hotKey(self): return Key(impl = lib.Window_get_hotKey(self.impl))
   @hotKey.setter
   def hotKey(self, value):
      if not isinstance(value, Key): value = Key(value)
      lib.Window_set_hotKey(self.impl, value.impl)

   @property
   def background(self): return Color(impl = lib.Window_get_background(self.impl))
   @background.setter
   def background(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.Window_set_background(self.impl, value.impl)

   @property
   def opacity(self): return Percentage(impl = lib.Window_get_opacity(self.impl))
   @opacity.setter
   def opacity(self, value):
      if not isinstance(value, Percentage): value = Percentage(value)
      lib.Window_set_opacity(self.impl, value.impl)

   @property
   def foreground(self): return Color(impl = lib.Window_get_foreground(self.impl))
   @foreground.setter
   def foreground(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.Window_set_foreground(self.impl, value.impl)

   @property
   def borderStyle(self): return lib.Window_get_borderStyle(self.impl)
   @borderStyle.setter
   def borderStyle(self, value):
      lib.Window_set_borderStyle(self.impl, value.impl)

   @property
   def minClientSize(self): value = Size(); lib.Window_get_minClientSize(self.impl, ffi.cast("eC_Size *", value.impl)); return value
   @minClientSize.setter
   def minClientSize(self, value):
      if not isinstance(value, Size): value = Size(value)
      lib.Window_set_minClientSize(self.impl, ffi.cast("eC_Size *", value.impl))

   @property
   def maxClientSize(self): value = Size(); lib.Window_get_maxClientSize(self.impl, ffi.cast("eC_Size *", value.impl)); return value
   @maxClientSize.setter
   def maxClientSize(self, value):
      if not isinstance(value, Size): value = Size(value)
      lib.Window_set_maxClientSize(self.impl, ffi.cast("eC_Size *", value.impl))

   @property
   def hasMaximize(self): return lib.Window_get_hasMaximize(self.impl)
   @hasMaximize.setter
   def hasMaximize(self, value):
      lib.Window_set_hasMaximize(self.impl, value)

   @property
   def hasMinimize(self): return lib.Window_get_hasMinimize(self.impl)
   @hasMinimize.setter
   def hasMinimize(self, value):
      lib.Window_set_hasMinimize(self.impl, value)

   @property
   def hasClose(self): return lib.Window_get_hasClose(self.impl)
   @hasClose.setter
   def hasClose(self, value):
      lib.Window_set_hasClose(self.impl, value)

   @property
   def nonClient(self): return lib.Window_get_nonClient(self.impl)
   @nonClient.setter
   def nonClient(self, value):
      lib.Window_set_nonClient(self.impl, value)

   @property
   def inactive(self): return lib.Window_get_inactive(self.impl)
   @inactive.setter
   def inactive(self, value):
      lib.Window_set_inactive(self.impl, value)

   @property
   def clickThrough(self): return lib.Window_get_clickThrough(self.impl)
   @clickThrough.setter
   def clickThrough(self, value):
      lib.Window_set_clickThrough(self.impl, value)

   @property
   def isRemote(self): return lib.Window_get_isRemote(self.impl)
   @isRemote.setter
   def isRemote(self, value):
      lib.Window_set_isRemote(self.impl, value)

   @property
   def noCycle(self): return lib.Window_get_noCycle(self.impl)
   @noCycle.setter
   def noCycle(self, value):
      lib.Window_set_noCycle(self.impl, value)

   @property
   def isModal(self): return lib.Window_get_isModal(self.impl)
   @isModal.setter
   def isModal(self, value):
      lib.Window_set_isModal(self.impl, value)

   @property
   def interim(self): return lib.Window_get_interim(self.impl)
   @interim.setter
   def interim(self, value):
      lib.Window_set_interim(self.impl, value)

   @property
   def tabCycle(self): return lib.Window_get_tabCycle(self.impl)
   @tabCycle.setter
   def tabCycle(self, value):
      lib.Window_set_tabCycle(self.impl, value)

   @property
   def isDefault(self): return lib.Window_get_isDefault(self.impl)
   @isDefault.setter
   def isDefault(self, value):
      lib.Window_set_isDefault(self.impl, value)

   @property
   def drawBehind(self): return lib.Window_get_drawBehind(self.impl)
   @drawBehind.setter
   def drawBehind(self, value):
      lib.Window_set_drawBehind(self.impl, value)

   @property
   def hasMenuBar(self): return lib.Window_get_hasMenuBar(self.impl)
   @hasMenuBar.setter
   def hasMenuBar(self, value):
      lib.Window_set_hasMenuBar(self.impl, value)

   @property
   def hasStatusBar(self): return lib.Window_get_hasStatusBar(self.impl)
   @hasStatusBar.setter
   def hasStatusBar(self, value):
      lib.Window_set_hasStatusBar(self.impl, value)

   @property
   def stayOnTop(self): return lib.Window_get_stayOnTop(self.impl)
   @stayOnTop.setter
   def stayOnTop(self, value):
      lib.Window_set_stayOnTop(self.impl, value)

   @property
   def menu(self): return pyOrNewObject(Menu, lib.Window_get_menu(self.impl))
   @menu.setter
   def menu(self, value):
      if not isinstance(value, Menu): value = Menu(value)
      lib.Window_set_menu(self.impl, value.impl)

   @property
   def font(self): return pyOrNewObject(FontResource, lib.Window_get_font(self.impl))
   @font.setter
   def font(self, value):
      if not isinstance(value, FontResource): value = FontResource(value)
      lib.Window_set_font(self.impl, value.impl)
   # @font.isset # tofix: how do we get isset?
   # def font(self): lib.Window_isSet_font(self.impl)

   @property
   def sizeAnchor(self): value = SizeAnchor(); lib.Window_get_sizeAnchor(self.impl, ffi.cast("eC_SizeAnchor *", value.impl)); return value
   @sizeAnchor.setter
   def sizeAnchor(self, value):
      if not isinstance(value, SizeAnchor): value = SizeAnchor(value)
      lib.Window_set_sizeAnchor(self.impl, ffi.cast("eC_SizeAnchor *", value.impl))
   # @sizeAnchor.isset # tofix: how do we get isset?
   # def sizeAnchor(self): lib.Window_isSet_sizeAnchor(self.impl)

   @property
   def size(self): value = Size(); lib.Window_get_size(self.impl, ffi.cast("eC_Size *", value.impl)); return value
   @size.setter
   def size(self, value):
      if not isinstance(value, Size): value = Size(value)
      lib.Window_set_size(self.impl, ffi.cast("eC_Size *", value.impl))
   # @size.isset # tofix: how do we get isset?
   # def size(self): lib.Window_isSet_size(self.impl)

   @property
   def clientSize(self): value = Size(); lib.Window_get_clientSize(self.impl, ffi.cast("eC_Size *", value.impl)); return value
   @clientSize.setter
   def clientSize(self, value):
      if not isinstance(value, Size): value = Size(value)
      lib.Window_set_clientSize(self.impl, ffi.cast("eC_Size *", value.impl))
   # @clientSize.isset # tofix: how do we get isset?
   # def clientSize(self): lib.Window_isSet_clientSize(self.impl)

   @property
   def initSize(self): value = Size(); lib.Window_get_initSize(self.impl, ffi.cast("eC_Size *", value.impl)); return value

   @property
   def anchor(self): value = Anchor(); lib.Window_get_anchor(self.impl, ffi.cast("eC_Anchor *", value.impl)); return value
   @anchor.setter
   def anchor(self, value):
      if not isinstance(value, Anchor): value = Anchor(value)
      lib.Window_set_anchor(self.impl, ffi.cast("eC_Anchor *", value.impl))
   # @anchor.isset # tofix: how do we get isset?
   # def anchor(self): lib.Window_isSet_anchor(self.impl)

   @property
   def position(self): value = Point(); lib.Window_get_position(self.impl, ffi.cast("eC_Point *", value.impl)); return value
   @position.setter
   def position(self, value):
      if not isinstance(value, Point): value = Point(value)
      lib.Window_set_position(self.impl, ffi.cast("eC_Point *", value.impl))

   @property
   def disabled(self): return lib.Window_get_disabled(self.impl)
   @disabled.setter
   def disabled(self, value):
      lib.Window_set_disabled(self.impl, value)

   @property
   def isEnabled(self): return lib.Window_get_isEnabled(self.impl)

   @property
   def state(self): return lib.Window_get_state(self.impl)
   @state.setter
   def state(self, value):
      lib.Window_set_state(self.impl, value)

   @property
   def visible(self): return lib.Window_get_visible(self.impl)
   @visible.setter
   def visible(self, value):
      lib.Window_set_visible(self.impl, value)

   @property
   def isDocument(self): return lib.Window_get_isDocument(self.impl)
   @isDocument.setter
   def isDocument(self, value):
      lib.Window_set_isDocument(self.impl, value)

   @property
   def mergeMenus(self): return lib.Window_get_mergeMenus(self.impl)
   @mergeMenus.setter
   def mergeMenus(self, value):
      lib.Window_set_mergeMenus(self.impl, value)

   @property
   def hasHorzScroll(self): return lib.Window_get_hasHorzScroll(self.impl)
   @hasHorzScroll.setter
   def hasHorzScroll(self, value):
      lib.Window_set_hasHorzScroll(self.impl, value)

   @property
   def hasVertScroll(self): return lib.Window_get_hasVertScroll(self.impl)
   @hasVertScroll.setter
   def hasVertScroll(self, value):
      lib.Window_set_hasVertScroll(self.impl, value)

   @property
   def dontHideScroll(self): return lib.Window_get_dontHideScroll(self.impl)
   @dontHideScroll.setter
   def dontHideScroll(self, value):
      lib.Window_set_dontHideScroll(self.impl, value)

   @property
   def dontScrollVert(self): return lib.Window_get_dontScrollVert(self.impl)
   @dontScrollVert.setter
   def dontScrollVert(self, value):
      lib.Window_set_dontScrollVert(self.impl, value)

   @property
   def dontScrollHorz(self): return lib.Window_get_dontScrollHorz(self.impl)
   @dontScrollHorz.setter
   def dontScrollHorz(self, value):
      lib.Window_set_dontScrollHorz(self.impl, value)

   @property
   def snapVertScroll(self): return lib.Window_get_snapVertScroll(self.impl)
   @snapVertScroll.setter
   def snapVertScroll(self, value):
      lib.Window_set_snapVertScroll(self.impl, value)

   @property
   def snapHorzScroll(self): return lib.Window_get_snapHorzScroll(self.impl)
   @snapHorzScroll.setter
   def snapHorzScroll(self, value):
      lib.Window_set_snapHorzScroll(self.impl, value)

   @property
   def scroll(self): value = Point(); lib.Window_get_scroll(self.impl, ffi.cast("eC_Point *", value.impl)); return value
   @scroll.setter
   def scroll(self, value):
      if not isinstance(value, Point): value = Point(value)
      lib.Window_set_scroll(self.impl, ffi.cast("eC_Point *", value.impl))

   @property
   def modifyVirtualArea(self): return lib.Window_get_modifyVirtualArea(self.impl)
   @modifyVirtualArea.setter
   def modifyVirtualArea(self, value):
      lib.Window_set_modifyVirtualArea(self.impl, value)

   @property
   def dontAutoScrollArea(self): return lib.Window_get_dontAutoScrollArea(self.impl)
   @dontAutoScrollArea.setter
   def dontAutoScrollArea(self, value):
      lib.Window_set_dontAutoScrollArea(self.impl, value)

   @property
   def fileName(self): value = lib.Window_get_fileName(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @fileName.setter
   def fileName(self, value):
      lib.Window_set_fileName(self.impl, value.encode('u8'))

   @property
   def id(self): return lib.Window_get_id(self.impl)
   @id.setter
   def id(self, value):
      lib.Window_set_id(self.impl, value)

   @property
   def modifiedDocument(self): return lib.Window_get_modifiedDocument(self.impl)
   @modifiedDocument.setter
   def modifiedDocument(self, value):
      lib.Window_set_modifiedDocument(self.impl, value)

   @property
   def showInTaskBar(self): return lib.Window_get_showInTaskBar(self.impl)
   @showInTaskBar.setter
   def showInTaskBar(self, value):
      lib.Window_set_showInTaskBar(self.impl, value)

   @property
   def saveDialog(self): return None
   @saveDialog.setter
   def saveDialog(self, value):
      if not isinstance(value, FileDialog): value = FileDialog(value)
      lib.Window_set_saveDialog(self.impl, value.impl)

   @property
   def isActiveClient(self): return lib.Window_get_isActiveClient(self.impl)
   @isActiveClient.setter
   def isActiveClient(self, value):
      lib.Window_set_isActiveClient(self.impl, value)

   @property
   def cursor(self): return pyOrNewObject(Cursor, lib.Window_get_cursor(self.impl))
   @cursor.setter
   def cursor(self, value):
      if not isinstance(value, Cursor): value = Cursor(value)
      lib.Window_set_cursor(self.impl, value.impl)

   @property
   def name(self): value = lib.Window_get_name(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @name.setter
   def name(self, value):
      lib.Window_set_name(self.impl, value.encode('u8'))

   @property
   def displayDriver(self): value = lib.Window_get_displayDriver(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @displayDriver.setter
   def displayDriver(self, value):
      lib.Window_set_displayDriver(self.impl, value.encode('u8'))

   @property
   def autoCreate(self): return lib.Window_get_autoCreate(self.impl)
   @autoCreate.setter
   def autoCreate(self, value):
      lib.Window_set_autoCreate(self.impl, value)

   @property
   def scrollArea(self): value = Size(); lib.Window_get_scrollArea(self.impl, ffi.cast("eC_Size *", value.impl)); return value
   @scrollArea.setter
   def scrollArea(self, value):
      if not isinstance(value, Size): value = Size(value)
      lib.Window_set_scrollArea(self.impl, ffi.cast("eC_Size *", value.impl))
   # @scrollArea.isset # tofix: how do we get isset?
   # def scrollArea(self): lib.Window_isSet_scrollArea(self.impl)

   @property
   def is3D(self): return lib.Window_get_is3D(self.impl)
   @is3D.setter
   def is3D(self, value):
      lib.Window_set_is3D(self.impl, value)

   @property
   def fontObject(self): return Font(impl = lib.Window_get_fontObject(self.impl))

   @property
   def clientStart(self): value = Point(); lib.Window_get_clientStart(self.impl, ffi.cast("eC_Point *", value.impl)); return value

   @property
   def absPosition(self): value = Point(); lib.Window_get_absPosition(self.impl, ffi.cast("eC_Point *", value.impl)); return value

   @property
   def normalAnchor(self): value = Anchor(); lib.Window_get_normalAnchor(self.impl, ffi.cast("eC_Anchor *", value.impl)); return value

   @property
   def normalSizeAnchor(self): value = SizeAnchor(); lib.Window_get_normalSizeAnchor(self.impl, ffi.cast("eC_SizeAnchor *", value.impl)); return value

   @property
   def active(self): return lib.Window_get_active(self.impl)

   @property
   def created(self): return lib.Window_get_created(self.impl)

   @property
   def destroyed(self): return lib.Window_get_destroyed(self.impl)

   @property
   def firstSlave(self): return pyOrNewObject(Window, lib.Window_get_firstSlave(self.impl))

   @property
   def firstChild(self): return pyOrNewObject(Window, lib.Window_get_firstChild(self.impl))

   @property
   def lastChild(self): return pyOrNewObject(Window, lib.Window_get_lastChild(self.impl))

   @property
   def activeClient(self): return pyOrNewObject(Window, lib.Window_get_activeClient(self.impl))

   @property
   def activeChild(self): return pyOrNewObject(Window, lib.Window_get_activeChild(self.impl))

   @property
   def display(self): return pyOrNewObject(Display, lib.Window_get_display(self.impl))

   @property
   def displaySystem(self): return pyOrNewObject(DisplaySystem, lib.Window_get_displaySystem(self.impl))

   @property
   def horzScroll(self): return pyOrNewObject(ScrollBar, lib.Window_get_horzScroll(self.impl))

   @property
   def vertScroll(self): return pyOrNewObject(ScrollBar, lib.Window_get_vertScroll(self.impl))

   @property
   def statusBar(self): return pyOrNewObject(StatusBar, lib.Window_get_statusBar(self.impl))

   @property
   def rootWindow(self): return pyOrNewObject(Window, lib.Window_get_rootWindow(self.impl))

   @property
   def closing(self): return lib.Window_get_closing(self.impl)
   @closing.setter
   def closing(self, value):
      lib.Window_set_closing(self.impl, value)

   @property
   def documentID(self): return lib.Window_get_documentID(self.impl)

   @property
   def previous(self): return pyOrNewObject(Window, lib.Window_get_previous(self.impl))

   @property
   def next(self): return pyOrNewObject(Window, lib.Window_get_next(self.impl))

   @property
   def nextSlave(self): return pyOrNewObject(Window, lib.Window_get_nextSlave(self.impl))

   @property
   def menuBar(self): return pyOrNewObject(PopupMenu, lib.Window_get_menuBar(self.impl))

   @property
   def sbv(self): return pyOrNewObject(ScrollBar, lib.Window_get_sbv(self.impl))

   @property
   def sbh(self): return pyOrNewObject(ScrollBar, lib.Window_get_sbh(self.impl))

   @property
   def fullRender(self): return lib.Window_get_fullRender(self.impl)
   @fullRender.setter
   def fullRender(self, value):
      lib.Window_set_fullRender(self.impl, value)

   @property
   def systemHandle(self): return lib.Window_get_systemHandle(self.impl)

   @property
   def minimizeButton(self): return pyOrNewObject(Button, lib.Window_get_minimizeButton(self.impl))

   @property
   def maximizeButton(self): return pyOrNewObject(Button, lib.Window_get_maximizeButton(self.impl))

   @property
   def closeButton(self): return pyOrNewObject(Button, lib.Window_get_closeButton(self.impl))

   @property
   def icon(self): return pyOrNewObject(BitmapResource, lib.Window_get_icon(self.impl))
   @icon.setter
   def icon(self, value):
      if not isinstance(value, BitmapResource): value = BitmapResource(value)
      lib.Window_set_icon(self.impl, value.impl)

   @property
   def moveable(self): return lib.Window_get_moveable(self.impl)
   @moveable.setter
   def moveable(self, value):
      lib.Window_set_moveable(self.impl, value)

   @property
   def alphaBlend(self): return lib.Window_get_alphaBlend(self.impl)
   @alphaBlend.setter
   def alphaBlend(self, value):
      lib.Window_set_alphaBlend(self.impl, value)

   @property
   def useSharedMemory(self): return lib.Window_get_useSharedMemory(self.impl)
   @useSharedMemory.setter
   def useSharedMemory(self, value):
      lib.Window_set_useSharedMemory(self.impl, value)

   @property
   def glCapabilities(self): return GLCapabilities(impl = lib.Window_get_glCapabilities(self.impl))
   @glCapabilities.setter
   def glCapabilities(self, value):
      if not isinstance(value, GLCapabilities): value = GLCapabilities(value)
      lib.Window_set_glCapabilities(self.impl, value.impl)

   @property
   def creationActivation(self): return lib.Window_get_creationActivation(self.impl)
   @creationActivation.setter
   def creationActivation(self, value):
      lib.Window_set_creationActivation(self.impl, value)

   @property
   def nativeDecorations(self): return lib.Window_get_nativeDecorations(self.impl)
   @nativeDecorations.setter
   def nativeDecorations(self, value):
      lib.Window_set_nativeDecorations(self.impl, value)
   # @nativeDecorations.isset # tofix: how do we get isset?
   # def nativeDecorations(self): lib.Window_isSet_nativeDecorations(self.impl)

   @property
   def manageDisplay(self): return lib.Window_get_manageDisplay(self.impl)
   @manageDisplay.setter
   def manageDisplay(self, value):
      lib.Window_set_manageDisplay(self.impl, value)

   @property
   def text(self): value = lib.Window_get_text(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @text.setter
   def text(self, value):
      lib.Window_set_text(self.impl, value.encode('u8'))

   @property
   def controller(self): return pyOrNewObject(WindowController, lib.Window_get_controller(self.impl))
   @controller.setter
   def controller(self, value):
      if not isinstance(value, WindowController): value = WindowController(value)
      lib.Window_set_controller(self.impl, value.impl)

   @property
   def noConsequential(self): return lib.Window_get_noConsequential(self.impl)
   @noConsequential.setter
   def noConsequential(self, value):
      lib.Window_set_noConsequential(self.impl, value)

   def acquireInput(self, acquired):
      return lib.Window_acquireInput(self.impl, acquired)

   def activate(self):
      lib.Window_activate(self.impl)

   def addResource(self, resource = None):
      if resource is not None and not isinstance(resource, Resource): resource = Resource(resource)
      resource = ffi.NULL if resource is None else resource.impl
      lib.Window_addResource(self.impl, resource)

   def buttonCloseDialog(self, button, x, y, mods):
      if button is not None and not isinstance(button, Button): button = Button(button)
      button = ffi.NULL if button is None else button.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_buttonCloseDialog(self.impl, button, x, y, mods)

   def capture(self):
      return lib.Window_capture(self.impl)

   def closeConfirmation(self, parentClosing):
      return lib.Window_closeConfirmation(self.impl, parentClosing)

   def create(self):
      return lib.Window_create(self.impl)

   def cycleChildren(self, backward, clientOnly, tabCycleOnly, cycleParents):
      return lib.Window_cycleChildren(self.impl, backward, clientOnly, tabCycleOnly, cycleParents)

   def deactivate(self):
      lib.Window_deactivate(self.impl)

   def destroy(self, code):
      return lib.Window_destroy(self.impl, code)

   def doModal(self):
      return lib.Window_doModal(self.impl)

   def doModalEnd(self):
      return lib.Window_doModalEnd(self.impl)

   def doModalLoop(self):
      return lib.Window_doModalLoop(self.impl)

   def doModalStart(self):
      lib.Window_doModalStart(self.impl)

   def externalPosition(self, x, y, w, h):
      lib.Window_externalPosition(self.impl, x, y, w, h)

   def flash(self):
      lib.Window_flash(self.impl)

   def freeMouseRange():
      lib.Window_freeMouseRange()

   def getCaretPosition(self, caretPos = None):
      if caretPos is not None and not isinstance(caretPos, Point): caretPos = Point(caretPos)
      caretPos = ffi.NULL if caretPos is None else caretPos.impl
      lib.Window_getCaretPosition(self.impl, ffi.cast("eC_Point *", caretPos))

   def getCaretSize(self):
      return lib.Window_getCaretSize(self.impl)

   def fn_unset_Window_getDecorationsSize(self, w, h):
      if w is None: w = ffi.NULL
      if h is None: h = ffi.NULL
      return lib.Window_getDecorationsSize(self.impl, w, h)

   @property
   def getDecorationsSize(self):
      if hasattr(self, 'fn_Window_getDecorationsSize'): return self.fn_Window_getDecorationsSize
      else: return self.fn_unset_Window_getDecorationsSize
   @getDecorationsSize.setter
   def getDecorationsSize(self, value):
      self.fn_Window_getDecorationsSize = value
      lib.Instance_setMethod(self.impl, "GetDecorationsSize".encode('u8'), cb_Window_getDecorationsSize)

   def getIcon(self, iconID):
      return pyOrNewObject(BitmapResource, lib.Window_getIcon(self.impl, iconID))

   def getMousePosition(self):
      x = ffi.new("int *")
      y = ffi.new("int *")
      lib.Window_getMousePosition(self.impl, x, y)
      return x[0], y[0]

   def getNCMousePosition(self):
      x = ffi.new("int *")
      y = ffi.new("int *")
      lib.Window_getNCMousePosition(self.impl, x, y)
      return x[0], y[0]

   def grab(self, bitmap, box, decorations):
      if bitmap is not None and not isinstance(bitmap, Bitmap): bitmap = Bitmap(bitmap)
      bitmap = ffi.NULL if bitmap is None else bitmap.impl
      if box is not None and not isinstance(box, Box): box = Box(box)
      box = ffi.NULL if box is None else box.impl
      return lib.Window_grab(self.impl, bitmap, ffi.cast("eC_Box *", box), decorations)

   def fn_unset_Window_isInside(self, x, y):
      return lib.Window_isInside(self.impl, x, y)

   @property
   def isInside(self):
      if hasattr(self, 'fn_Window_isInside'): return self.fn_Window_isInside
      else: return self.fn_unset_Window_isInside
   @isInside.setter
   def isInside(self, value):
      self.fn_Window_isInside = value
      lib.Instance_setMethod(self.impl, "IsInside".encode('u8'), cb_Window_isInside)

   def fn_unset_Window_isMouseMoving(self, x, y, w, h):
      return lib.Window_isMouseMoving(self.impl, x, y, w, h)

   @property
   def isMouseMoving(self):
      if hasattr(self, 'fn_Window_isMouseMoving'): return self.fn_Window_isMouseMoving
      else: return self.fn_unset_Window_isMouseMoving
   @isMouseMoving.setter
   def isMouseMoving(self, value):
      self.fn_Window_isMouseMoving = value
      lib.Instance_setMethod(self.impl, "IsMouseMoving".encode('u8'), cb_Window_isMouseMoving)

   def fn_unset_Window_isMouseResizing(self, x, y, w, h, resizeX, resizeY, resizeEndX, resizeEndY):
      if resizeX is None: resizeX = ffi.NULL
      if resizeY is None: resizeY = ffi.NULL
      if resizeEndX is None: resizeEndX = ffi.NULL
      if resizeEndY is None: resizeEndY = ffi.NULL
      return lib.Window_isMouseResizing(self.impl, x, y, w, h, resizeX, resizeY, resizeEndX, resizeEndY)

   @property
   def isMouseResizing(self):
      if hasattr(self, 'fn_Window_isMouseResizing'): return self.fn_Window_isMouseResizing
      else: return self.fn_unset_Window_isMouseResizing
   @isMouseResizing.setter
   def isMouseResizing(self, value):
      self.fn_Window_isMouseResizing = value
      lib.Instance_setMethod(self.impl, "IsMouseResizing".encode('u8'), cb_Window_isMouseResizing)

   def fn_unset_Window_isOpaque(self):
      return lib.Window_isOpaque(self.impl)

   @property
   def isOpaque(self):
      if hasattr(self, 'fn_Window_isOpaque'): return self.fn_Window_isOpaque
      else: return self.fn_unset_Window_isOpaque
   @isOpaque.setter
   def isOpaque(self, value):
      self.fn_Window_isOpaque = value
      lib.Instance_setMethod(self.impl, "IsOpaque".encode('u8'), cb_Window_isOpaque)

   def makeActive(self):
      lib.Window_makeActive(self.impl)

   def menuFileClose(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuFileClose(self.impl, selection, mods)

   def menuFileExit(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuFileExit(self.impl, selection, mods)

   def menuFileSave(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuFileSave(self.impl, selection, mods)

   def menuFileSaveAll(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuFileSaveAll(self.impl, selection, mods)

   def menuFileSaveAs(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuFileSaveAs(self.impl, selection, mods)

   def menuWindowArrangeIcons(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowArrangeIcons(self.impl, selection, mods)

   def menuWindowCascade(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowCascade(self.impl, selection, mods)

   def menuWindowClose(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowClose(self.impl, selection, mods)

   def menuWindowCloseAll(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowCloseAll(self.impl, selection, mods)

   def menuWindowMaximize(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowMaximize(self.impl, selection, mods)

   def menuWindowMinimize(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowMinimize(self.impl, selection, mods)

   def menuWindowMove(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowMove(self.impl, selection, mods)

   def menuWindowNext(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowNext(self.impl, selection, mods)

   def menuWindowPrevious(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowPrevious(self.impl, selection, mods)

   def menuWindowRestore(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowRestore(self.impl, selection, mods)

   def menuWindowSelectWindow(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowSelectWindow(self.impl, selection, mods)

   def menuWindowSize(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowSize(self.impl, selection, mods)

   def menuWindowStayOnTop(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowStayOnTop(self.impl, selection, mods)

   def menuWindowTileHorz(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowTileHorz(self.impl, selection, mods)

   def menuWindowTileVert(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowTileVert(self.impl, selection, mods)

   def menuWindowWindows(self, selection, mods):
      if selection is not None and not isinstance(selection, MenuItem): selection = MenuItem(selection)
      selection = ffi.NULL if selection is None else selection.impl
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      return lib.Window_menuWindowWindows(self.impl, selection, mods)

   def modal(self):
      return lib.Window_modal(self.impl)

   def mouseMessage(self, method, x, y, consequential, activate):
      mods = ffi.new("eC_Modifiers *")
      r = lib.Window_mouseMessage(self.impl, method, x, y, mods, consequential, activate)
      return r, Modifiers(impl = mods[0])

   def move(self, x, y, w, h):
      lib.Window_move(self.impl, x, y, w, h)

   def multiTouchMessage(self, event, infos, consequential, activate):
      mods = ffi.new("eC_Modifiers *")
      r = lib.Window_multiTouchMessage(self.impl, event, Array.impl, mods, consequential, activate)
      return r, Modifiers(impl = mods[0])

   def fn_unset_Window_notifyActivate(self, _ec_window, window, active, previous):
      return lib.Window_notifyActivate(self.impl, _ec_window.impl, ffi.NULL if window is None else window.impl, active, ffi.NULL if previous is None else previous.impl)

   @property
   def notifyActivate(self):
      if hasattr(self, 'fn_Window_notifyActivate'): return self.fn_Window_notifyActivate
      else: return self.fn_unset_Window_notifyActivate
   @notifyActivate.setter
   def notifyActivate(self, value):
      self.fn_Window_notifyActivate = value
      lib.Instance_setMethod(self.impl, "NotifyActivate".encode('u8'), cb_Window_notifyActivate)

   def fn_unset_Window_notifyDestroyed(self, _ec_window, window, result):
      return lib.Window_notifyDestroyed(self.impl, _ec_window.impl, ffi.NULL if window is None else window.impl, result)

   @property
   def notifyDestroyed(self):
      if hasattr(self, 'fn_Window_notifyDestroyed'): return self.fn_Window_notifyDestroyed
      else: return self.fn_unset_Window_notifyDestroyed
   @notifyDestroyed.setter
   def notifyDestroyed(self, value):
      self.fn_Window_notifyDestroyed = value
      lib.Instance_setMethod(self.impl, "NotifyDestroyed".encode('u8'), cb_Window_notifyDestroyed)

   def fn_unset_Window_notifySaved(self, _ec_window, window, filePath):
      return lib.Window_notifySaved(self.impl, _ec_window.impl, ffi.NULL if window is None else window.impl, filePath)

   @property
   def notifySaved(self):
      if hasattr(self, 'fn_Window_notifySaved'): return self.fn_Window_notifySaved
      else: return self.fn_unset_Window_notifySaved
   @notifySaved.setter
   def notifySaved(self, value):
      self.fn_Window_notifySaved = value
      lib.Instance_setMethod(self.impl, "NotifySaved".encode('u8'), cb_Window_notifySaved)

   def fn_unset_Window_onActivate(self, active, previous, goOnWithActivation, direct):
      if goOnWithActivation is None: goOnWithActivation = ffi.NULL
      return lib.Window_onActivate(self.impl, active, ffi.NULL if previous is None else previous.impl, goOnWithActivation, direct)

   @property
   def onActivate(self):
      if hasattr(self, 'fn_Window_onActivate'): return self.fn_Window_onActivate
      else: return self.fn_unset_Window_onActivate
   @onActivate.setter
   def onActivate(self, value):
      self.fn_Window_onActivate = value
      lib.Instance_setMethod(self.impl, "OnActivate".encode('u8'), cb_Window_onActivate)

   def fn_unset_Window_onActivateClient(self, client, previous):
      return lib.Window_onActivateClient(self.impl, ffi.NULL if client is None else client.impl, ffi.NULL if previous is None else previous.impl)

   @property
   def onActivateClient(self):
      if hasattr(self, 'fn_Window_onActivateClient'): return self.fn_Window_onActivateClient
      else: return self.fn_unset_Window_onActivateClient
   @onActivateClient.setter
   def onActivateClient(self, value):
      self.fn_Window_onActivateClient = value
      lib.Instance_setMethod(self.impl, "OnActivateClient".encode('u8'), cb_Window_onActivateClient)

   def fn_unset_Window_onApplyGraphics(self):
      return lib.Window_onApplyGraphics(self.impl)

   @property
   def onApplyGraphics(self):
      if hasattr(self, 'fn_Window_onApplyGraphics'): return self.fn_Window_onApplyGraphics
      else: return self.fn_unset_Window_onApplyGraphics
   @onApplyGraphics.setter
   def onApplyGraphics(self, value):
      self.fn_Window_onApplyGraphics = value
      lib.Instance_setMethod(self.impl, "OnApplyGraphics".encode('u8'), cb_Window_onApplyGraphics)

   def fn_unset_Window_onChildAddedOrRemoved(self, child, removed):
      return lib.Window_onChildAddedOrRemoved(self.impl, ffi.NULL if child is None else child.impl, removed)

   @property
   def onChildAddedOrRemoved(self):
      if hasattr(self, 'fn_Window_onChildAddedOrRemoved'): return self.fn_Window_onChildAddedOrRemoved
      else: return self.fn_unset_Window_onChildAddedOrRemoved
   @onChildAddedOrRemoved.setter
   def onChildAddedOrRemoved(self, value):
      self.fn_Window_onChildAddedOrRemoved = value
      lib.Instance_setMethod(self.impl, "OnChildAddedOrRemoved".encode('u8'), cb_Window_onChildAddedOrRemoved)

   def fn_unset_Window_onChildResized(self, child, x, y, w, h):
      return lib.Window_onChildResized(self.impl, ffi.NULL if child is None else child.impl, x, y, w, h)

   @property
   def onChildResized(self):
      if hasattr(self, 'fn_Window_onChildResized'): return self.fn_Window_onChildResized
      else: return self.fn_unset_Window_onChildResized
   @onChildResized.setter
   def onChildResized(self, value):
      self.fn_Window_onChildResized = value
      lib.Instance_setMethod(self.impl, "OnChildResized".encode('u8'), cb_Window_onChildResized)

   def fn_unset_Window_onChildVisibilityToggled(self, child, visible):
      return lib.Window_onChildVisibilityToggled(self.impl, ffi.NULL if child is None else child.impl, visible)

   @property
   def onChildVisibilityToggled(self):
      if hasattr(self, 'fn_Window_onChildVisibilityToggled'): return self.fn_Window_onChildVisibilityToggled
      else: return self.fn_unset_Window_onChildVisibilityToggled
   @onChildVisibilityToggled.setter
   def onChildVisibilityToggled(self, value):
      self.fn_Window_onChildVisibilityToggled = value
      lib.Instance_setMethod(self.impl, "OnChildVisibilityToggled".encode('u8'), cb_Window_onChildVisibilityToggled)

   def fn_unset_Window_onClose(self, parentClosing):
      return lib.Window_onClose(self.impl, parentClosing)

   @property
   def onClose(self):
      if hasattr(self, 'fn_Window_onClose'): return self.fn_Window_onClose
      else: return self.fn_unset_Window_onClose
   @onClose.setter
   def onClose(self, value):
      self.fn_Window_onClose = value
      lib.Instance_setMethod(self.impl, "OnClose".encode('u8'), cb_Window_onClose)

   def fn_unset_Window_onCreate(self):
      return lib.Window_onCreate(self.impl)

   @property
   def onCreate(self):
      if hasattr(self, 'fn_Window_onCreate'): return self.fn_Window_onCreate
      else: return self.fn_unset_Window_onCreate
   @onCreate.setter
   def onCreate(self, value):
      self.fn_Window_onCreate = value
      lib.Instance_setMethod(self.impl, "OnCreate".encode('u8'), cb_Window_onCreate)

   def fn_unset_Window_onDestroy(self):
      return lib.Window_onDestroy(self.impl)

   @property
   def onDestroy(self):
      if hasattr(self, 'fn_Window_onDestroy'): return self.fn_Window_onDestroy
      else: return self.fn_unset_Window_onDestroy
   @onDestroy.setter
   def onDestroy(self, value):
      self.fn_Window_onDestroy = value
      lib.Instance_setMethod(self.impl, "OnDestroy".encode('u8'), cb_Window_onDestroy)

   def fn_unset_Window_onDestroyed(self):
      return lib.Window_onDestroyed(self.impl)

   @property
   def onDestroyed(self):
      if hasattr(self, 'fn_Window_onDestroyed'): return self.fn_Window_onDestroyed
      else: return self.fn_unset_Window_onDestroyed
   @onDestroyed.setter
   def onDestroyed(self, value):
      self.fn_Window_onDestroyed = value
      lib.Instance_setMethod(self.impl, "OnDestroyed".encode('u8'), cb_Window_onDestroyed)

   def fn_unset_Window_onDrawOverChildren(self, surface):
      return lib.Window_onDrawOverChildren(self.impl, ffi.NULL if surface is None else surface.impl)

   @property
   def onDrawOverChildren(self):
      if hasattr(self, 'fn_Window_onDrawOverChildren'): return self.fn_Window_onDrawOverChildren
      else: return self.fn_unset_Window_onDrawOverChildren
   @onDrawOverChildren.setter
   def onDrawOverChildren(self, value):
      self.fn_Window_onDrawOverChildren = value
      lib.Instance_setMethod(self.impl, "OnDrawOverChildren".encode('u8'), cb_Window_onDrawOverChildren)

   def fn_unset_Window_onFileModified(self, fileChange, param):
      return lib.Window_onFileModified(self.impl, fileChange, param)

   @property
   def onFileModified(self):
      if hasattr(self, 'fn_Window_onFileModified'): return self.fn_Window_onFileModified
      else: return self.fn_unset_Window_onFileModified
   @onFileModified.setter
   def onFileModified(self, value):
      self.fn_Window_onFileModified = value
      lib.Instance_setMethod(self.impl, "OnFileModified".encode('u8'), cb_Window_onFileModified)

   def fn_unset_Window_onHScroll(self, action, position, key):
      return lib.Window_onHScroll(self.impl, action, position, key)

   @property
   def onHScroll(self):
      if hasattr(self, 'fn_Window_onHScroll'): return self.fn_Window_onHScroll
      else: return self.fn_unset_Window_onHScroll
   @onHScroll.setter
   def onHScroll(self, value):
      self.fn_Window_onHScroll = value
      lib.Instance_setMethod(self.impl, "OnHScroll".encode('u8'), cb_Window_onHScroll)

   def fn_unset_Window_onKeyDown(self, key, ch):
      return lib.Window_onKeyDown(self.impl, key, ch)

   @property
   def onKeyDown(self):
      if hasattr(self, 'fn_Window_onKeyDown'): return self.fn_Window_onKeyDown
      else: return self.fn_unset_Window_onKeyDown
   @onKeyDown.setter
   def onKeyDown(self, value):
      self.fn_Window_onKeyDown = value
      lib.Instance_setMethod(self.impl, "OnKeyDown".encode('u8'), cb_Window_onKeyDown)

   def fn_unset_Window_onKeyHit(self, key, ch):
      return lib.Window_onKeyHit(self.impl, key, ch)

   @property
   def onKeyHit(self):
      if hasattr(self, 'fn_Window_onKeyHit'): return self.fn_Window_onKeyHit
      else: return self.fn_unset_Window_onKeyHit
   @onKeyHit.setter
   def onKeyHit(self, value):
      self.fn_Window_onKeyHit = value
      lib.Instance_setMethod(self.impl, "OnKeyHit".encode('u8'), cb_Window_onKeyHit)

   def fn_unset_Window_onKeyUp(self, key, ch):
      return lib.Window_onKeyUp(self.impl, key, ch)

   @property
   def onKeyUp(self):
      if hasattr(self, 'fn_Window_onKeyUp'): return self.fn_Window_onKeyUp
      else: return self.fn_unset_Window_onKeyUp
   @onKeyUp.setter
   def onKeyUp(self, value):
      self.fn_Window_onKeyUp = value
      lib.Instance_setMethod(self.impl, "OnKeyUp".encode('u8'), cb_Window_onKeyUp)

   def fn_unset_Window_onLeftButtonDown(self, x, y, mods):
      return lib.Window_onLeftButtonDown(self.impl, x, y, mods)

   @property
   def onLeftButtonDown(self):
      if hasattr(self, 'fn_Window_onLeftButtonDown'): return self.fn_Window_onLeftButtonDown
      else: return self.fn_unset_Window_onLeftButtonDown
   @onLeftButtonDown.setter
   def onLeftButtonDown(self, value):
      self.fn_Window_onLeftButtonDown = value
      lib.Instance_setMethod(self.impl, "OnLeftButtonDown".encode('u8'), cb_Window_onLeftButtonDown)

   def fn_unset_Window_onLeftButtonUp(self, x, y, mods):
      return lib.Window_onLeftButtonUp(self.impl, x, y, mods)

   @property
   def onLeftButtonUp(self):
      if hasattr(self, 'fn_Window_onLeftButtonUp'): return self.fn_Window_onLeftButtonUp
      else: return self.fn_unset_Window_onLeftButtonUp
   @onLeftButtonUp.setter
   def onLeftButtonUp(self, value):
      self.fn_Window_onLeftButtonUp = value
      lib.Instance_setMethod(self.impl, "OnLeftButtonUp".encode('u8'), cb_Window_onLeftButtonUp)

   def fn_unset_Window_onLeftDoubleClick(self, x, y, mods):
      return lib.Window_onLeftDoubleClick(self.impl, x, y, mods)

   @property
   def onLeftDoubleClick(self):
      if hasattr(self, 'fn_Window_onLeftDoubleClick'): return self.fn_Window_onLeftDoubleClick
      else: return self.fn_unset_Window_onLeftDoubleClick
   @onLeftDoubleClick.setter
   def onLeftDoubleClick(self, value):
      self.fn_Window_onLeftDoubleClick = value
      lib.Instance_setMethod(self.impl, "OnLeftDoubleClick".encode('u8'), cb_Window_onLeftDoubleClick)

   def fn_unset_Window_onLoadGraphics(self):
      return lib.Window_onLoadGraphics(self.impl)

   @property
   def onLoadGraphics(self):
      if hasattr(self, 'fn_Window_onLoadGraphics'): return self.fn_Window_onLoadGraphics
      else: return self.fn_unset_Window_onLoadGraphics
   @onLoadGraphics.setter
   def onLoadGraphics(self, value):
      self.fn_Window_onLoadGraphics = value
      lib.Instance_setMethod(self.impl, "OnLoadGraphics".encode('u8'), cb_Window_onLoadGraphics)

   def fn_unset_Window_onMiddleButtonDown(self, x, y, mods):
      return lib.Window_onMiddleButtonDown(self.impl, x, y, mods)

   @property
   def onMiddleButtonDown(self):
      if hasattr(self, 'fn_Window_onMiddleButtonDown'): return self.fn_Window_onMiddleButtonDown
      else: return self.fn_unset_Window_onMiddleButtonDown
   @onMiddleButtonDown.setter
   def onMiddleButtonDown(self, value):
      self.fn_Window_onMiddleButtonDown = value
      lib.Instance_setMethod(self.impl, "OnMiddleButtonDown".encode('u8'), cb_Window_onMiddleButtonDown)

   def fn_unset_Window_onMiddleButtonUp(self, x, y, mods):
      return lib.Window_onMiddleButtonUp(self.impl, x, y, mods)

   @property
   def onMiddleButtonUp(self):
      if hasattr(self, 'fn_Window_onMiddleButtonUp'): return self.fn_Window_onMiddleButtonUp
      else: return self.fn_unset_Window_onMiddleButtonUp
   @onMiddleButtonUp.setter
   def onMiddleButtonUp(self, value):
      self.fn_Window_onMiddleButtonUp = value
      lib.Instance_setMethod(self.impl, "OnMiddleButtonUp".encode('u8'), cb_Window_onMiddleButtonUp)

   def fn_unset_Window_onMiddleDoubleClick(self, x, y, mods):
      return lib.Window_onMiddleDoubleClick(self.impl, x, y, mods)

   @property
   def onMiddleDoubleClick(self):
      if hasattr(self, 'fn_Window_onMiddleDoubleClick'): return self.fn_Window_onMiddleDoubleClick
      else: return self.fn_unset_Window_onMiddleDoubleClick
   @onMiddleDoubleClick.setter
   def onMiddleDoubleClick(self, value):
      self.fn_Window_onMiddleDoubleClick = value
      lib.Instance_setMethod(self.impl, "OnMiddleDoubleClick".encode('u8'), cb_Window_onMiddleDoubleClick)

   def fn_unset_Window_onMouseCaptureLost(self):
      return lib.Window_onMouseCaptureLost(self.impl)

   @property
   def onMouseCaptureLost(self):
      if hasattr(self, 'fn_Window_onMouseCaptureLost'): return self.fn_Window_onMouseCaptureLost
      else: return self.fn_unset_Window_onMouseCaptureLost
   @onMouseCaptureLost.setter
   def onMouseCaptureLost(self, value):
      self.fn_Window_onMouseCaptureLost = value
      lib.Instance_setMethod(self.impl, "OnMouseCaptureLost".encode('u8'), cb_Window_onMouseCaptureLost)

   def fn_unset_Window_onMouseLeave(self, mods):
      return lib.Window_onMouseLeave(self.impl, mods)

   @property
   def onMouseLeave(self):
      if hasattr(self, 'fn_Window_onMouseLeave'): return self.fn_Window_onMouseLeave
      else: return self.fn_unset_Window_onMouseLeave
   @onMouseLeave.setter
   def onMouseLeave(self, value):
      self.fn_Window_onMouseLeave = value
      lib.Instance_setMethod(self.impl, "OnMouseLeave".encode('u8'), cb_Window_onMouseLeave)

   def fn_unset_Window_onMouseMove(self, x, y, mods):
      return lib.Window_onMouseMove(self.impl, x, y, mods)

   @property
   def onMouseMove(self):
      if hasattr(self, 'fn_Window_onMouseMove'): return self.fn_Window_onMouseMove
      else: return self.fn_unset_Window_onMouseMove
   @onMouseMove.setter
   def onMouseMove(self, value):
      self.fn_Window_onMouseMove = value
      lib.Instance_setMethod(self.impl, "OnMouseMove".encode('u8'), cb_Window_onMouseMove)

   def fn_unset_Window_onMouseOver(self, x, y, mods):
      return lib.Window_onMouseOver(self.impl, x, y, mods)

   @property
   def onMouseOver(self):
      if hasattr(self, 'fn_Window_onMouseOver'): return self.fn_Window_onMouseOver
      else: return self.fn_unset_Window_onMouseOver
   @onMouseOver.setter
   def onMouseOver(self, value):
      self.fn_Window_onMouseOver = value
      lib.Instance_setMethod(self.impl, "OnMouseOver".encode('u8'), cb_Window_onMouseOver)

   def fn_unset_Window_onMoving(self, x, y, w, h):
      if x is None: x = ffi.NULL
      if y is None: y = ffi.NULL
      return lib.Window_onMoving(self.impl, x, y, w, h)

   @property
   def onMoving(self):
      if hasattr(self, 'fn_Window_onMoving'): return self.fn_Window_onMoving
      else: return self.fn_unset_Window_onMoving
   @onMoving.setter
   def onMoving(self, value):
      self.fn_Window_onMoving = value
      lib.Instance_setMethod(self.impl, "OnMoving".encode('u8'), cb_Window_onMoving)

   def fn_unset_Window_onMultiTouch(self, event, infos, mods):
      return lib.Window_onMultiTouch(self.impl, event, ffi.NULL if infos is None else infos.impl, mods)

   @property
   def onMultiTouch(self):
      if hasattr(self, 'fn_Window_onMultiTouch'): return self.fn_Window_onMultiTouch
      else: return self.fn_unset_Window_onMultiTouch
   @onMultiTouch.setter
   def onMultiTouch(self, value):
      self.fn_Window_onMultiTouch = value
      lib.Instance_setMethod(self.impl, "OnMultiTouch".encode('u8'), cb_Window_onMultiTouch)

   def fn_unset_Window_onPosition(self, x, y, width, height):
      return lib.Window_onPosition(self.impl, x, y, width, height)

   @property
   def onPosition(self):
      if hasattr(self, 'fn_Window_onPosition'): return self.fn_Window_onPosition
      else: return self.fn_unset_Window_onPosition
   @onPosition.setter
   def onPosition(self, value):
      self.fn_Window_onPosition = value
      lib.Instance_setMethod(self.impl, "OnPosition".encode('u8'), cb_Window_onPosition)

   def fn_unset_Window_onPostCreate(self):
      return lib.Window_onPostCreate(self.impl)

   @property
   def onPostCreate(self):
      if hasattr(self, 'fn_Window_onPostCreate'): return self.fn_Window_onPostCreate
      else: return self.fn_unset_Window_onPostCreate
   @onPostCreate.setter
   def onPostCreate(self, value):
      self.fn_Window_onPostCreate = value
      lib.Instance_setMethod(self.impl, "OnPostCreate".encode('u8'), cb_Window_onPostCreate)

   def fn_unset_Window_onRedraw(self, surface):
      return lib.Window_onRedraw(self.impl, ffi.NULL if surface is None else surface.impl)

   @property
   def onRedraw(self):
      if hasattr(self, 'fn_Window_onRedraw'): return self.fn_Window_onRedraw
      else: return self.fn_unset_Window_onRedraw
   @onRedraw.setter
   def onRedraw(self, value):
      self.fn_Window_onRedraw = value
      lib.Instance_setMethod(self.impl, "OnRedraw".encode('u8'), cb_Window_onRedraw)

   def fn_unset_Window_onResize(self, width, height):
      return lib.Window_onResize(self.impl, width, height)

   @property
   def onResize(self):
      if hasattr(self, 'fn_Window_onResize'): return self.fn_Window_onResize
      else: return self.fn_unset_Window_onResize
   @onResize.setter
   def onResize(self, value):
      self.fn_Window_onResize = value
      lib.Instance_setMethod(self.impl, "OnResize".encode('u8'), cb_Window_onResize)

   def fn_unset_Window_onResizing(self, width, height):
      if width is None: width = ffi.NULL
      if height is None: height = ffi.NULL
      return lib.Window_onResizing(self.impl, width, height)

   @property
   def onResizing(self):
      if hasattr(self, 'fn_Window_onResizing'): return self.fn_Window_onResizing
      else: return self.fn_unset_Window_onResizing
   @onResizing.setter
   def onResizing(self, value):
      self.fn_Window_onResizing = value
      lib.Instance_setMethod(self.impl, "OnResizing".encode('u8'), cb_Window_onResizing)

   def fn_unset_Window_onRightButtonDown(self, x, y, mods):
      return lib.Window_onRightButtonDown(self.impl, x, y, mods)

   @property
   def onRightButtonDown(self):
      if hasattr(self, 'fn_Window_onRightButtonDown'): return self.fn_Window_onRightButtonDown
      else: return self.fn_unset_Window_onRightButtonDown
   @onRightButtonDown.setter
   def onRightButtonDown(self, value):
      self.fn_Window_onRightButtonDown = value
      lib.Instance_setMethod(self.impl, "OnRightButtonDown".encode('u8'), cb_Window_onRightButtonDown)

   def fn_unset_Window_onRightButtonUp(self, x, y, mods):
      return lib.Window_onRightButtonUp(self.impl, x, y, mods)

   @property
   def onRightButtonUp(self):
      if hasattr(self, 'fn_Window_onRightButtonUp'): return self.fn_Window_onRightButtonUp
      else: return self.fn_unset_Window_onRightButtonUp
   @onRightButtonUp.setter
   def onRightButtonUp(self, value):
      self.fn_Window_onRightButtonUp = value
      lib.Instance_setMethod(self.impl, "OnRightButtonUp".encode('u8'), cb_Window_onRightButtonUp)

   def fn_unset_Window_onRightDoubleClick(self, x, y, mods):
      return lib.Window_onRightDoubleClick(self.impl, x, y, mods)

   @property
   def onRightDoubleClick(self):
      if hasattr(self, 'fn_Window_onRightDoubleClick'): return self.fn_Window_onRightDoubleClick
      else: return self.fn_unset_Window_onRightDoubleClick
   @onRightDoubleClick.setter
   def onRightDoubleClick(self, value):
      self.fn_Window_onRightDoubleClick = value
      lib.Instance_setMethod(self.impl, "OnRightDoubleClick".encode('u8'), cb_Window_onRightDoubleClick)

   def fn_unset_Window_onSaveFile(self, fileName):
      return lib.Window_onSaveFile(self.impl, fileName)

   @property
   def onSaveFile(self):
      if hasattr(self, 'fn_Window_onSaveFile'): return self.fn_Window_onSaveFile
      else: return self.fn_unset_Window_onSaveFile
   @onSaveFile.setter
   def onSaveFile(self, value):
      self.fn_Window_onSaveFile = value
      lib.Instance_setMethod(self.impl, "OnSaveFile".encode('u8'), cb_Window_onSaveFile)

   def fn_unset_Window_onStateChange(self, state, mods):
      return lib.Window_onStateChange(self.impl, state, mods)

   @property
   def onStateChange(self):
      if hasattr(self, 'fn_Window_onStateChange'): return self.fn_Window_onStateChange
      else: return self.fn_unset_Window_onStateChange
   @onStateChange.setter
   def onStateChange(self, value):
      self.fn_Window_onStateChange = value
      lib.Instance_setMethod(self.impl, "OnStateChange".encode('u8'), cb_Window_onStateChange)

   def fn_unset_Window_onSysKeyDown(self, key, ch):
      return lib.Window_onSysKeyDown(self.impl, key, ch)

   @property
   def onSysKeyDown(self):
      if hasattr(self, 'fn_Window_onSysKeyDown'): return self.fn_Window_onSysKeyDown
      else: return self.fn_unset_Window_onSysKeyDown
   @onSysKeyDown.setter
   def onSysKeyDown(self, value):
      self.fn_Window_onSysKeyDown = value
      lib.Instance_setMethod(self.impl, "OnSysKeyDown".encode('u8'), cb_Window_onSysKeyDown)

   def fn_unset_Window_onSysKeyHit(self, key, ch):
      return lib.Window_onSysKeyHit(self.impl, key, ch)

   @property
   def onSysKeyHit(self):
      if hasattr(self, 'fn_Window_onSysKeyHit'): return self.fn_Window_onSysKeyHit
      else: return self.fn_unset_Window_onSysKeyHit
   @onSysKeyHit.setter
   def onSysKeyHit(self, value):
      self.fn_Window_onSysKeyHit = value
      lib.Instance_setMethod(self.impl, "OnSysKeyHit".encode('u8'), cb_Window_onSysKeyHit)

   def fn_unset_Window_onSysKeyUp(self, key, ch):
      return lib.Window_onSysKeyUp(self.impl, key, ch)

   @property
   def onSysKeyUp(self):
      if hasattr(self, 'fn_Window_onSysKeyUp'): return self.fn_Window_onSysKeyUp
      else: return self.fn_unset_Window_onSysKeyUp
   @onSysKeyUp.setter
   def onSysKeyUp(self, value):
      self.fn_Window_onSysKeyUp = value
      lib.Instance_setMethod(self.impl, "OnSysKeyUp".encode('u8'), cb_Window_onSysKeyUp)

   def fn_unset_Window_onUnloadGraphics(self):
      return lib.Window_onUnloadGraphics(self.impl)

   @property
   def onUnloadGraphics(self):
      if hasattr(self, 'fn_Window_onUnloadGraphics'): return self.fn_Window_onUnloadGraphics
      else: return self.fn_unset_Window_onUnloadGraphics
   @onUnloadGraphics.setter
   def onUnloadGraphics(self, value):
      self.fn_Window_onUnloadGraphics = value
      lib.Instance_setMethod(self.impl, "OnUnloadGraphics".encode('u8'), cb_Window_onUnloadGraphics)

   def fn_unset_Window_onVScroll(self, action, position, key):
      return lib.Window_onVScroll(self.impl, action, position, key)

   @property
   def onVScroll(self):
      if hasattr(self, 'fn_Window_onVScroll'): return self.fn_Window_onVScroll
      else: return self.fn_unset_Window_onVScroll
   @onVScroll.setter
   def onVScroll(self, value):
      self.fn_Window_onVScroll = value
      lib.Instance_setMethod(self.impl, "OnVScroll".encode('u8'), cb_Window_onVScroll)

   def fn_unset_Window_preShowDecorations(self, captionFont, surface, name, active, moving):
      return lib.Window_preShowDecorations(self.impl, ffi.NULL if captionFont is None else captionFont.impl, ffi.NULL if surface is None else surface.impl, name, active, moving)

   @property
   def preShowDecorations(self):
      if hasattr(self, 'fn_Window_preShowDecorations'): return self.fn_Window_preShowDecorations
      else: return self.fn_unset_Window_preShowDecorations
   @preShowDecorations.setter
   def preShowDecorations(self, value):
      self.fn_Window_preShowDecorations = value
      lib.Instance_setMethod(self.impl, "PreShowDecorations".encode('u8'), cb_Window_preShowDecorations)

   def releaseCapture(self):
      lib.Window_releaseCapture(self.impl)

   def removeResource(self, resource = None):
      if resource is not None and not isinstance(resource, Resource): resource = Resource(resource)
      resource = ffi.NULL if resource is None else resource.impl
      lib.Window_removeResource(self.impl, resource)

   def restoreCaret():
      lib.Window_restoreCaret()

   def scroll(self, x, y):
      lib.Window_scroll(self.impl, x, y)

   def fn_unset_Window_setBox(self, box):
      return lib.Window_setBox(self.impl, ffi.NULL if box is None else box.impl)

   @property
   def setBox(self):
      if hasattr(self, 'fn_Window_setBox'): return self.fn_Window_setBox
      else: return self.fn_unset_Window_setBox
   @setBox.setter
   def setBox(self, value):
      self.fn_Window_setBox = value
      lib.Instance_setMethod(self.impl, "SetBox".encode('u8'), cb_Window_setBox)

   def setCaption(self, format, *args):
      if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
      elif format is None: format = ffi.NULL
      lib.Window_setCaption(self.impl, format, *ellipsisArgs(args))

   def setCaret(self, x, y, size):
      lib.Window_setCaret(self.impl, x, y, size)

   def setMousePosition(self, x, y):
      lib.Window_setMousePosition(self.impl, x, y)

   def setMouseRange(self, range = None):
      if range is not None and not isinstance(range, Box): range = Box(range)
      range = ffi.NULL if range is None else range.impl
      lib.Window_setMouseRange(self.impl, ffi.cast("eC_Box *", range))

   def setMouseRangeToClient(self):
      lib.Window_setMouseRangeToClient(self.impl)

   def setMouseRangeToWindow(self):
      lib.Window_setMouseRangeToWindow(self.impl)

   def setScrollArea(self, width, height, snapToStep):
      lib.Window_setScrollArea(self.impl, width, height, snapToStep)

   def setScrollLineStep(self, stepX, stepY):
      lib.Window_setScrollLineStep(self.impl, stepX, stepY)

   def setScrollPosition(self, x, y):
      lib.Window_setScrollPosition(self.impl, x, y)

   def setState(self, newState, activate, mods):
      if mods is not None and not isinstance(mods, Modifiers): mods = Modifiers(mods)
      if mods is None: mods = ffi.NULL
      lib.Window_setState(self.impl, newState, activate, mods)

   def setText(self, format, *args):
      if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
      elif format is None: format = ffi.NULL
      lib.Window_setText(self.impl, format, *ellipsisArgs(args))

   def fn_unset_Window_setWindowArea(self, x, y, w, h, cw, ch):
      if x is None: x = ffi.NULL
      if y is None: y = ffi.NULL
      if w is None: w = ffi.NULL
      if h is None: h = ffi.NULL
      if cw is None: cw = ffi.NULL
      if ch is None: ch = ffi.NULL
      return lib.Window_setWindowArea(self.impl, x, y, w, h, cw, ch)

   @property
   def setWindowArea(self):
      if hasattr(self, 'fn_Window_setWindowArea'): return self.fn_Window_setWindowArea
      else: return self.fn_unset_Window_setWindowArea
   @setWindowArea.setter
   def setWindowArea(self, value):
      self.fn_Window_setWindowArea = value
      lib.Instance_setMethod(self.impl, "SetWindowArea".encode('u8'), cb_Window_setWindowArea)

   def fn_unset_Window_setWindowMinimum(self, mw, mh):
      if mw is None: mw = ffi.NULL
      if mh is None: mh = ffi.NULL
      return lib.Window_setWindowMinimum(self.impl, mw, mh)

   @property
   def setWindowMinimum(self):
      if hasattr(self, 'fn_Window_setWindowMinimum'): return self.fn_Window_setWindowMinimum
      else: return self.fn_unset_Window_setWindowMinimum
   @setWindowMinimum.setter
   def setWindowMinimum(self, value):
      self.fn_Window_setWindowMinimum = value
      lib.Instance_setMethod(self.impl, "SetWindowMinimum".encode('u8'), cb_Window_setWindowMinimum)

   def fn_unset_Window_showDecorations(self, captionFont, surface, name, active, moving):
      return lib.Window_showDecorations(self.impl, ffi.NULL if captionFont is None else captionFont.impl, ffi.NULL if surface is None else surface.impl, name, active, moving)

   @property
   def showDecorations(self):
      if hasattr(self, 'fn_Window_showDecorations'): return self.fn_Window_showDecorations
      else: return self.fn_unset_Window_showDecorations
   @showDecorations.setter
   def showDecorations(self, value):
      self.fn_Window_showDecorations = value
      lib.Instance_setMethod(self.impl, "ShowDecorations".encode('u8'), cb_Window_showDecorations)

   def showSysMenu(self, x, y):
      lib.Window_showSysMenu(self.impl, x, y)

   def softActivate(self):
      lib.Window_softActivate(self.impl)

   def update(self, region = None):
      if region is not None and not isinstance(region, Box): region = Box(region)
      region = ffi.NULL if region is None else region.impl
      lib.Window_update(self.impl, ffi.cast("eC_Box *", region))

   def updateDisplay(self):
      lib.Window_updateDisplay(self.impl)

   def fn_unset_Window_updateNonClient(self):
      return lib.Window_updateNonClient(self.impl)

   @property
   def updateNonClient(self):
      if hasattr(self, 'fn_Window_updateNonClient'): return self.fn_Window_updateNonClient
      else: return self.fn_unset_Window_updateNonClient
   @updateNonClient.setter
   def updateNonClient(self, value):
      self.fn_Window_updateNonClient = value
      lib.Instance_setMethod(self.impl, "UpdateNonClient".encode('u8'), cb_Window_updateNonClient)

   def writeCaption(self, surface, x, y):
      if surface is not None and not isinstance(surface, Surface): surface = Surface(surface)
      surface = ffi.NULL if surface is None else surface.impl
      lib.Window_writeCaption(self.impl, surface, x, y)

class CommonControl(Window):
   class_members = [
                      'toolTip',
                   ]

   def init_args(self, args, kwArgs): init_args(CommonControl, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def toolTip(self): value = lib.CommonControl_get_toolTip(self.impl) if self is not None and self.impl != ffi.NULL else ffi.NULL; return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @toolTip.setter
   def toolTip(self, value):
      if not isinstance(value, String): value = String(value)
      lib.CommonControl_set_toolTip(self.impl, value.impl.encode('u8'))

@ffi.callback("eC_bool(eC_Window, eC_Button, int, int, eC_Modifiers)")
def cb_Button_notifyClicked(__e, button, x, y, mods):
   button = pyOrNewObject(Button, button)
   return button.fn_Button_notifyClicked(pyOrNewObject(Button, __e), button, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_Button, int, int, eC_Modifiers)")
def cb_Button_notifyDoubleClick(__e, button, x, y, mods):
   button = pyOrNewObject(Button, button)
   return button.fn_Button_notifyDoubleClick(pyOrNewObject(Button, __e), button, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_Button, eC_Modifiers)")
def cb_Button_notifyMouseLeave(__e, button, mods):
   button = pyOrNewObject(Button, button)
   return button.fn_Button_notifyMouseLeave(pyOrNewObject(Button, __e), button, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_Button, int, int, eC_Modifiers)")
def cb_Button_notifyMouseMove(__e, button, x, y, mods):
   button = pyOrNewObject(Button, button)
   return button.fn_Button_notifyMouseMove(pyOrNewObject(Button, __e), button, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_Button, int, int, eC_Modifiers)")
def cb_Button_notifyMouseOver(__e, button, x, y, mods):
   button = pyOrNewObject(Button, button)
   return button.fn_Button_notifyMouseOver(pyOrNewObject(Button, __e), button, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_Button, int, int, eC_Modifiers)")
def cb_Button_notifyPushed(__e, button, x, y, mods):
   button = pyOrNewObject(Button, button)
   return button.fn_Button_notifyPushed(pyOrNewObject(Button, __e), button, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_Button, int, int, eC_Modifiers)")
def cb_Button_notifyReleased(__e, button, x, y, mods):
   button = pyOrNewObject(Button, button)
   return button.fn_Button_notifyReleased(pyOrNewObject(Button, __e), button, x, y, Modifiers(impl = mods))

class Button(CommonControl):
   class_members = [
                      'opacity',
                      'drawBehind',
                      'isRadio',
                      'isCheckbox',
                      'bevel',
                      'bevelOver',
                      'toggle',
                      'checked',
                      'alignment',
                      'bitmap',
                      'stayUp',
                      'scaleBitmap',
                      'keyRepeat',
                      'symbol',
                      'ellipsis',
                      'stayDown',
                      'offset',
                      'buttonState',
                      'bitmapAlignment',
                      'notifyClicked',
                      'notifyDoubleClick',
                      'notifyMouseLeave',
                      'notifyMouseMove',
                      'notifyMouseOver',
                      'notifyPushed',
                      'notifyReleased',
                   ]

   def init_args(self, args, kwArgs): init_args(Button, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def opacity(self): return Percentage(impl = lib.Button_get_opacity(self.impl))
   @opacity.setter
   def opacity(self, value):
      if not isinstance(value, Percentage): value = Percentage(value)
      lib.Button_set_opacity(self.impl, value.impl)
   # @opacity.isset # tofix: how do we get isset?
   # def opacity(self): lib.Button_isSet_opacity(self.impl)

   @property
   def drawBehind(self): return lib.Button_get_drawBehind(self.impl)
   @drawBehind.setter
   def drawBehind(self, value):
      lib.Button_set_drawBehind(self.impl, value)
   # @drawBehind.isset # tofix: how do we get isset?
   # def drawBehind(self): lib.Button_isSet_drawBehind(self.impl)

   @property
   def isRadio(self): return lib.Button_get_isRadio(self.impl)
   @isRadio.setter
   def isRadio(self, value):
      lib.Button_set_isRadio(self.impl, value)

   @property
   def isCheckbox(self): return lib.Button_get_isCheckbox(self.impl)
   @isCheckbox.setter
   def isCheckbox(self, value):
      lib.Button_set_isCheckbox(self.impl, value)

   @property
   def bevel(self): return lib.Button_get_bevel(self.impl)
   @bevel.setter
   def bevel(self, value):
      lib.Button_set_bevel(self.impl, value)

   @property
   def bevelOver(self): return lib.Button_get_bevelOver(self.impl)
   @bevelOver.setter
   def bevelOver(self, value):
      lib.Button_set_bevelOver(self.impl, value)

   @property
   def toggle(self): return lib.Button_get_toggle(self.impl)
   @toggle.setter
   def toggle(self, value):
      lib.Button_set_toggle(self.impl, value)

   @property
   def checked(self): return lib.Button_get_checked(self.impl)
   @checked.setter
   def checked(self, value):
      lib.Button_set_checked(self.impl, value)

   @property
   def alignment(self): return lib.Button_get_alignment(self.impl)
   @alignment.setter
   def alignment(self, value):
      lib.Button_set_alignment(self.impl, value)

   @property
   def bitmap(self): return pyOrNewObject(BitmapResource, lib.Button_get_bitmap(self.impl))
   @bitmap.setter
   def bitmap(self, value):
      if not isinstance(value, BitmapResource): value = BitmapResource(value)
      lib.Button_set_bitmap(self.impl, value.impl)

   @property
   def stayUp(self): return lib.Button_get_stayUp(self.impl)
   @stayUp.setter
   def stayUp(self, value):
      lib.Button_set_stayUp(self.impl, value)

   @property
   def scaleBitmap(self): return lib.Button_get_scaleBitmap(self.impl)
   @scaleBitmap.setter
   def scaleBitmap(self, value):
      lib.Button_set_scaleBitmap(self.impl, value)

   @property
   def keyRepeat(self): return lib.Button_get_keyRepeat(self.impl)
   @keyRepeat.setter
   def keyRepeat(self, value):
      lib.Button_set_keyRepeat(self.impl, value)

   @property
   def symbol(self): return unichar(impl = lib.Button_get_symbol(self.impl))
   @symbol.setter
   def symbol(self, value):
      if not isinstance(value, unichar): value = unichar(value)
      lib.Button_set_symbol(self.impl, value.impl)

   @property
   def ellipsis(self): return lib.Button_get_ellipsis(self.impl)
   @ellipsis.setter
   def ellipsis(self, value):
      lib.Button_set_ellipsis(self.impl, value)

   @property
   def stayDown(self): return lib.Button_get_stayDown(self.impl)
   @stayDown.setter
   def stayDown(self, value):
      lib.Button_set_stayDown(self.impl, value)

   @property
   def offset(self): return lib.Button_get_offset(self.impl)
   @offset.setter
   def offset(self, value):
      lib.Button_set_offset(self.impl, value)

   @property
   def buttonState(self): return lib.Button_get_buttonState(self.impl)
   @buttonState.setter
   def buttonState(self, value):
      lib.Button_set_buttonState(self.impl, value)

   @property
   def bitmapAlignment(self): return lib.Button_get_bitmapAlignment(self.impl)
   @bitmapAlignment.setter
   def bitmapAlignment(self, value):
      lib.Button_set_bitmapAlignment(self.impl, value)

   def fn_unset_Button_notifyClicked(self, _ec_window, button, x, y, mods):
      return lib.Button_notifyClicked(self.impl, _ec_window.impl, ffi.NULL if button is None else button.impl, x, y, mods)

   @property
   def notifyClicked(self):
      if hasattr(self, 'fn_Button_notifyClicked'): return self.fn_Button_notifyClicked
      else: return self.fn_unset_Button_notifyClicked
   @notifyClicked.setter
   def notifyClicked(self, value):
      self.fn_Button_notifyClicked = value
      lib.Instance_setMethod(self.impl, "NotifyClicked".encode('u8'), cb_Button_notifyClicked)

   def fn_unset_Button_notifyDoubleClick(self, _ec_window, button, x, y, mods):
      return lib.Button_notifyDoubleClick(self.impl, _ec_window.impl, ffi.NULL if button is None else button.impl, x, y, mods)

   @property
   def notifyDoubleClick(self):
      if hasattr(self, 'fn_Button_notifyDoubleClick'): return self.fn_Button_notifyDoubleClick
      else: return self.fn_unset_Button_notifyDoubleClick
   @notifyDoubleClick.setter
   def notifyDoubleClick(self, value):
      self.fn_Button_notifyDoubleClick = value
      lib.Instance_setMethod(self.impl, "NotifyDoubleClick".encode('u8'), cb_Button_notifyDoubleClick)

   def fn_unset_Button_notifyMouseLeave(self, _ec_window, button, mods):
      return lib.Button_notifyMouseLeave(self.impl, _ec_window.impl, ffi.NULL if button is None else button.impl, mods)

   @property
   def notifyMouseLeave(self):
      if hasattr(self, 'fn_Button_notifyMouseLeave'): return self.fn_Button_notifyMouseLeave
      else: return self.fn_unset_Button_notifyMouseLeave
   @notifyMouseLeave.setter
   def notifyMouseLeave(self, value):
      self.fn_Button_notifyMouseLeave = value
      lib.Instance_setMethod(self.impl, "NotifyMouseLeave".encode('u8'), cb_Button_notifyMouseLeave)

   def fn_unset_Button_notifyMouseMove(self, _ec_window, button, x, y, mods):
      return lib.Button_notifyMouseMove(self.impl, _ec_window.impl, ffi.NULL if button is None else button.impl, x, y, mods)

   @property
   def notifyMouseMove(self):
      if hasattr(self, 'fn_Button_notifyMouseMove'): return self.fn_Button_notifyMouseMove
      else: return self.fn_unset_Button_notifyMouseMove
   @notifyMouseMove.setter
   def notifyMouseMove(self, value):
      self.fn_Button_notifyMouseMove = value
      lib.Instance_setMethod(self.impl, "NotifyMouseMove".encode('u8'), cb_Button_notifyMouseMove)

   def fn_unset_Button_notifyMouseOver(self, _ec_window, button, x, y, mods):
      return lib.Button_notifyMouseOver(self.impl, _ec_window.impl, ffi.NULL if button is None else button.impl, x, y, mods)

   @property
   def notifyMouseOver(self):
      if hasattr(self, 'fn_Button_notifyMouseOver'): return self.fn_Button_notifyMouseOver
      else: return self.fn_unset_Button_notifyMouseOver
   @notifyMouseOver.setter
   def notifyMouseOver(self, value):
      self.fn_Button_notifyMouseOver = value
      lib.Instance_setMethod(self.impl, "NotifyMouseOver".encode('u8'), cb_Button_notifyMouseOver)

   def fn_unset_Button_notifyPushed(self, _ec_window, button, x, y, mods):
      return lib.Button_notifyPushed(self.impl, _ec_window.impl, ffi.NULL if button is None else button.impl, x, y, mods)

   @property
   def notifyPushed(self):
      if hasattr(self, 'fn_Button_notifyPushed'): return self.fn_Button_notifyPushed
      else: return self.fn_unset_Button_notifyPushed
   @notifyPushed.setter
   def notifyPushed(self, value):
      self.fn_Button_notifyPushed = value
      lib.Instance_setMethod(self.impl, "NotifyPushed".encode('u8'), cb_Button_notifyPushed)

   def fn_unset_Button_notifyReleased(self, _ec_window, button, x, y, mods):
      return lib.Button_notifyReleased(self.impl, _ec_window.impl, ffi.NULL if button is None else button.impl, x, y, mods)

   @property
   def notifyReleased(self):
      if hasattr(self, 'fn_Button_notifyReleased'): return self.fn_Button_notifyReleased
      else: return self.fn_unset_Button_notifyReleased
   @notifyReleased.setter
   def notifyReleased(self, value):
      self.fn_Button_notifyReleased = value
      lib.Instance_setMethod(self.impl, "NotifyReleased".encode('u8'), cb_Button_notifyReleased)

   def removeRadio(self):
      lib.Button_removeRadio(self.impl)

   def setColor(self, state, value):
      if value is not None and not isinstance(value, Color): value = Color(value)
      if value is None: value = ffi.NULL
      lib.Button_setColor(self.impl, state, value)

   def setTextColor(self, state, value):
      if value is not None and not isinstance(value, Color): value = Color(value)
      if value is None: value = ffi.NULL
      lib.Button_setTextColor(self.impl, state, value)

class Distance(pyBaseClass):
   def __init__(self, impl = 0):
      self.impl = impl

Distance.buc = Distance

class Centimeters(Distance):
   def __init__(self, value = 0, impl = None):
      if impl is not None: self.impl = impl
      elif isinstance(value, Distance): self.impl = value.impl
      else: self.value = value

   # conv eC_Distance <-> eC_Meters
   @property
   def value(self): return self.impl * 100
   @value.setter
   def value(self, value): self.impl = value * 0.01

Centimeters.buc = Distance

class CharCategories(pyBaseClass):
   def __init__(self, none = False, markNonSpacing = False, markSpacing = False, markEnclosing = False, numberDecimalDigit = False, numberLetter = False, numberOther = False, separatorSpace = False, separatorLine = False, separatorParagraph = False, otherControl = False, otherFormat = False, otherSurrogate = False, otherPrivateUse = False, otherNotAssigned = False, letterUpperCase = False, letterLowerCase = False, letterTitleCase = False, letterModifier = False, letterOther = False, punctuationConnector = False, punctuationDash = False, punctuationOpen = False, punctuationClose = False, punctuationInitial = False, punctuationFinal = False, punctuationOther = False, symbolMath = False, symbolCurrency = False, symbolModifier = False, symbolOther = False,
                impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(none, CharCategories):
         self.impl = none.impl
      else:
         self.impl = (
            (none                 << lib.CHARCATEGORIES_none_SHIFT)                 |
            (markNonSpacing       << lib.CHARCATEGORIES_markNonSpacing_SHIFT)       |
            (markSpacing          << lib.CHARCATEGORIES_markSpacing_SHIFT)          |
            (markEnclosing        << lib.CHARCATEGORIES_markEnclosing_SHIFT)        |
            (numberDecimalDigit   << lib.CHARCATEGORIES_numberDecimalDigit_SHIFT)   |
            (numberLetter         << lib.CHARCATEGORIES_numberLetter_SHIFT)         |
            (numberOther          << lib.CHARCATEGORIES_numberOther_SHIFT)          |
            (separatorSpace       << lib.CHARCATEGORIES_separatorSpace_SHIFT)       |
            (separatorLine        << lib.CHARCATEGORIES_separatorLine_SHIFT)        |
            (separatorParagraph   << lib.CHARCATEGORIES_separatorParagraph_SHIFT)   |
            (otherControl         << lib.CHARCATEGORIES_otherControl_SHIFT)         |
            (otherFormat          << lib.CHARCATEGORIES_otherFormat_SHIFT)          |
            (otherSurrogate       << lib.CHARCATEGORIES_otherSurrogate_SHIFT)       |
            (otherPrivateUse      << lib.CHARCATEGORIES_otherPrivateUse_SHIFT)      |
            (otherNotAssigned     << lib.CHARCATEGORIES_otherNotAssigned_SHIFT)     |
            (letterUpperCase      << lib.CHARCATEGORIES_letterUpperCase_SHIFT)      |
            (letterLowerCase      << lib.CHARCATEGORIES_letterLowerCase_SHIFT)      |
            (letterTitleCase      << lib.CHARCATEGORIES_letterTitleCase_SHIFT)      |
            (letterModifier       << lib.CHARCATEGORIES_letterModifier_SHIFT)       |
            (letterOther          << lib.CHARCATEGORIES_letterOther_SHIFT)          |
            (punctuationConnector << lib.CHARCATEGORIES_punctuationConnector_SHIFT) |
            (punctuationDash      << lib.CHARCATEGORIES_punctuationDash_SHIFT)      |
            (punctuationOpen      << lib.CHARCATEGORIES_punctuationOpen_SHIFT)      |
            (punctuationClose     << lib.CHARCATEGORIES_punctuationClose_SHIFT)     |
            (punctuationInitial   << lib.CHARCATEGORIES_punctuationInitial_SHIFT)   |
            (punctuationFinal     << lib.CHARCATEGORIES_punctuationFinal_SHIFT)     |
            (punctuationOther     << lib.CHARCATEGORIES_punctuationOther_SHIFT)     |
            (symbolMath           << lib.CHARCATEGORIES_symbolMath_SHIFT)           |
            (symbolCurrency       << lib.CHARCATEGORIES_symbolCurrency_SHIFT)       |
            (symbolModifier       << lib.CHARCATEGORIES_symbolModifier_SHIFT)       |
            (symbolOther          << lib.CHARCATEGORIES_symbolOther_SHIFT)          )

   @property
   def none(self): return ((((self.impl)) & lib.CHARCATEGORIES_none_MASK) >> lib.CHARCATEGORIES_none_SHIFT)
   @none.setter
   def none(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_none_MASK)) | (((value)) << lib.CHARCATEGORIES_none_SHIFT)

   @property
   def markNonSpacing(self): return ((((self.impl)) & lib.CHARCATEGORIES_markNonSpacing_MASK) >> lib.CHARCATEGORIES_markNonSpacing_SHIFT)
   @markNonSpacing.setter
   def markNonSpacing(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_markNonSpacing_MASK)) | (((value)) << lib.CHARCATEGORIES_markNonSpacing_SHIFT)

   @property
   def markSpacing(self): return ((((self.impl)) & lib.CHARCATEGORIES_markSpacing_MASK) >> lib.CHARCATEGORIES_markSpacing_SHIFT)
   @markSpacing.setter
   def markSpacing(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_markSpacing_MASK)) | (((value)) << lib.CHARCATEGORIES_markSpacing_SHIFT)

   @property
   def markEnclosing(self): return ((((self.impl)) & lib.CHARCATEGORIES_markEnclosing_MASK) >> lib.CHARCATEGORIES_markEnclosing_SHIFT)
   @markEnclosing.setter
   def markEnclosing(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_markEnclosing_MASK)) | (((value)) << lib.CHARCATEGORIES_markEnclosing_SHIFT)

   @property
   def numberDecimalDigit(self): return ((((self.impl)) & lib.CHARCATEGORIES_numberDecimalDigit_MASK) >> lib.CHARCATEGORIES_numberDecimalDigit_SHIFT)
   @numberDecimalDigit.setter
   def numberDecimalDigit(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_numberDecimalDigit_MASK)) | (((value)) << lib.CHARCATEGORIES_numberDecimalDigit_SHIFT)

   @property
   def numberLetter(self): return ((((self.impl)) & lib.CHARCATEGORIES_numberLetter_MASK) >> lib.CHARCATEGORIES_numberLetter_SHIFT)
   @numberLetter.setter
   def numberLetter(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_numberLetter_MASK)) | (((value)) << lib.CHARCATEGORIES_numberLetter_SHIFT)

   @property
   def numberOther(self): return ((((self.impl)) & lib.CHARCATEGORIES_numberOther_MASK) >> lib.CHARCATEGORIES_numberOther_SHIFT)
   @numberOther.setter
   def numberOther(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_numberOther_MASK)) | (((value)) << lib.CHARCATEGORIES_numberOther_SHIFT)

   @property
   def separatorSpace(self): return ((((self.impl)) & lib.CHARCATEGORIES_separatorSpace_MASK) >> lib.CHARCATEGORIES_separatorSpace_SHIFT)
   @separatorSpace.setter
   def separatorSpace(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_separatorSpace_MASK)) | (((value)) << lib.CHARCATEGORIES_separatorSpace_SHIFT)

   @property
   def separatorLine(self): return ((((self.impl)) & lib.CHARCATEGORIES_separatorLine_MASK) >> lib.CHARCATEGORIES_separatorLine_SHIFT)
   @separatorLine.setter
   def separatorLine(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_separatorLine_MASK)) | (((value)) << lib.CHARCATEGORIES_separatorLine_SHIFT)

   @property
   def separatorParagraph(self): return ((((self.impl)) & lib.CHARCATEGORIES_separatorParagraph_MASK) >> lib.CHARCATEGORIES_separatorParagraph_SHIFT)
   @separatorParagraph.setter
   def separatorParagraph(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_separatorParagraph_MASK)) | (((value)) << lib.CHARCATEGORIES_separatorParagraph_SHIFT)

   @property
   def otherControl(self): return ((((self.impl)) & lib.CHARCATEGORIES_otherControl_MASK) >> lib.CHARCATEGORIES_otherControl_SHIFT)
   @otherControl.setter
   def otherControl(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_otherControl_MASK)) | (((value)) << lib.CHARCATEGORIES_otherControl_SHIFT)

   @property
   def otherFormat(self): return ((((self.impl)) & lib.CHARCATEGORIES_otherFormat_MASK) >> lib.CHARCATEGORIES_otherFormat_SHIFT)
   @otherFormat.setter
   def otherFormat(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_otherFormat_MASK)) | (((value)) << lib.CHARCATEGORIES_otherFormat_SHIFT)

   @property
   def otherSurrogate(self): return ((((self.impl)) & lib.CHARCATEGORIES_otherSurrogate_MASK) >> lib.CHARCATEGORIES_otherSurrogate_SHIFT)
   @otherSurrogate.setter
   def otherSurrogate(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_otherSurrogate_MASK)) | (((value)) << lib.CHARCATEGORIES_otherSurrogate_SHIFT)

   @property
   def otherPrivateUse(self): return ((((self.impl)) & lib.CHARCATEGORIES_otherPrivateUse_MASK) >> lib.CHARCATEGORIES_otherPrivateUse_SHIFT)
   @otherPrivateUse.setter
   def otherPrivateUse(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_otherPrivateUse_MASK)) | (((value)) << lib.CHARCATEGORIES_otherPrivateUse_SHIFT)

   @property
   def otherNotAssigned(self): return ((((self.impl)) & lib.CHARCATEGORIES_otherNotAssigned_MASK) >> lib.CHARCATEGORIES_otherNotAssigned_SHIFT)
   @otherNotAssigned.setter
   def otherNotAssigned(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_otherNotAssigned_MASK)) | (((value)) << lib.CHARCATEGORIES_otherNotAssigned_SHIFT)

   @property
   def letterUpperCase(self): return ((((self.impl)) & lib.CHARCATEGORIES_letterUpperCase_MASK) >> lib.CHARCATEGORIES_letterUpperCase_SHIFT)
   @letterUpperCase.setter
   def letterUpperCase(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_letterUpperCase_MASK)) | (((value)) << lib.CHARCATEGORIES_letterUpperCase_SHIFT)

   @property
   def letterLowerCase(self): return ((((self.impl)) & lib.CHARCATEGORIES_letterLowerCase_MASK) >> lib.CHARCATEGORIES_letterLowerCase_SHIFT)
   @letterLowerCase.setter
   def letterLowerCase(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_letterLowerCase_MASK)) | (((value)) << lib.CHARCATEGORIES_letterLowerCase_SHIFT)

   @property
   def letterTitleCase(self): return ((((self.impl)) & lib.CHARCATEGORIES_letterTitleCase_MASK) >> lib.CHARCATEGORIES_letterTitleCase_SHIFT)
   @letterTitleCase.setter
   def letterTitleCase(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_letterTitleCase_MASK)) | (((value)) << lib.CHARCATEGORIES_letterTitleCase_SHIFT)

   @property
   def letterModifier(self): return ((((self.impl)) & lib.CHARCATEGORIES_letterModifier_MASK) >> lib.CHARCATEGORIES_letterModifier_SHIFT)
   @letterModifier.setter
   def letterModifier(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_letterModifier_MASK)) | (((value)) << lib.CHARCATEGORIES_letterModifier_SHIFT)

   @property
   def letterOther(self): return ((((self.impl)) & lib.CHARCATEGORIES_letterOther_MASK) >> lib.CHARCATEGORIES_letterOther_SHIFT)
   @letterOther.setter
   def letterOther(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_letterOther_MASK)) | (((value)) << lib.CHARCATEGORIES_letterOther_SHIFT)

   @property
   def punctuationConnector(self): return ((((self.impl)) & lib.CHARCATEGORIES_punctuationConnector_MASK) >> lib.CHARCATEGORIES_punctuationConnector_SHIFT)
   @punctuationConnector.setter
   def punctuationConnector(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_punctuationConnector_MASK)) | (((value)) << lib.CHARCATEGORIES_punctuationConnector_SHIFT)

   @property
   def punctuationDash(self): return ((((self.impl)) & lib.CHARCATEGORIES_punctuationDash_MASK) >> lib.CHARCATEGORIES_punctuationDash_SHIFT)
   @punctuationDash.setter
   def punctuationDash(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_punctuationDash_MASK)) | (((value)) << lib.CHARCATEGORIES_punctuationDash_SHIFT)

   @property
   def punctuationOpen(self): return ((((self.impl)) & lib.CHARCATEGORIES_punctuationOpen_MASK) >> lib.CHARCATEGORIES_punctuationOpen_SHIFT)
   @punctuationOpen.setter
   def punctuationOpen(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_punctuationOpen_MASK)) | (((value)) << lib.CHARCATEGORIES_punctuationOpen_SHIFT)

   @property
   def punctuationClose(self): return ((((self.impl)) & lib.CHARCATEGORIES_punctuationClose_MASK) >> lib.CHARCATEGORIES_punctuationClose_SHIFT)
   @punctuationClose.setter
   def punctuationClose(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_punctuationClose_MASK)) | (((value)) << lib.CHARCATEGORIES_punctuationClose_SHIFT)

   @property
   def punctuationInitial(self): return ((((self.impl)) & lib.CHARCATEGORIES_punctuationInitial_MASK) >> lib.CHARCATEGORIES_punctuationInitial_SHIFT)
   @punctuationInitial.setter
   def punctuationInitial(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_punctuationInitial_MASK)) | (((value)) << lib.CHARCATEGORIES_punctuationInitial_SHIFT)

   @property
   def punctuationFinal(self): return ((((self.impl)) & lib.CHARCATEGORIES_punctuationFinal_MASK) >> lib.CHARCATEGORIES_punctuationFinal_SHIFT)
   @punctuationFinal.setter
   def punctuationFinal(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_punctuationFinal_MASK)) | (((value)) << lib.CHARCATEGORIES_punctuationFinal_SHIFT)

   @property
   def punctuationOther(self): return ((((self.impl)) & lib.CHARCATEGORIES_punctuationOther_MASK) >> lib.CHARCATEGORIES_punctuationOther_SHIFT)
   @punctuationOther.setter
   def punctuationOther(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_punctuationOther_MASK)) | (((value)) << lib.CHARCATEGORIES_punctuationOther_SHIFT)

   @property
   def symbolMath(self): return ((((self.impl)) & lib.CHARCATEGORIES_symbolMath_MASK) >> lib.CHARCATEGORIES_symbolMath_SHIFT)
   @symbolMath.setter
   def symbolMath(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_symbolMath_MASK)) | (((value)) << lib.CHARCATEGORIES_symbolMath_SHIFT)

   @property
   def symbolCurrency(self): return ((((self.impl)) & lib.CHARCATEGORIES_symbolCurrency_MASK) >> lib.CHARCATEGORIES_symbolCurrency_SHIFT)
   @symbolCurrency.setter
   def symbolCurrency(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_symbolCurrency_MASK)) | (((value)) << lib.CHARCATEGORIES_symbolCurrency_SHIFT)

   @property
   def symbolModifier(self): return ((((self.impl)) & lib.CHARCATEGORIES_symbolModifier_MASK) >> lib.CHARCATEGORIES_symbolModifier_SHIFT)
   @symbolModifier.setter
   def symbolModifier(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_symbolModifier_MASK)) | (((value)) << lib.CHARCATEGORIES_symbolModifier_SHIFT)

   @property
   def symbolOther(self): return ((((self.impl)) & lib.CHARCATEGORIES_symbolOther_MASK) >> lib.CHARCATEGORIES_symbolOther_SHIFT)
   @symbolOther.setter
   def symbolOther(self, value): self.impl = ((self.impl) & ~(lib.CHARCATEGORIES_symbolOther_MASK)) | (((value)) << lib.CHARCATEGORIES_symbolOther_SHIFT)

class ColorRGB(Struct):
   def __init__(self, r = 0.0, g = 0.0, b = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_ColorRGB *", impl)
      else:
         if isinstance(r, tuple):
            __tuple = r
            r = 0.0
            if len(__tuple) > 0: r = __tuple[0]
            if len(__tuple) > 1: g = __tuple[1]
            if len(__tuple) > 2: b = __tuple[2]
         elif isinstance(r, Color):
            self.impl = ffi.new("eC_ColorRGB *")
            lib.Color_to_ColorRGB(r, self.impl)
            return
         elif isinstance(r, ColorCMYK):
            self.impl = ffi.new("eC_ColorRGB *")
            lib.ColorCMYK_to_ColorRGB(r.impl, self.impl)
            return
         elif isinstance(r, ColorHSV):
            self.impl = ffi.new("eC_ColorRGB *")
            lib.ColorHSV_to_ColorRGB(r.impl, self.impl)
            return
         elif isinstance(r, ColorLab):
            self.impl = ffi.new("eC_ColorRGB *")
            lib.ColorLab_to_ColorRGB(r.impl, self.impl)
            return
         self.impl = ffi.new("eC_ColorRGB *", { 'r' : r, 'g' : g, 'b' : b })

   @property
   def r(self): return self.impl.r
   @r.setter
   def r(self, value): self.impl.r = value

   @property
   def g(self): return self.impl.g
   @g.setter
   def g(self, value): self.impl.g = value

   @property
   def b(self): return self.impl.b
   @b.setter
   def b(self, value): self.impl.b = value

class Color(pyBaseClass):
   def __init__(self, r = 0, g = 0, b = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(r, Color):
         self.impl = r.impl
      else:
         if isinstance(r, tuple):
            __tuple = r
            r = 0
            if len(__tuple) > 0: r = __tuple[0]
            if len(__tuple) > 1: g = __tuple[1]
            if len(__tuple) > 2: b = __tuple[2]
         elif isinstance(r, ColorRGB):
            self.impl = lib.Color_from_ColorRGB(r.impl)
            return
         elif isinstance(r, Color444):
            self.impl = lib.Color444_to_Color(r.impl)
            return
         elif isinstance(r, Color555):
            self.impl = lib.Color555_to_Color(r.impl)
            return
         elif isinstance(r, Color565):
            self.impl = lib.Color565_to_Color(r.impl)
            return
         elif isinstance(r, ColorAlpha):
            self.impl = lib.ColorAlpha_to_Color(r.impl)
            return
         elif isinstance(r, ColorRGBA):
            self.impl = lib.ColorRGBA_to_Color(r.impl)
            return
         elif isinstance(r, ColorRGBAf):
            self.impl = lib.ColorRGBAf_to_Color(r.impl)
            return
         self.impl = (
            (r << lib.COLOR_r_SHIFT) |
            (g << lib.COLOR_g_SHIFT) |
            (b << lib.COLOR_b_SHIFT) )

   @property
   def r(self): return ((((self.impl)) & lib.COLOR_r_MASK) >> lib.COLOR_r_SHIFT)
   @r.setter
   def r(self, value): self.impl = ((self.impl) & ~(lib.COLOR_r_MASK)) | (((value)) << lib.COLOR_r_SHIFT)

   @property
   def g(self): return ((((self.impl)) & lib.COLOR_g_MASK) >> lib.COLOR_g_SHIFT)
   @g.setter
   def g(self, value): self.impl = ((self.impl) & ~(lib.COLOR_g_MASK)) | (((value)) << lib.COLOR_g_SHIFT)

   @property
   def b(self): return ((((self.impl)) & lib.COLOR_b_MASK) >> lib.COLOR_b_SHIFT)
   @b.setter
   def b(self, value): self.impl = ((self.impl) & ~(lib.COLOR_b_MASK)) | (((value)) << lib.COLOR_b_SHIFT)

   # def Color_to_ColorRGB(self): value = ColorRGB(); lib.Color_to_ColorRGB(self.impl, ffi.cast("eC_ColorRGB *", value.impl)); return

   # here is an unhandled conversion: Color::ColorRGB (BitClass 2 StructClass)
   # Color_to_ColorRGB
   # Color_from_ColorRGB

class ColorAlpha(pyBaseClass):
   def __init__(self, a = 0, color = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(a, ColorAlpha):
         self.impl = a.impl
      else:
         if isinstance(a, tuple):
            __tuple = a
            a = 0
            if len(__tuple) > 0: a = __tuple[0]
            if len(__tuple) > 1: color = __tuple[1]
         elif isinstance(a, Color):
            self.impl = lib.ColorAlpha_from_Color(a.impl)
            return
         elif isinstance(a, ColorRGBA):
            self.impl = lib.ColorRGBA_to_ColorAlpha(a.impl)
            return
         elif isinstance(a, ColorRGBAf):
            self.impl = lib.ColorRGBAf_to_ColorAlpha(a.impl)
            return
         if not isinstance(color, Color): color = Color(color)
         self.impl = (
            (a          << lib.COLORALPHA_a_SHIFT)          |
            (color.impl << lib.COLORALPHA_color_SHIFT)      )

   @property
   def a(self): return ((((self.impl)) & lib.COLORALPHA_a_MASK) >> lib.COLORALPHA_a_SHIFT)
   @a.setter
   def a(self, value): self.impl = ((self.impl) & ~(lib.COLORALPHA_a_MASK)) | (((value)) << lib.COLORALPHA_a_SHIFT)

   @property
   def color(self): return ((((self.impl)) & lib.COLORALPHA_color_MASK) >> lib.COLORALPHA_color_SHIFT)
   @color.setter
   def color(self, value): self.impl = ((self.impl) & ~(lib.COLORALPHA_color_MASK)) | (((value)) << lib.COLORALPHA_color_SHIFT)

   # def ColorAlpha_to_Color(self): return Color(impl = lib.ColorAlpha_to_Color(self.impl))

   # here is an unhandled conversion: ColorAlpha::Color (BitClass 2 BitClass)
   # ColorAlpha_to_Color
   # ColorAlpha_from_Color

class ColorRGBA(pyBaseClass):
   def __init__(self, r = 0, g = 0, b = 0, a = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(r, ColorRGBA):
         self.impl = r.impl
      else:
         if isinstance(r, tuple):
            __tuple = r
            r = 0
            if len(__tuple) > 0: r = __tuple[0]
            if len(__tuple) > 1: g = __tuple[1]
            if len(__tuple) > 2: b = __tuple[2]
            if len(__tuple) > 3: a = __tuple[3]
         elif isinstance(r, ColorAlpha):
            self.impl = lib.ColorRGBA_from_ColorAlpha(r.impl)
            return
         elif isinstance(r, Color):
            self.impl = lib.ColorRGBA_from_Color(r.impl)
            return
         self.impl = (
            (r << lib.COLORRGBA_r_SHIFT) |
            (g << lib.COLORRGBA_g_SHIFT) |
            (b << lib.COLORRGBA_b_SHIFT) |
            (a << lib.COLORRGBA_a_SHIFT) )

   @property
   def r(self): return ((((self.impl)) & lib.COLORRGBA_r_MASK) >> lib.COLORRGBA_r_SHIFT)
   @r.setter
   def r(self, value): self.impl = ((self.impl) & ~(lib.COLORRGBA_r_MASK)) | (((value)) << lib.COLORRGBA_r_SHIFT)

   @property
   def g(self): return ((((self.impl)) & lib.COLORRGBA_g_MASK) >> lib.COLORRGBA_g_SHIFT)
   @g.setter
   def g(self, value): self.impl = ((self.impl) & ~(lib.COLORRGBA_g_MASK)) | (((value)) << lib.COLORRGBA_g_SHIFT)

   @property
   def b(self): return ((((self.impl)) & lib.COLORRGBA_b_MASK) >> lib.COLORRGBA_b_SHIFT)
   @b.setter
   def b(self, value): self.impl = ((self.impl) & ~(lib.COLORRGBA_b_MASK)) | (((value)) << lib.COLORRGBA_b_SHIFT)

   @property
   def a(self): return ((((self.impl)) & lib.COLORRGBA_a_MASK) >> lib.COLORRGBA_a_SHIFT)
   @a.setter
   def a(self, value): self.impl = ((self.impl) & ~(lib.COLORRGBA_a_MASK)) | (((value)) << lib.COLORRGBA_a_SHIFT)

   # def ColorRGBA_to_ColorAlpha(self): return ColorAlpha(impl = lib.ColorRGBA_to_ColorAlpha(self.impl))

   # here is an unhandled conversion: ColorRGBA::ColorAlpha (BitClass 2 BitClass)
   # ColorRGBA_to_ColorAlpha
   # ColorRGBA_from_ColorAlpha

   # def ColorRGBA_to_Color(self): return Color(impl = lib.ColorRGBA_to_Color(self.impl))

   # here is an unhandled conversion: ColorRGBA::Color (BitClass 2 BitClass)
   # ColorRGBA_to_Color
   # ColorRGBA_from_Color

class Date(Struct):
   def __init__(self, year = 0, month = 0, day = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Date *", impl)
      else:
         if isinstance(year, tuple):
            __tuple = year
            year = 0
            if len(__tuple) > 0: year  = __tuple[0]
            if len(__tuple) > 1: month = __tuple[1]
            if len(__tuple) > 2: day   = __tuple[2]
         elif isinstance(year, DateTime):
            self.impl = ffi.new("eC_Date *")
            lib.DateTime_to_Date(year.impl, self.impl)
            return
         self.impl = ffi.new("eC_Date *", { 'year' : year, 'month' : month, 'day' : day })

   @property
   def year(self): return self.impl.year
   @year.setter
   def year(self, value): self.impl.year = value

   @property
   def month(self): return self.impl.month
   @month.setter
   def month(self, value): self.impl.month = value

   @property
   def day(self): return self.impl.day
   @day.setter
   def day(self, value): self.impl.day = value

   @property
   def dayOfTheWeek(self): return lib.Date_get_dayOfTheWeek(self.impl)

   def onGetStringEn(self, stringOutput, fieldData, onType):
      if isinstance(stringOutput, str): stringOutput = ffi.new("char[]", stringOutput.encode('u8'))
      elif stringOutput is None: stringOutput = ffi.NULL
      if hasattr(fieldData, 'impl'): fieldData = fieldData.impl
      if fieldData is None: fieldData = ffi.NULL
      return lib.Date_onGetStringEn(ffi.cast("eC_Date *", self.impl), stringOutput, fieldData, onType)

class DateTime(Struct):
   def __init__(self, year = 0, month = 0, day = 0, hour = 0, minute = 0, second = 0, dayOfTheWeek = 0, dayInTheYear = 0, _global = None, local = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_DateTime *", impl)
      else:
         if isinstance(year, SecSince1970):
            self.impl = ffi.new("eC_DateTime *")
            lib.DateTime_from_SecSince1970(self.impl, year.impl)
            return
         elif isinstance(year, Date):
            self.impl = ffi.new("eC_DateTime *")
            lib.DateTime_from_Date(self.impl, year.impl)
            return
         self.impl = ffi.new("eC_DateTime *", {
                                'year' : year,
                                'month' : month,
                                'day' : day,
                                'hour' : hour,
                                'minute' : minute,
                                'second' : second,
                                'dayOfTheWeek' : dayOfTheWeek,
                                'dayInTheYear' : dayInTheYear
                             })
         if _global is not None:      self._global           = _global
         if local is not None:        self.local             = local

   @property
   def year(self): return self.impl.year
   @year.setter
   def year(self, value): self.impl.year = value

   @property
   def month(self): return self.impl.month
   @month.setter
   def month(self, value): self.impl.month = value

   @property
   def day(self): return self.impl.day
   @day.setter
   def day(self, value): self.impl.day = value

   @property
   def hour(self): return self.impl.hour
   @hour.setter
   def hour(self, value): self.impl.hour = value

   @property
   def minute(self): return self.impl.minute
   @minute.setter
   def minute(self, value): self.impl.minute = value

   @property
   def second(self): return self.impl.second
   @second.setter
   def second(self, value): self.impl.second = value

   @property
   def dayOfTheWeek(self): return self.impl.dayOfTheWeek
   @dayOfTheWeek.setter
   def dayOfTheWeek(self, value): self.impl.dayOfTheWeek = value

   @property
   def dayInTheYear(self): return self.impl.dayInTheYear
   @dayInTheYear.setter
   def dayInTheYear(self, value): self.impl.dayInTheYear = value

   @property
   def _global(self): value = DateTime(); lib.DateTime_get_global(self.impl, ffi.cast("eC_DateTime *", value.impl)); return value
   @_global.setter
   def _global(self, value):
      if not isinstance(value, DateTime): value = DateTime(value)
      lib.DateTime_set_global(self.impl, ffi.cast("eC_DateTime *", value.impl))

   @property
   def local(self): value = DateTime(); lib.DateTime_get_local(self.impl, ffi.cast("eC_DateTime *", value.impl)); return value
   @local.setter
   def local(self, value):
      if not isinstance(value, DateTime): value = DateTime(value)
      lib.DateTime_set_local(self.impl, ffi.cast("eC_DateTime *", value.impl))

   @property
   def daysSince1970(self): return lib.DateTime_get_daysSince1970(self.impl)

   # def DateTime_to_SecSince1970(self): return SecSince1970(lib.DateTime_to_SecSince1970(self.impl))

   # here is an unhandled conversion: DateTime::SecSince1970 (StructClass 2 UnitClass)
   # DateTime_to_SecSince1970
   # DateTime_from_SecSince1970

   # def DateTime_to_Date(self): value = Date(); lib.DateTime_to_Date(self.impl, ffi.cast("eC_Date *", value.impl)); return

   # here is an unhandled conversion: DateTime::Date (StructClass 2 StructClass)
   # DateTime_to_Date
   # DateTime_from_Date

   def fixDayOfYear(self):
      return lib.DateTime_fixDayOfYear(ffi.cast("eC_DateTime *", self.impl))

   def getLocalTime(self):
      return lib.DateTime_getLocalTime(ffi.cast("eC_DateTime *", self.impl))

class Degrees(Angle):
   def __init__(self, value = 0, impl = None):
      if impl is not None: self.impl = impl
      elif isinstance(value, Angle): self.impl = value.impl
      else: self.value = value

   # conv eC_Angle <-> eC_Radians
   @property
   def value(self): return self.impl * 57.2957795130823
   @value.setter
   def value(self, value): self.impl = value * 0.0174532925199433

Degrees.buc = Angle

class ErrorCode(pyBaseClass):
   def __init__(self, level = 0, code = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(level, ErrorCode):
         self.impl = level.impl
      else:
         if isinstance(level, tuple):
            __tuple = level
            level = 0
            if len(__tuple) > 0: level = __tuple[0]
            if len(__tuple) > 1: code = __tuple[1]
         self.impl = (
            (level << lib.ERRORCODE_level_SHIFT) |
            (code  << lib.ERRORCODE_code_SHIFT)  )

   @property
   def level(self): return ((((self.impl)) & lib.ERRORCODE_level_MASK) >> lib.ERRORCODE_level_SHIFT)
   @level.setter
   def level(self, value): self.impl = ((self.impl) & ~(lib.ERRORCODE_level_MASK)) | (((value)) << lib.ERRORCODE_level_SHIFT)

   @property
   def code(self): return ((((self.impl)) & lib.ERRORCODE_code_MASK) >> lib.ERRORCODE_code_SHIFT)
   @code.setter
   def code(self, value): self.impl = ((self.impl) & ~(lib.ERRORCODE_code_MASK)) | (((value)) << lib.ERRORCODE_code_SHIFT)

class Euler(Struct):
   def __init__(self, yaw = 0, pitch = 0, roll = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Euler *", impl)
      else:
         if isinstance(yaw, tuple):
            __tuple = yaw
            yaw = 0
            if len(__tuple) > 0: yaw   = __tuple[0]
            if len(__tuple) > 1: pitch = __tuple[1]
            if len(__tuple) > 2: roll  = __tuple[2]
         elif isinstance(yaw, Quaternion):
            self.impl = ffi.new("eC_Euler *")
            lib.Euler_from_Quaternion(self.impl, yaw.impl)
            return
         if yaw is not None:
            if not isinstance(yaw, Angle): yaw = Degrees(yaw)
            yaw = yaw.impl
         else:
            yaw = Degrees()
         if pitch is not None:
            if not isinstance(pitch, Angle): pitch = Degrees(pitch)
            pitch = pitch.impl
         else:
            pitch = Degrees()
         if roll is not None:
            if not isinstance(roll, Angle): roll = Degrees(roll)
            roll = roll.impl
         else:
            roll = Degrees()
         self.impl = ffi.new("eC_Euler *", { 'yaw' : yaw, 'pitch' : pitch, 'roll' : roll })

   @property
   def yaw(self): return Degrees(impl = self.impl.yaw)
   @yaw.setter
   def yaw(self, value):
      if not isinstance(value, Angle): value = Degrees(value)
      self.impl.yaw = value.impl

   @property
   def pitch(self): return Degrees(impl = self.impl.pitch)
   @pitch.setter
   def pitch(self, value):
      if not isinstance(value, Angle): value = Degrees(value)
      self.impl.pitch = value.impl

   @property
   def roll(self): return Degrees(impl = self.impl.roll)
   @roll.setter
   def roll(self, value):
      if not isinstance(value, Angle): value = Degrees(value)
      self.impl.roll = value.impl

   # def Euler_to_Quaternion(self): value = Quaternion(); lib.Euler_to_Quaternion(self.impl, ffi.cast("eC_Quaternion *", value.impl)); return

   # here is an unhandled conversion: Euler::Quaternion (StructClass 2 StructClass)
   # Euler_to_Quaternion
   # Euler_from_Quaternion

   def add(self, e1 = None, e2 = None):
      if e1 is not None and not isinstance(e1, Euler): e1 = Euler(e1)
      e1 = ffi.NULL if e1 is None else e1.impl
      if e2 is not None and not isinstance(e2, Euler): e2 = Euler(e2)
      e2 = ffi.NULL if e2 is None else e2.impl
      lib.Euler_add(ffi.cast("eC_Euler *", self.impl), ffi.cast("eC_Euler *", e1), ffi.cast("eC_Euler *", e2))

   def fromMatrix(self, m, order):
      if m is not None and not isinstance(m, Matrix): m = Matrix(m)
      m = ffi.NULL if m is None else m.impl
      lib.Euler_fromMatrix(ffi.cast("eC_Euler *", self.impl), ffi.cast("eC_Matrix *", m), order)

   def fromQuaternion(self, q, order):
      if q is not None and not isinstance(q, Quaternion): q = Quaternion(q)
      q = ffi.NULL if q is None else q.impl
      lib.Euler_fromQuaternion(ffi.cast("eC_Euler *", self.impl), ffi.cast("eC_Quaternion *", q), order)

@ffi.callback("void(eC_File)")
def cb_File_close(__e):
   file = pyOrNewObject(File, __e)
   file.fn_File_close(file)

@ffi.callback("void(eC_File)")
def cb_File_closeInput(__e):
   file = pyOrNewObject(File, __e)
   file.fn_File_closeInput(file)

@ffi.callback("void(eC_File)")
def cb_File_closeOutput(__e):
   file = pyOrNewObject(File, __e)
   file.fn_File_closeOutput(file)

@ffi.callback("eC_bool(eC_File)")
def cb_File_eof(__e):
   file = pyOrNewObject(File, __e)
   return file.fn_File_eof(file)

@ffi.callback("uint64(eC_File)")
def cb_File_getSize(__e):
   file = pyOrNewObject(File, __e)
   return file.fn_File_getSize(file)

@ffi.callback("eC_bool(eC_File, char *)")
def cb_File_getc(__e, ch):
   file = pyOrNewObject(File, __e)
   return file.fn_File_getc(file, ch.encode('u8'))

@ffi.callback("eC_bool(eC_File, eC_FileLock, uint64, uint64, eC_bool)")
def cb_File_lock(__e, type, start, length, wait):
   file = pyOrNewObject(File, __e)
   return file.fn_File_lock(file, FileLock(impl = type), start, length, wait)

@ffi.callback("eC_bool(eC_File, char)")
def cb_File_putc(__e, ch):
   file = pyOrNewObject(File, __e)
   return file.fn_File_putc(file, ch)

@ffi.callback("eC_bool(eC_File, const char *)")
def cb_File_puts(__e, string):
   file = pyOrNewObject(File, __e)
   return file.fn_File_puts(file, string.encode('u8'))

@ffi.callback("uintsize(eC_File, void *, uintsize, uintsize)")
def cb_File_read(__e, buffer, size, count):
   file = pyOrNewObject(File, __e)
   return file.fn_File_read(file, buffer, size, count)

@ffi.callback("eC_bool(eC_File, int64, eC_FileSeekMode)")
def cb_File_seek(__e, pos, mode):
   file = pyOrNewObject(File, __e)
   return file.fn_File_seek(file, pos, FileSeekMode(impl = mode))

@ffi.callback("uint64(eC_File)")
def cb_File_tell(__e):
   file = pyOrNewObject(File, __e)
   return file.fn_File_tell(file)

@ffi.callback("eC_bool(eC_File, uint64)")
def cb_File_truncate(__e, size):
   file = pyOrNewObject(File, __e)
   return file.fn_File_truncate(file, size)

@ffi.callback("eC_bool(eC_File, uint64, uint64, eC_bool)")
def cb_File_unlock(__e, start, length, wait):
   file = pyOrNewObject(File, __e)
   return file.fn_File_unlock(file, start, length, wait)

@ffi.callback("uintsize(eC_File, const void *, uintsize, uintsize)")
def cb_File_write(__e, buffer, size, count):
   file = pyOrNewObject(File, __e)
   return file.fn_File_write(file, buffer, size, count)

class File(IOChannel):
   class_members = [
                      'input',
                      'output',
                      'buffered',
                      'eof',
                      'close',
                      'closeInput',
                      'closeOutput',
                      'eof',
                      'getSize',
                      'getc',
                      'lock',
                      'putc',
                      'puts',
                      'read',
                      'seek',
                      'tell',
                      'truncate',
                      'unlock',
                      'write',
                   ]

   def init_args(self, args, kwArgs): init_args(File, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def input(self): return lib.File_get_input(self.impl)
   @input.setter
   def input(self, value):
      lib.File_set_input(self.impl, value)

   @property
   def output(self): return lib.File_get_output(self.impl)
   @output.setter
   def output(self, value):
      lib.File_set_output(self.impl, value)

   @property
   def buffered(self): return None
   @buffered.setter
   def buffered(self, value):
      lib.File_set_buffered(self.impl, value)

   @property
   def eof(self): return lib.File_get_eof(self.impl)

   def fn_unset_File_close(self):
      return lib.File_close(self.impl)

   @property
   def close(self):
      if hasattr(self, 'fn_File_close'): return self.fn_File_close
      else: return self.fn_unset_File_close
   @close.setter
   def close(self, value):
      self.fn_File_close = value
      lib.Instance_setMethod(self.impl, "Close".encode('u8'), cb_File_close)

   def fn_unset_File_closeInput(self):
      return lib.File_closeInput(self.impl)

   @property
   def closeInput(self):
      if hasattr(self, 'fn_File_closeInput'): return self.fn_File_closeInput
      else: return self.fn_unset_File_closeInput
   @closeInput.setter
   def closeInput(self, value):
      self.fn_File_closeInput = value
      lib.Instance_setMethod(self.impl, "CloseInput".encode('u8'), cb_File_closeInput)

   def fn_unset_File_closeOutput(self):
      return lib.File_closeOutput(self.impl)

   @property
   def closeOutput(self):
      if hasattr(self, 'fn_File_closeOutput'): return self.fn_File_closeOutput
      else: return self.fn_unset_File_closeOutput
   @closeOutput.setter
   def closeOutput(self, value):
      self.fn_File_closeOutput = value
      lib.Instance_setMethod(self.impl, "CloseOutput".encode('u8'), cb_File_closeOutput)

   def copyTo(self, outputFileName):
      if isinstance(outputFileName, str): outputFileName = ffi.new("char[]", outputFileName.encode('u8'))
      elif outputFileName is None: outputFileName = ffi.NULL
      return lib.File_copyTo(self.impl, outputFileName)

   def copyToFile(self, f = None):
      if f is not None and not isinstance(f, File): f = File(f)
      f = ffi.NULL if f is None else f.impl
      return lib.File_copyToFile(self.impl, f)

   def fn_unset_File_eof(self):
      return lib.File_eof(self.impl)

   @property
   def eof(self):
      if hasattr(self, 'fn_File_eof'): return self.fn_File_eof
      else: return self.fn_unset_File_eof
   @eof.setter
   def eof(self, value):
      self.fn_File_eof = value
      lib.Instance_setMethod(self.impl, "Eof".encode('u8'), cb_File_eof)

   def flush(self):
      return lib.File_flush(self.impl)

   def getDouble(self):
      return lib.File_getDouble(self.impl)

   def getFloat(self):
      return lib.File_getFloat(self.impl)

   def getHexValue(self):
      return lib.File_getHexValue(self.impl)

   def getLine(self, s, max):
      if isinstance(s, str): s = ffi.new("char[]", s.encode('u8'))
      elif s is None: s = ffi.NULL
      return lib.File_getLine(self.impl, s, max)

   def getLineEx(self, s, max):
      if isinstance(s, str): s = ffi.new("char[]", s.encode('u8'))
      elif s is None: s = ffi.NULL
      hasNewLineChar = ffi.new("eC_bool *")
      r = lib.File_getLineEx(self.impl, s, max, hasNewLineChar)
      return r, hasNewLineChar[0]

   def fn_unset_File_getSize(self):
      return lib.File_getSize(self.impl)

   @property
   def getSize(self):
      if hasattr(self, 'fn_File_getSize'): return self.fn_File_getSize
      else: return self.fn_unset_File_getSize
   @getSize.setter
   def getSize(self, value):
      self.fn_File_getSize = value
      lib.Instance_setMethod(self.impl, "GetSize".encode('u8'), cb_File_getSize)

   def getString(self, string, max):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      return lib.File_getString(self.impl, string, max)

   def getValue(self):
      return lib.File_getValue(self.impl)

   def fn_unset_File_getc(self, ch):
      return lib.File_getc(self.impl, ch)

   @property
   def getc(self):
      if hasattr(self, 'fn_File_getc'): return self.fn_File_getc
      else: return self.fn_unset_File_getc
   @getc.setter
   def getc(self, value):
      self.fn_File_getc = value
      lib.Instance_setMethod(self.impl, "Getc".encode('u8'), cb_File_getc)

   def fn_unset_File_lock(self, type, start, length, wait):
      return lib.File_lock(self.impl, type, start, length, wait)

   @property
   def lock(self):
      if hasattr(self, 'fn_File_lock'): return self.fn_File_lock
      else: return self.fn_unset_File_lock
   @lock.setter
   def lock(self, value):
      self.fn_File_lock = value
      lib.Instance_setMethod(self.impl, "Lock".encode('u8'), cb_File_lock)

   def _print(self, *args): lib.File_print(self.impl, *convertTypedArgs(args))

   def printLn(self, *args): lib.File_printLn(self.impl, *convertTypedArgs(args))

   def printf(self, format, *args):
      if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
      elif format is None: format = ffi.NULL
      return lib.File_printf(self.impl, format, *ellipsisArgs(args))

   def fn_unset_File_putc(self, ch):
      return lib.File_putc(self.impl, ch)

   @property
   def putc(self):
      if hasattr(self, 'fn_File_putc'): return self.fn_File_putc
      else: return self.fn_unset_File_putc
   @putc.setter
   def putc(self, value):
      self.fn_File_putc = value
      lib.Instance_setMethod(self.impl, "Putc".encode('u8'), cb_File_putc)

   def fn_unset_File_puts(self, string):
      return lib.File_puts(self.impl, string)

   @property
   def puts(self):
      if hasattr(self, 'fn_File_puts'): return self.fn_File_puts
      else: return self.fn_unset_File_puts
   @puts.setter
   def puts(self, value):
      self.fn_File_puts = value
      lib.Instance_setMethod(self.impl, "Puts".encode('u8'), cb_File_puts)

   def fn_unset_File_read(self, buffer, size, count):
      return lib.File_read(self.impl, buffer, size, count)

   @property
   def read(self):
      if hasattr(self, 'fn_File_read'): return self.fn_File_read
      else: return self.fn_unset_File_read
   @read.setter
   def read(self, value):
      self.fn_File_read = value
      lib.Instance_setMethod(self.impl, "Read".encode('u8'), cb_File_read)

   def fn_unset_File_seek(self, pos, mode):
      return lib.File_seek(self.impl, pos, mode)

   @property
   def seek(self):
      if hasattr(self, 'fn_File_seek'): return self.fn_File_seek
      else: return self.fn_unset_File_seek
   @seek.setter
   def seek(self, value):
      self.fn_File_seek = value
      lib.Instance_setMethod(self.impl, "Seek".encode('u8'), cb_File_seek)

   def fn_unset_File_tell(self):
      return lib.File_tell(self.impl)

   @property
   def tell(self):
      if hasattr(self, 'fn_File_tell'): return self.fn_File_tell
      else: return self.fn_unset_File_tell
   @tell.setter
   def tell(self, value):
      self.fn_File_tell = value
      lib.Instance_setMethod(self.impl, "Tell".encode('u8'), cb_File_tell)

   def fn_unset_File_truncate(self, size):
      return lib.File_truncate(self.impl, size)

   @property
   def truncate(self):
      if hasattr(self, 'fn_File_truncate'): return self.fn_File_truncate
      else: return self.fn_unset_File_truncate
   @truncate.setter
   def truncate(self, value):
      self.fn_File_truncate = value
      lib.Instance_setMethod(self.impl, "Truncate".encode('u8'), cb_File_truncate)

   def fn_unset_File_unlock(self, start, length, wait):
      return lib.File_unlock(self.impl, start, length, wait)

   @property
   def unlock(self):
      if hasattr(self, 'fn_File_unlock'): return self.fn_File_unlock
      else: return self.fn_unset_File_unlock
   @unlock.setter
   def unlock(self, value):
      self.fn_File_unlock = value
      lib.Instance_setMethod(self.impl, "Unlock".encode('u8'), cb_File_unlock)

   def fn_unset_File_write(self, buffer, size, count):
      return lib.File_write(self.impl, buffer, size, count)

   @property
   def write(self):
      if hasattr(self, 'fn_File_write'): return self.fn_File_write
      else: return self.fn_unset_File_write
   @write.setter
   def write(self, value):
      self.fn_File_write = value
      lib.Instance_setMethod(self.impl, "Write".encode('u8'), cb_File_write)

class FileChange(pyBaseClass):
   def __init__(self, created = False, renamed = False, modified = False, deleted = False, attribs = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(created, FileChange):
         self.impl = created.impl
      else:
         if isinstance(created, tuple):
            __tuple = created
            created = False
            if len(__tuple) > 0: created = __tuple[0]
            if len(__tuple) > 1: renamed = __tuple[1]
            if len(__tuple) > 2: modified = __tuple[2]
            if len(__tuple) > 3: deleted = __tuple[3]
            if len(__tuple) > 4: attribs = __tuple[4]
         self.impl = (
            (created  << lib.FILECHANGE_created_SHIFT)  |
            (renamed  << lib.FILECHANGE_renamed_SHIFT)  |
            (modified << lib.FILECHANGE_modified_SHIFT) |
            (deleted  << lib.FILECHANGE_deleted_SHIFT)  |
            (attribs  << lib.FILECHANGE_attribs_SHIFT)  )

   @property
   def created(self): return ((((self.impl)) & lib.FILECHANGE_created_MASK) >> lib.FILECHANGE_created_SHIFT)
   @created.setter
   def created(self, value): self.impl = ((self.impl) & ~(lib.FILECHANGE_created_MASK)) | (((value)) << lib.FILECHANGE_created_SHIFT)

   @property
   def renamed(self): return ((((self.impl)) & lib.FILECHANGE_renamed_MASK) >> lib.FILECHANGE_renamed_SHIFT)
   @renamed.setter
   def renamed(self, value): self.impl = ((self.impl) & ~(lib.FILECHANGE_renamed_MASK)) | (((value)) << lib.FILECHANGE_renamed_SHIFT)

   @property
   def modified(self): return ((((self.impl)) & lib.FILECHANGE_modified_MASK) >> lib.FILECHANGE_modified_SHIFT)
   @modified.setter
   def modified(self, value): self.impl = ((self.impl) & ~(lib.FILECHANGE_modified_MASK)) | (((value)) << lib.FILECHANGE_modified_SHIFT)

   @property
   def deleted(self): return ((((self.impl)) & lib.FILECHANGE_deleted_MASK) >> lib.FILECHANGE_deleted_SHIFT)
   @deleted.setter
   def deleted(self, value): self.impl = ((self.impl) & ~(lib.FILECHANGE_deleted_MASK)) | (((value)) << lib.FILECHANGE_deleted_SHIFT)

   @property
   def attribs(self): return ((((self.impl)) & lib.FILECHANGE_attribs_MASK) >> lib.FILECHANGE_attribs_SHIFT)
   @attribs.setter
   def attribs(self, value): self.impl = ((self.impl) & ~(lib.FILECHANGE_attribs_MASK)) | (((value)) << lib.FILECHANGE_attribs_SHIFT)

@ffi.callback("eC_SettingsIOResult(eC_GlobalSettings)")
def cb_GlobalSettings_load(__e):
   globalsettings = pyOrNewObject(GlobalSettings, __e)
   return globalsettings.fn_GlobalSettings_load(globalsettings)

@ffi.callback("void(eC_GlobalSettings)")
def cb_GlobalSettings_onAskReloadSettings(__e):
   globalsettings = pyOrNewObject(GlobalSettings, __e)
   globalsettings.fn_GlobalSettings_onAskReloadSettings(globalsettings)

@ffi.callback("eC_SettingsIOResult(eC_GlobalSettings)")
def cb_GlobalSettings_save(__e):
   globalsettings = pyOrNewObject(GlobalSettings, __e)
   return globalsettings.fn_GlobalSettings_save(globalsettings)

class GlobalSettings(Instance):
   class_members = [
                      'settingsName',
                      'settingsExtension',
                      'settingsDirectory',
                      'settingsLocation',
                      'settingsFilePath',
                      'allowDefaultLocations',
                      'allUsers',
                      'portable',
                      'driver',
                      'data',
                      'dataOwner',
                      'dataClass',
                      'isGlobalPath',
                      'load',
                      'onAskReloadSettings',
                      'save',
                   ]

   def init_args(self, args, kwArgs): init_args(GlobalSettings, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def settingsName(self): value = lib.GlobalSettings_get_settingsName(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @settingsName.setter
   def settingsName(self, value):
      lib.GlobalSettings_set_settingsName(self.impl, value.encode('u8'))

   @property
   def settingsExtension(self): value = lib.GlobalSettings_get_settingsExtension(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @settingsExtension.setter
   def settingsExtension(self, value):
      lib.GlobalSettings_set_settingsExtension(self.impl, value.encode('u8'))

   @property
   def settingsDirectory(self): value = lib.GlobalSettings_get_settingsDirectory(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @settingsDirectory.setter
   def settingsDirectory(self, value):
      lib.GlobalSettings_set_settingsDirectory(self.impl, value.encode('u8'))

   @property
   def settingsLocation(self): value = lib.GlobalSettings_get_settingsLocation(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @settingsLocation.setter
   def settingsLocation(self, value):
      lib.GlobalSettings_set_settingsLocation(self.impl, value.encode('u8'))

   @property
   def settingsFilePath(self): value = lib.GlobalSettings_get_settingsFilePath(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @settingsFilePath.setter
   def settingsFilePath(self, value):
      lib.GlobalSettings_set_settingsFilePath(self.impl, value.encode('u8'))

   @property
   def allowDefaultLocations(self): return lib.GlobalSettings_get_allowDefaultLocations(self.impl)
   @allowDefaultLocations.setter
   def allowDefaultLocations(self, value):
      lib.GlobalSettings_set_allowDefaultLocations(self.impl, value)

   @property
   def allUsers(self): return lib.GlobalSettings_get_allUsers(self.impl)
   @allUsers.setter
   def allUsers(self, value):
      lib.GlobalSettings_set_allUsers(self.impl, value)

   @property
   def portable(self): return lib.GlobalSettings_get_portable(self.impl)
   @portable.setter
   def portable(self, value):
      lib.GlobalSettings_set_portable(self.impl, value)

   @property
   def driver(self): value = lib.GlobalSettings_get_driver(self.impl) if self is not None and self.impl != ffi.NULL else ffi.NULL; return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @driver.setter
   def driver(self, value):
      if not isinstance(value, String): value = String(value)
      lib.GlobalSettings_set_driver(self.impl, value.impl.encode('u8'))

   @property
   def data(self): return pyOrNewObject(GlobalSettingsData, IPTR(lib, ffi, self, GlobalSettings).data)
   @data.setter
   def data(self, value):
      if not isinstance(value, GlobalSettingsData): value = GlobalSettingsData(value)
      IPTR(lib, ffi, self, GlobalSettings).data = value.impl

   @property
   def dataOwner(self): return IPTR(lib, ffi, self, GlobalSettings).dataOwner
   @dataOwner.setter
   def dataOwner(self, value): IPTR(lib, ffi, self, GlobalSettings).dataOwner = value

   @property
   def dataClass(self): return IPTR(lib, ffi, self, GlobalSettings).dataClass
   @dataClass.setter
   def dataClass(self, value): IPTR(lib, ffi, self, GlobalSettings).dataClass = value

   @property
   def isGlobalPath(self): return lib.GlobalSettings_get_isGlobalPath(self.impl)

   def close(self):
      lib.GlobalSettings_close(self.impl)

   def closeAndMonitor(self):
      lib.GlobalSettings_closeAndMonitor(self.impl)

   def fn_unset_GlobalSettings_load(self):
      return lib.GlobalSettings_load(self.impl)

   @property
   def load(self):
      if hasattr(self, 'fn_GlobalSettings_load'): return self.fn_GlobalSettings_load
      else: return self.fn_unset_GlobalSettings_load
   @load.setter
   def load(self, value):
      self.fn_GlobalSettings_load = value
      lib.Instance_setMethod(self.impl, "Load".encode('u8'), cb_GlobalSettings_load)

   def fn_unset_GlobalSettings_onAskReloadSettings(self):
      return lib.GlobalSettings_onAskReloadSettings(self.impl)

   @property
   def onAskReloadSettings(self):
      if hasattr(self, 'fn_GlobalSettings_onAskReloadSettings'): return self.fn_GlobalSettings_onAskReloadSettings
      else: return self.fn_unset_GlobalSettings_onAskReloadSettings
   @onAskReloadSettings.setter
   def onAskReloadSettings(self, value):
      self.fn_GlobalSettings_onAskReloadSettings = value
      lib.Instance_setMethod(self.impl, "OnAskReloadSettings".encode('u8'), cb_GlobalSettings_onAskReloadSettings)

   def openAndLock(self):
      fileSize = ffi.new("eC_FileSize *")
      r = lib.GlobalSettings_openAndLock(self.impl, fileSize)
      return r, FileSize(impl = fileSize[0])

   def fn_unset_GlobalSettings_save(self):
      return lib.GlobalSettings_save(self.impl)

   @property
   def save(self):
      if hasattr(self, 'fn_GlobalSettings_save'): return self.fn_GlobalSettings_save
      else: return self.fn_unset_GlobalSettings_save
   @save.setter
   def save(self, value):
      self.fn_GlobalSettings_save = value
      lib.Instance_setMethod(self.impl, "Save".encode('u8'), cb_GlobalSettings_save)

@ffi.callback("eC_SettingsIOResult(eC_GlobalSettingsDriver, eC_File, eC_GlobalSettings)")
def cb_GlobalSettingsDriver_load(__e, f, globalSettings):
   globalsettingsdriver = pyOrNewObject(GlobalSettingsDriver, __e)
   return globalsettingsdriver.fn_GlobalSettingsDriver_load(globalsettingsdriver, pyOrNewObject(File, f), pyOrNewObject(GlobalSettings, globalSettings))

@ffi.callback("eC_SettingsIOResult(eC_GlobalSettingsDriver, eC_File, eC_GlobalSettings)")
def cb_GlobalSettingsDriver_save(__e, f, globalSettings):
   globalsettingsdriver = pyOrNewObject(GlobalSettingsDriver, __e)
   return globalsettingsdriver.fn_GlobalSettingsDriver_save(globalsettingsdriver, pyOrNewObject(File, f), pyOrNewObject(GlobalSettings, globalSettings))

class GlobalSettingsDriver(Instance):
   class_members = [
                      'load',
                      'save',
                   ]

   def init_args(self, args, kwArgs): init_args(GlobalSettingsDriver, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def fn_unset_GlobalSettingsDriver_load(self, f, globalSettings):
      return lib.GlobalSettingsDriver_load(self.impl, ffi.NULL if f is None else f.impl, ffi.NULL if globalSettings is None else globalSettings.impl)

   @property
   def load(self):
      if hasattr(self, 'fn_GlobalSettingsDriver_load'): return self.fn_GlobalSettingsDriver_load
      else: return self.fn_unset_GlobalSettingsDriver_load
   @load.setter
   def load(self, value):
      self.fn_GlobalSettingsDriver_load = value
      lib.Instance_setMethod(self.impl, "Load".encode('u8'), cb_GlobalSettingsDriver_load)

   def fn_unset_GlobalSettingsDriver_save(self, f, globalSettings):
      return lib.GlobalSettingsDriver_save(self.impl, ffi.NULL if f is None else f.impl, ffi.NULL if globalSettings is None else globalSettings.impl)

   @property
   def save(self):
      if hasattr(self, 'fn_GlobalSettingsDriver_save'): return self.fn_GlobalSettingsDriver_save
      else: return self.fn_unset_GlobalSettingsDriver_save
   @save.setter
   def save(self, value):
      self.fn_GlobalSettingsDriver_save = value
      lib.Instance_setMethod(self.impl, "Save".encode('u8'), cb_GlobalSettingsDriver_save)

class JSONParser(Instance):
   class_members = [
                      'f',
                      'customJsonOptions',
                      'debug',
                      'warnings',
                   ]

   def init_args(self, args, kwArgs): init_args(JSONParser, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def f(self): return pyOrNewObject(File, IPTR(lib, ffi, self, JSONParser).f)
   @f.setter
   def f(self, value):
      if not isinstance(value, File): value = File(value)
      IPTR(lib, ffi, self, JSONParser).f = value.impl

   @property
   def customJsonOptions(self): return pyOrNewObject(OptionsMap, IPTR(lib, ffi, self, JSONParser).customJsonOptions)
   @customJsonOptions.setter
   def customJsonOptions(self, value):
      if not isinstance(value, OptionsMap): value = OptionsMap(value)
      IPTR(lib, ffi, self, JSONParser).customJsonOptions = value.impl

   @property
   def debug(self): return lib.JSONParser_get_debug(self.impl)
   @debug.setter
   def debug(self, value):
      lib.JSONParser_set_debug(self.impl, value)

   @property
   def warnings(self): return lib.JSONParser_get_warnings(self.impl)
   @warnings.setter
   def warnings(self, value):
      lib.JSONParser_set_warnings(self.impl, value)

   def getObject(self, objectType = None):
      if objectType is not None and not isinstance(objectType, Class): objectType = Class(objectType)
      objectType = ffi.NULL if objectType is None else objectType.impl
      object = ffi.new("void * *")
      r = lib.JSONParser_getObject(self.impl, ffi.cast("struct eC_Class *", objectType), object)
      if object[0] == ffi.NULL: _object = None
      else:
         if objectType.type == ClassType.normalClass:
            i = ffi.cast("eC_Instance", object[0])
            n = ffi.string(i._class.name).decode('u8')
         else:
            n = ffi.string(objectType.name).decode('u8')
         t = pyTypeByName(n)
         ct = n + " * " if objectType.type == ClassType.noHeadClass else n
         _object = t(impl = pyFFI().cast(ct, object[0]))
      return r, _object

class SmartKey(pyBaseClass):
   def __init__(self, code = 0, shift = False, ctrl = False, alt = False, modifiers = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(code, SmartKey):
         self.impl = code.impl
      else:
         if isinstance(code, tuple):
            __tuple = code
            code = 0
            if len(__tuple) > 0: code = __tuple[0]
            if len(__tuple) > 1: shift = __tuple[1]
            if len(__tuple) > 2: ctrl = __tuple[2]
            if len(__tuple) > 3: alt = __tuple[3]
            if len(__tuple) > 4: modifiers = __tuple[4]
         elif isinstance(code, Key):
            self.impl = lib.Key_to_SmartKey(code.impl)
            return
         if not isinstance(modifiers, Modifiers): modifiers = Modifiers(modifiers)
         self.impl = (
            (code           << lib.SMARTKEY_code_SHIFT)           |
            (shift          << lib.SMARTKEY_shift_SHIFT)          |
            (ctrl           << lib.SMARTKEY_ctrl_SHIFT)           |
            (alt            << lib.SMARTKEY_alt_SHIFT)            |
            (modifiers.impl << lib.SMARTKEY_modifiers_SHIFT)      )

   @property
   def code(self): return ((((self.impl)) & lib.SMARTKEY_code_MASK) >> lib.SMARTKEY_code_SHIFT)
   @code.setter
   def code(self, value): self.impl = ((self.impl) & ~(lib.SMARTKEY_code_MASK)) | (((value)) << lib.SMARTKEY_code_SHIFT)

   @property
   def shift(self): return ((((self.impl)) & lib.SMARTKEY_shift_MASK) >> lib.SMARTKEY_shift_SHIFT)
   @shift.setter
   def shift(self, value): self.impl = ((self.impl) & ~(lib.SMARTKEY_shift_MASK)) | (((value)) << lib.SMARTKEY_shift_SHIFT)

   @property
   def ctrl(self): return ((((self.impl)) & lib.SMARTKEY_ctrl_MASK) >> lib.SMARTKEY_ctrl_SHIFT)
   @ctrl.setter
   def ctrl(self, value): self.impl = ((self.impl) & ~(lib.SMARTKEY_ctrl_MASK)) | (((value)) << lib.SMARTKEY_ctrl_SHIFT)

   @property
   def alt(self): return ((((self.impl)) & lib.SMARTKEY_alt_MASK) >> lib.SMARTKEY_alt_SHIFT)
   @alt.setter
   def alt(self, value): self.impl = ((self.impl) & ~(lib.SMARTKEY_alt_MASK)) | (((value)) << lib.SMARTKEY_alt_SHIFT)

   @property
   def modifiers(self): return ((((self.impl)) & lib.SMARTKEY_modifiers_MASK) >> lib.SMARTKEY_modifiers_SHIFT)
   @modifiers.setter
   def modifiers(self, value): self.impl = ((self.impl) & ~(lib.SMARTKEY_modifiers_MASK)) | (((value)) << lib.SMARTKEY_modifiers_SHIFT)

class Key(pyBaseClass):
   def __init__(self, code = 0, shift = False, ctrl = False, alt = False, cmd = False, modifiers = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(code, Key):
         self.impl = code.impl
      else:
         if isinstance(code, tuple):
            __tuple = code
            code = 0
            if len(__tuple) > 0: code = __tuple[0]
            if len(__tuple) > 1: shift = __tuple[1]
            if len(__tuple) > 2: ctrl = __tuple[2]
            if len(__tuple) > 3: alt = __tuple[3]
            if len(__tuple) > 4: cmd = __tuple[4]
            if len(__tuple) > 5: modifiers = __tuple[5]
         elif isinstance(code, SmartKey):
            self.impl = lib.Key_from_SmartKey(code.impl)
            return
         if not isinstance(modifiers, Modifiers): modifiers = Modifiers(modifiers)
         self.impl = (
            (code           << lib.KEY_code_SHIFT)           |
            (shift          << lib.KEY_shift_SHIFT)          |
            (ctrl           << lib.KEY_ctrl_SHIFT)           |
            (alt            << lib.KEY_alt_SHIFT)            |
            (cmd            << lib.KEY_cmd_SHIFT)            |
            (modifiers.impl << lib.KEY_modifiers_SHIFT)      )

   @property
   def code(self): return ((((self.impl)) & lib.KEY_code_MASK) >> lib.KEY_code_SHIFT)
   @code.setter
   def code(self, value): self.impl = ((self.impl) & ~(lib.KEY_code_MASK)) | (((value)) << lib.KEY_code_SHIFT)

   @property
   def shift(self): return ((((self.impl)) & lib.KEY_shift_MASK) >> lib.KEY_shift_SHIFT)
   @shift.setter
   def shift(self, value): self.impl = ((self.impl) & ~(lib.KEY_shift_MASK)) | (((value)) << lib.KEY_shift_SHIFT)

   @property
   def ctrl(self): return ((((self.impl)) & lib.KEY_ctrl_MASK) >> lib.KEY_ctrl_SHIFT)
   @ctrl.setter
   def ctrl(self, value): self.impl = ((self.impl) & ~(lib.KEY_ctrl_MASK)) | (((value)) << lib.KEY_ctrl_SHIFT)

   @property
   def alt(self): return ((((self.impl)) & lib.KEY_alt_MASK) >> lib.KEY_alt_SHIFT)
   @alt.setter
   def alt(self, value): self.impl = ((self.impl) & ~(lib.KEY_alt_MASK)) | (((value)) << lib.KEY_alt_SHIFT)

   @property
   def cmd(self): return ((((self.impl)) & lib.KEY_cmd_MASK) >> lib.KEY_cmd_SHIFT)
   @cmd.setter
   def cmd(self, value): self.impl = ((self.impl) & ~(lib.KEY_cmd_MASK)) | (((value)) << lib.KEY_cmd_SHIFT)

   @property
   def modifiers(self): return ((((self.impl)) & lib.KEY_modifiers_MASK) >> lib.KEY_modifiers_SHIFT)
   @modifiers.setter
   def modifiers(self, value): self.impl = ((self.impl) & ~(lib.KEY_modifiers_MASK)) | (((value)) << lib.KEY_modifiers_SHIFT)

   # def Key_to_SmartKey(self): return SmartKey(impl = lib.Key_to_SmartKey(self.impl))

   # here is an unhandled conversion: Key::SmartKey (BitClass 2 BitClass)
   # Key_to_SmartKey
   # Key_from_SmartKey

class Matrix(Struct):
   def __init__(self, array = None, m = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Matrix *", impl)
      else:
         if isinstance(array, tuple):
            __tuple = array
            array = None
            if len(__tuple) > 0: array = __tuple[0]
         elif isinstance(array, Quaternion):
            self.impl = ffi.new("eC_Matrix *")
            lib.Matrix_from_Quaternion(self.impl, array.impl)
            return
         elif isinstance(array, Matrixf):
            self.impl = ffi.new("eC_Matrix *")
            lib.Matrixf_to_Matrix(array.impl, self.impl)
            return
         elif isinstance(array, Transform):
            self.impl = ffi.new("eC_Matrix *")
            lib.Transform_to_Matrix(array.impl, self.impl)
            return
         __members = { }
         if array is not None: __members['array'] = array.impl
         if m is not None:     __members['m']     = m.impl
         self.impl = ffi.new("eC_Matrix *", __members)

   @property
   def array(self): return self.impl.array
   @array.setter
   def array(self, value): self.impl.array = value

   @property
   def m(self): return self.impl.m
   @m.setter
   def m(self, value): self.impl.m = value

   # def Matrix_to_Quaternion(self): value = Quaternion(); lib.Matrix_to_Quaternion(self.impl, ffi.cast("eC_Quaternion *", value.impl)); return

   # here is an unhandled conversion: Matrix::Quaternion (StructClass 2 StructClass)
   # Matrix_to_Quaternion
   # Matrix_from_Quaternion

   def determinant(self):
      return lib.Matrix_determinant(ffi.cast("eC_Matrix *", self.impl))

   def identity(self):
      lib.Matrix_identity(ffi.cast("eC_Matrix *", self.impl))

   def inverse(self, source = None):
      if source is not None and not isinstance(source, Matrix): source = Matrix(source)
      source = ffi.NULL if source is None else source.impl
      lib.Matrix_inverse(ffi.cast("eC_Matrix *", self.impl), ffi.cast("eC_Matrix *", source))

   def inverseTransposeTransform(self, source = None):
      if source is not None and not isinstance(source, Matrix): source = Matrix(source)
      source = ffi.NULL if source is None else source.impl
      lib.Matrix_inverseTransposeTransform(ffi.cast("eC_Matrix *", self.impl), ffi.cast("eC_Matrix *", source))

   def multiply(self, a = None, b = None):
      if a is not None and not isinstance(a, Matrix): a = Matrix(a)
      a = ffi.NULL if a is None else a.impl
      if b is not None and not isinstance(b, Matrix): b = Matrix(b)
      b = ffi.NULL if b is None else b.impl
      lib.Matrix_multiply(ffi.cast("eC_Matrix *", self.impl), ffi.cast("eC_Matrix *", a), ffi.cast("eC_Matrix *", b))

   def multiply3x4(self, a = None, b = None):
      if a is not None and not isinstance(a, Matrix): a = Matrix(a)
      a = ffi.NULL if a is None else a.impl
      if b is not None and not isinstance(b, Matrix): b = Matrix(b)
      b = ffi.NULL if b is None else b.impl
      lib.Matrix_multiply3x4(ffi.cast("eC_Matrix *", self.impl), ffi.cast("eC_Matrix *", a), ffi.cast("eC_Matrix *", b))

   def rotate(self, quat = None):
      if quat is not None and not isinstance(quat, Quaternion): quat = Quaternion(quat)
      quat = ffi.NULL if quat is None else quat.impl
      lib.Matrix_rotate(ffi.cast("eC_Matrix *", self.impl), ffi.cast("eC_Quaternion *", quat))

   def rotationQuaternion(self, quat = None):
      if quat is not None and not isinstance(quat, Quaternion): quat = Quaternion(quat)
      quat = ffi.NULL if quat is None else quat.impl
      lib.Matrix_rotationQuaternion(ffi.cast("eC_Matrix *", self.impl), ffi.cast("eC_Quaternion *", quat))

   def scale(self, sx, sy, sz):
      lib.Matrix_scale(ffi.cast("eC_Matrix *", self.impl), sx, sy, sz)

   def toEuler(self, euler = None):
      if euler is not None and not isinstance(euler, Euler): euler = Euler(euler)
      euler = ffi.NULL if euler is None else euler.impl
      lib.Matrix_toEuler(ffi.cast("eC_Matrix *", self.impl), ffi.cast("eC_Euler *", euler))

   def translate(self, tx, ty, tz):
      lib.Matrix_translate(ffi.cast("eC_Matrix *", self.impl), tx, ty, tz)

   def transpose(self, source = None):
      if source is not None and not isinstance(source, Matrix): source = Matrix(source)
      source = ffi.NULL if source is None else source.impl
      lib.Matrix_transpose(ffi.cast("eC_Matrix *", self.impl), ffi.cast("eC_Matrix *", source))

   def isIdentity(self):
      return lib.Matrix_isIdentity(ffi.cast("eC_Matrix *", self.impl))

class Matrixf(Struct):
   def __init__(self, m = None, array = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Matrixf *", impl)
      else:
         if isinstance(m, tuple):
            __tuple = m
            m = None
            if len(__tuple) > 0: m     = __tuple[0]
         elif isinstance(m, Matrix):
            self.impl = ffi.new("eC_Matrixf *")
            lib.Matrixf_from_Matrix(self.impl, m.impl)
            return
         __members = { }
         if m is not None:     __members['m']     = m.impl
         if array is not None: __members['array'] = array.impl
         self.impl = ffi.new("eC_Matrixf *", __members)

   @property
   def m(self): return self.impl.m
   @m.setter
   def m(self, value): self.impl.m = value

   @property
   def array(self): return self.impl.array
   @array.setter
   def array(self, value): self.impl.array = value

   # def Matrixf_to_Matrix(self): value = Matrix(); lib.Matrixf_to_Matrix(self.impl, ffi.cast("eC_Matrix *", value.impl)); return

   # here is an unhandled conversion: Matrixf::Matrix (StructClass 2 StructClass)
   # Matrixf_to_Matrix
   # Matrixf_from_Matrix

   def identity(self):
      lib.Matrixf_identity(ffi.cast("eC_Matrixf *", self.impl))

   def fromMatrix(self, m = None):
      if m is not None and not isinstance(m, Matrix): m = Matrix(m)
      m = ffi.NULL if m is None else m.impl
      lib.Matrixf_fromMatrix(ffi.cast("eC_Matrixf *", self.impl), ffi.cast("eC_Matrix *", m))

class Meters(Distance):
   def __init__(self, value = 0, impl = None):
      if impl is not None: self.impl = impl
      elif isinstance(value, Distance): self.impl = value.impl
      else: self.impl = value
   @property
   def value(self): return self.impl
   @value.setter
   def value(self, value): self.impl = value

Meters.buc = Distance

class MinMaxValue(pyBaseClass):
   def __init__(self, impl = 0):
      self.impl = impl

MinMaxValue.buc = MinMaxValue

class Quaternion(Struct):
   def __init__(self, w = 0.0, x = 0.0, y = 0.0, z = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Quaternion *", impl)
      else:
         if isinstance(w, tuple):
            __tuple = w
            w = 0.0
            if len(__tuple) > 0: w = __tuple[0]
            if len(__tuple) > 1: x = __tuple[1]
            if len(__tuple) > 2: y = __tuple[2]
            if len(__tuple) > 3: z = __tuple[3]
         elif isinstance(w, Euler):
            self.impl = ffi.new("eC_Quaternion *")
            lib.Euler_to_Quaternion(w.impl, self.impl)
            return
         elif isinstance(w, Matrix):
            self.impl = ffi.new("eC_Quaternion *")
            lib.Matrix_to_Quaternion(w.impl, self.impl)
            return
         self.impl = ffi.new("eC_Quaternion *", { 'w' : w, 'x' : x, 'y' : y, 'z' : z })

   @property
   def w(self): return self.impl.w
   @w.setter
   def w(self, value): self.impl.w = value

   @property
   def x(self): return self.impl.x
   @x.setter
   def x(self, value): self.impl.x = value

   @property
   def y(self): return self.impl.y
   @y.setter
   def y(self, value): self.impl.y = value

   @property
   def z(self): return self.impl.z
   @z.setter
   def z(self, value): self.impl.z = value

   def divide(self, q1 = None, q2 = None):
      if q1 is not None and not isinstance(q1, Quaternion): q1 = Quaternion(q1)
      q1 = ffi.NULL if q1 is None else q1.impl
      if q2 is not None and not isinstance(q2, Quaternion): q2 = Quaternion(q2)
      q2 = ffi.NULL if q2 is None else q2.impl
      lib.Quaternion_divide(ffi.cast("eC_Quaternion *", self.impl), ffi.cast("eC_Quaternion *", q1), ffi.cast("eC_Quaternion *", q2))

   def identity(self):
      lib.Quaternion_identity(ffi.cast("eC_Quaternion *", self.impl))

   def inverse(self, source = None):
      if source is not None and not isinstance(source, Quaternion): source = Quaternion(source)
      source = ffi.NULL if source is None else source.impl
      lib.Quaternion_inverse(ffi.cast("eC_Quaternion *", self.impl), ffi.cast("eC_Quaternion *", source))

   def multiply(self, q1 = None, q2 = None):
      if q1 is not None and not isinstance(q1, Quaternion): q1 = Quaternion(q1)
      q1 = ffi.NULL if q1 is None else q1.impl
      if q2 is not None and not isinstance(q2, Quaternion): q2 = Quaternion(q2)
      q2 = ffi.NULL if q2 is None else q2.impl
      lib.Quaternion_multiply(ffi.cast("eC_Quaternion *", self.impl), ffi.cast("eC_Quaternion *", q1), ffi.cast("eC_Quaternion *", q2))

   def normalize(self, source = None):
      if source is not None and not isinstance(source, Quaternion): source = Quaternion(source)
      source = ffi.NULL if source is None else source.impl
      lib.Quaternion_normalize(ffi.cast("eC_Quaternion *", self.impl), ffi.cast("eC_Quaternion *", source))

   def pitch(self, angle):
      if angle is not None and not isinstance(angle, Angle): angle = Degrees(angle)
      if angle is None: angle = ffi.NULL
      lib.Quaternion_pitch(ffi.cast("eC_Quaternion *", self.impl), angle.impl)

   def roll(self, angle):
      if angle is not None and not isinstance(angle, Angle): angle = Degrees(angle)
      if angle is None: angle = ffi.NULL
      lib.Quaternion_roll(ffi.cast("eC_Quaternion *", self.impl), angle.impl)

   def rotatePitch(self, pitch):
      if pitch is not None and not isinstance(pitch, Angle): pitch = Degrees(pitch)
      if pitch is None: pitch = ffi.NULL
      lib.Quaternion_rotatePitch(ffi.cast("eC_Quaternion *", self.impl), pitch.impl)

   def rotateRoll(self, roll):
      if roll is not None and not isinstance(roll, Angle): roll = Degrees(roll)
      if roll is None: roll = ffi.NULL
      lib.Quaternion_rotateRoll(ffi.cast("eC_Quaternion *", self.impl), roll.impl)

   def rotateYaw(self, yaw):
      if yaw is not None and not isinstance(yaw, Angle): yaw = Degrees(yaw)
      if yaw is None: yaw = ffi.NULL
      lib.Quaternion_rotateYaw(ffi.cast("eC_Quaternion *", self.impl), yaw.impl)

   def rotateYawPitch(self, yaw, pitch):
      if yaw is not None and not isinstance(yaw, Angle): yaw = Degrees(yaw)
      if yaw is None: yaw = ffi.NULL
      if pitch is not None and not isinstance(pitch, Angle): pitch = Degrees(pitch)
      if pitch is None: pitch = ffi.NULL
      lib.Quaternion_rotateYawPitch(ffi.cast("eC_Quaternion *", self.impl), yaw.impl, pitch.impl)

   def rotationAxis(self, axis, angle):
      if axis is not None and not isinstance(axis, Vector3D): axis = Vector3D(axis)
      axis = ffi.NULL if axis is None else axis.impl
      if angle is not None and not isinstance(angle, Angle): angle = Degrees(angle)
      if angle is None: angle = ffi.NULL
      lib.Quaternion_rotationAxis(ffi.cast("eC_Quaternion *", self.impl), ffi.cast("eC_Vector3D *", axis), angle.impl)

   def rotationDirection(self, direction = None):
      if direction is not None and not isinstance(direction, Vector3D): direction = Vector3D(direction)
      direction = ffi.NULL if direction is None else direction.impl
      lib.Quaternion_rotationDirection(ffi.cast("eC_Quaternion *", self.impl), ffi.cast("eC_Vector3D *", direction))

   def rotationEuler(self, euler, rotationOrder):
      if euler is not None and not isinstance(euler, Euler): euler = Euler(euler)
      euler = ffi.NULL if euler is None else euler.impl
      lib.Quaternion_rotationEuler(ffi.cast("eC_Quaternion *", self.impl), ffi.cast("eC_Euler *", euler), rotationOrder)

   def rotationMatrix(self, m = None):
      if m is not None and not isinstance(m, Matrix): m = Matrix(m)
      m = ffi.NULL if m is None else m.impl
      lib.Quaternion_rotationMatrix(ffi.cast("eC_Quaternion *", self.impl), ffi.cast("eC_Matrix *", m))

   def rotationYawPitchRoll(self, euler = None):
      if euler is not None and not isinstance(euler, Euler): euler = Euler(euler)
      euler = ffi.NULL if euler is None else euler.impl
      lib.Quaternion_rotationYawPitchRoll(ffi.cast("eC_Quaternion *", self.impl), ffi.cast("eC_Euler *", euler))

   def slerp(self, _from, to, t):
      if _from is not None and not isinstance(_from, Quaternion): _from = Quaternion(_from)
      _from = ffi.NULL if _from is None else _from.impl
      if to is not None and not isinstance(to, Quaternion): to = Quaternion(to)
      to = ffi.NULL if to is None else to.impl
      lib.Quaternion_slerp(ffi.cast("eC_Quaternion *", self.impl), ffi.cast("eC_Quaternion *", _from), ffi.cast("eC_Quaternion *", to), t)

   def toDirection(self, direction = None):
      if direction is not None and not isinstance(direction, Vector3D): direction = Vector3D(direction)
      direction = ffi.NULL if direction is None else direction.impl
      lib.Quaternion_toDirection(ffi.cast("eC_Quaternion *", self.impl), ffi.cast("eC_Vector3D *", direction))

   def yaw(self, angle):
      if angle is not None and not isinstance(angle, Angle): angle = Degrees(angle)
      if angle is None: angle = ffi.NULL
      lib.Quaternion_yaw(ffi.cast("eC_Quaternion *", self.impl), angle.impl)

   def yawPitch(self, yaw, pitch):
      if yaw is not None and not isinstance(yaw, Angle): yaw = Degrees(yaw)
      if yaw is None: yaw = ffi.NULL
      if pitch is not None and not isinstance(pitch, Angle): pitch = Degrees(pitch)
      if pitch is None: pitch = ffi.NULL
      lib.Quaternion_yawPitch(ffi.cast("eC_Quaternion *", self.impl), yaw.impl, pitch.impl)

   def rotateQuats(self, qPitch, qYaw, qRoll, rotationOrder):
      if qPitch is not None and not isinstance(qPitch, Quaternion): qPitch = Quaternion(qPitch)
      qPitch = ffi.NULL if qPitch is None else qPitch.impl
      if qYaw is not None and not isinstance(qYaw, Quaternion): qYaw = Quaternion(qYaw)
      qYaw = ffi.NULL if qYaw is None else qYaw.impl
      if qRoll is not None and not isinstance(qRoll, Quaternion): qRoll = Quaternion(qRoll)
      qRoll = ffi.NULL if qRoll is None else qRoll.impl
      lib.Quaternion_rotateQuats(ffi.cast("eC_Quaternion *", self.impl), ffi.cast("eC_Quaternion *", qPitch), ffi.cast("eC_Quaternion *", qYaw), ffi.cast("eC_Quaternion *", qRoll), rotationOrder)

class Radians(Angle):
   def __init__(self, value = 0, impl = None):
      if impl is not None: self.impl = impl
      elif isinstance(value, Angle): self.impl = value.impl
      else: self.impl = value
   @property
   def value(self): return self.impl
   @value.setter
   def value(self, value): self.impl = value

Radians.buc = Angle

class SecSince1970(pyBaseClass):
   def __init__(self, impl = 0):
      self.impl = impl

   @property
   def _global(self): return SecSince1970(impl = lib.SecSince1970_get_global(self.impl))

   @property
   def local(self): return SecSince1970(impl = lib.SecSince1970_get_local(self.impl))

SecSince1970.buc = SecSince1970

class Time(pyBaseClass):
   def __init__(self, impl = 0):
      self.impl = impl

Time.buc = Time

class Seconds(Time):
   def __init__(self, value = 0, impl = None):
      if impl is not None: self.impl = impl
      elif isinstance(value, Time): self.impl = value.impl
      else: self.impl = value
   @property
   def value(self): return self.impl
   @value.setter
   def value(self, value): self.impl = value

Seconds.buc = Time

AnyFileChange = FileChange ( True, True, True, True, True )

Pi = Radians ( 3.1415926535897932384626433832795028841971 )

@ffi.callback("eC_bool(eC_Archive)")
def cb_Archive_clear(__e):
   archive = pyOrNewObject(Archive, __e)
   return archive.fn_Archive_clear(archive)

@ffi.callback("eC_FileAttribs(eC_Archive, const char *)")
def cb_Archive_fileExists(__e, fileName):
   archive = pyOrNewObject(Archive, __e)
   return archive.fn_Archive_fileExists(archive, fileName.encode('u8'))

@ffi.callback("eC_File(eC_Archive, const char *)")
def cb_Archive_fileOpen(__e, fileName):
   archive = pyOrNewObject(Archive, __e)
   return archive.fn_Archive_fileOpen(archive, fileName.encode('u8'))

@ffi.callback("eC_File(eC_Archive, uint)")
def cb_Archive_fileOpenAtPosition(__e, position):
   archive = pyOrNewObject(Archive, __e)
   return archive.fn_Archive_fileOpenAtPosition(archive, position)

@ffi.callback("eC_File(eC_Archive, const char *, eC_bool *, uint64 *)")
def cb_Archive_fileOpenCompressed(__e, fileName, isCompressed, ucSize):
   archive = pyOrNewObject(Archive, __e)
   return archive.fn_Archive_fileOpenCompressed(archive, fileName.encode('u8'), isCompressed, ucSize)

@ffi.callback("eC_ArchiveDir(eC_Archive, const char *, eC_FileStats *, eC_ArchiveAddMode)")
def cb_Archive_openDirectory(__e, name, stats, addMode):
   archive = pyOrNewObject(Archive, __e)
   return archive.fn_Archive_openDirectory(archive, name.encode('u8'), FileStats(impl = stats), ArchiveAddMode(impl = addMode))

@ffi.callback("void(eC_Archive, uint)")
def cb_Archive_setBufferRead(__e, bufferRead):
   archive = pyOrNewObject(Archive, __e)
   archive.fn_Archive_setBufferRead(archive, bufferRead)

@ffi.callback("void(eC_Archive, uint)")
def cb_Archive_setBufferSize(__e, bufferSize):
   archive = pyOrNewObject(Archive, __e)
   archive.fn_Archive_setBufferSize(archive, bufferSize)

class Archive(Instance):
   class_members = [
                      'totalSize',
                      'bufferSize',
                      'bufferRead',
                      'clear',
                      'fileExists',
                      'fileOpen',
                      'fileOpenAtPosition',
                      'fileOpenCompressed',
                      'openDirectory',
                      'setBufferRead',
                      'setBufferSize',
                   ]

   def init_args(self, args, kwArgs): init_args(Archive, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def totalSize(self): return FileSize(impl = lib.Archive_get_totalSize(self.impl))
   @totalSize.setter
   def totalSize(self, value):
      if not isinstance(value, FileSize): value = FileSize(value)
      lib.Archive_set_totalSize(self.impl, value.impl)

   @property
   def bufferSize(self): return None
   @bufferSize.setter
   def bufferSize(self, value):
      lib.Archive_set_bufferSize(self.impl, value)

   @property
   def bufferRead(self): return None
   @bufferRead.setter
   def bufferRead(self, value):
      lib.Archive_set_bufferRead(self.impl, value)

   def fn_unset_Archive_clear(self):
      return lib.Archive_clear(self.impl)

   @property
   def clear(self):
      if hasattr(self, 'fn_Archive_clear'): return self.fn_Archive_clear
      else: return self.fn_unset_Archive_clear
   @clear.setter
   def clear(self, value):
      self.fn_Archive_clear = value
      lib.Instance_setMethod(self.impl, "Clear".encode('u8'), cb_Archive_clear)

   def fn_unset_Archive_fileExists(self, fileName):
      return lib.Archive_fileExists(self.impl, fileName)

   @property
   def fileExists(self):
      if hasattr(self, 'fn_Archive_fileExists'): return self.fn_Archive_fileExists
      else: return self.fn_unset_Archive_fileExists
   @fileExists.setter
   def fileExists(self, value):
      self.fn_Archive_fileExists = value
      lib.Instance_setMethod(self.impl, "FileExists".encode('u8'), cb_Archive_fileExists)

   def fn_unset_Archive_fileOpen(self, fileName):
      return pyOrNewObject(File, lib.Archive_fileOpen(self.impl, fileName))

   @property
   def fileOpen(self):
      if hasattr(self, 'fn_Archive_fileOpen'): return self.fn_Archive_fileOpen
      else: return self.fn_unset_Archive_fileOpen
   @fileOpen.setter
   def fileOpen(self, value):
      self.fn_Archive_fileOpen = value
      lib.Instance_setMethod(self.impl, "FileOpen".encode('u8'), cb_Archive_fileOpen)

   def fn_unset_Archive_fileOpenAtPosition(self, position):
      return pyOrNewObject(File, lib.Archive_fileOpenAtPosition(self.impl, position))

   @property
   def fileOpenAtPosition(self):
      if hasattr(self, 'fn_Archive_fileOpenAtPosition'): return self.fn_Archive_fileOpenAtPosition
      else: return self.fn_unset_Archive_fileOpenAtPosition
   @fileOpenAtPosition.setter
   def fileOpenAtPosition(self, value):
      self.fn_Archive_fileOpenAtPosition = value
      lib.Instance_setMethod(self.impl, "FileOpenAtPosition".encode('u8'), cb_Archive_fileOpenAtPosition)

   def fn_unset_Archive_fileOpenCompressed(self, fileName, isCompressed, ucSize):
      if isCompressed is None: isCompressed = ffi.NULL
      if ucSize is None: ucSize = ffi.NULL
      return pyOrNewObject(File, lib.Archive_fileOpenCompressed(self.impl, fileName, isCompressed, ucSize))

   @property
   def fileOpenCompressed(self):
      if hasattr(self, 'fn_Archive_fileOpenCompressed'): return self.fn_Archive_fileOpenCompressed
      else: return self.fn_unset_Archive_fileOpenCompressed
   @fileOpenCompressed.setter
   def fileOpenCompressed(self, value):
      self.fn_Archive_fileOpenCompressed = value
      lib.Instance_setMethod(self.impl, "FileOpenCompressed".encode('u8'), cb_Archive_fileOpenCompressed)

   def fn_unset_Archive_openDirectory(self, name, stats, addMode):
      return pyOrNewObject(ArchiveDir, lib.Archive_openDirectory(self.impl, name, ffi.NULL if stats is None else stats.impl, addMode))

   @property
   def openDirectory(self):
      if hasattr(self, 'fn_Archive_openDirectory'): return self.fn_Archive_openDirectory
      else: return self.fn_unset_Archive_openDirectory
   @openDirectory.setter
   def openDirectory(self, value):
      self.fn_Archive_openDirectory = value
      lib.Instance_setMethod(self.impl, "OpenDirectory".encode('u8'), cb_Archive_openDirectory)

   def fn_unset_Archive_setBufferRead(self, bufferRead):
      return lib.Archive_setBufferRead(self.impl, bufferRead)

   @property
   def setBufferRead(self):
      if hasattr(self, 'fn_Archive_setBufferRead'): return self.fn_Archive_setBufferRead
      else: return self.fn_unset_Archive_setBufferRead
   @setBufferRead.setter
   def setBufferRead(self, value):
      self.fn_Archive_setBufferRead = value
      lib.Instance_setMethod(self.impl, "SetBufferRead".encode('u8'), cb_Archive_setBufferRead)

   def fn_unset_Archive_setBufferSize(self, bufferSize):
      return lib.Archive_setBufferSize(self.impl, bufferSize)

   @property
   def setBufferSize(self):
      if hasattr(self, 'fn_Archive_setBufferSize'): return self.fn_Archive_setBufferSize
      else: return self.fn_unset_Archive_setBufferSize
   @setBufferSize.setter
   def setBufferSize(self, value):
      self.fn_Archive_setBufferSize = value
      lib.Instance_setMethod(self.impl, "SetBufferSize".encode('u8'), cb_Archive_setBufferSize)

class ArchiveAddMode:
   replace     = lib.ArchiveAddMode_replace
   refresh     = lib.ArchiveAddMode_refresh
   update      = lib.ArchiveAddMode_update
   readOnlyDir = lib.ArchiveAddMode_readOnlyDir

@ffi.callback("eC_bool(eC_ArchiveDir, const char *, eC_File, eC_FileStats *, eC_ArchiveAddMode, int, int *, uint *)")
def cb_ArchiveDir_addFromFile(__e, name, input, stats, addMode, compression, ratio, newPosition):
   archivedir = pyOrNewObject(ArchiveDir, __e)
   return archivedir.fn_ArchiveDir_addFromFile(archivedir, name.encode('u8'), pyOrNewObject(File, input), FileStats(impl = stats), ArchiveAddMode(impl = addMode), compression, ratio, newPosition)

@ffi.callback("eC_bool(eC_ArchiveDir, uint, const char *, eC_File, eC_FileStats *, eC_ArchiveAddMode, int, int *, uint *)")
def cb_ArchiveDir_addFromFileAtPosition(__e, position, name, input, stats, addMode, compression, ratio, newPosition):
   archivedir = pyOrNewObject(ArchiveDir, __e)
   return archivedir.fn_ArchiveDir_addFromFileAtPosition(archivedir, position, name.encode('u8'), pyOrNewObject(File, input), FileStats(impl = stats), ArchiveAddMode(impl = addMode), compression, ratio, newPosition)

@ffi.callback("eC_bool(eC_ArchiveDir, const char *)")
def cb_ArchiveDir_delete(__e, fileName):
   archivedir = pyOrNewObject(ArchiveDir, __e)
   return archivedir.fn_ArchiveDir_delete(archivedir, fileName.encode('u8'))

@ffi.callback("eC_FileAttribs(eC_ArchiveDir, const char *)")
def cb_ArchiveDir_fileExists(__e, fileName):
   archivedir = pyOrNewObject(ArchiveDir, __e)
   return archivedir.fn_ArchiveDir_fileExists(archivedir, fileName.encode('u8'))

@ffi.callback("eC_File(eC_ArchiveDir, const char *)")
def cb_ArchiveDir_fileOpen(__e, fileName):
   archivedir = pyOrNewObject(ArchiveDir, __e)
   return archivedir.fn_ArchiveDir_fileOpen(archivedir, fileName.encode('u8'))

@ffi.callback("eC_bool(eC_ArchiveDir, const char *, eC_ArchiveDir)")
def cb_ArchiveDir_move(__e, name, to):
   archivedir = pyOrNewObject(ArchiveDir, __e)
   return archivedir.fn_ArchiveDir_move(archivedir, name.encode('u8'), pyOrNewObject(ArchiveDir, to))

@ffi.callback("eC_ArchiveDir(eC_ArchiveDir, const char *, eC_FileStats *, eC_ArchiveAddMode)")
def cb_ArchiveDir_openDirectory(__e, name, stats, addMode):
   archivedir = pyOrNewObject(ArchiveDir, __e)
   return archivedir.fn_ArchiveDir_openDirectory(archivedir, name.encode('u8'), FileStats(impl = stats), ArchiveAddMode(impl = addMode))

@ffi.callback("eC_bool(eC_ArchiveDir, const char *, const char *)")
def cb_ArchiveDir_rename(__e, name, newName):
   archivedir = pyOrNewObject(ArchiveDir, __e)
   return archivedir.fn_ArchiveDir_rename(archivedir, name.encode('u8'), newName.encode('u8'))

class ArchiveDir(Instance):
   class_members = [
                      'addFromFile',
                      'addFromFileAtPosition',
                      'delete',
                      'fileExists',
                      'fileOpen',
                      'move',
                      'openDirectory',
                      'rename',
                   ]

   def init_args(self, args, kwArgs): init_args(ArchiveDir, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def add(self, name, path, addMode, compression):
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      if isinstance(path, str): path = ffi.new("char[]", path.encode('u8'))
      elif path is None: path = ffi.NULL
      ratio = ffi.new("int *")
      newPosition = ffi.new("uint *")
      r = lib.ArchiveDir_add(self.impl, name, path, addMode, compression, ratio, newPosition)
      return r, ratio[0], newPosition[0]

   def fn_unset_ArchiveDir_addFromFile(self, name, input, stats, addMode, compression, ratio, newPosition):
      if ratio is None: ratio = ffi.NULL
      if newPosition is None: newPosition = ffi.NULL
      return lib.ArchiveDir_addFromFile(self.impl, name, ffi.NULL if input is None else input.impl, ffi.NULL if stats is None else stats.impl, addMode, compression, ratio, newPosition)

   @property
   def addFromFile(self):
      if hasattr(self, 'fn_ArchiveDir_addFromFile'): return self.fn_ArchiveDir_addFromFile
      else: return self.fn_unset_ArchiveDir_addFromFile
   @addFromFile.setter
   def addFromFile(self, value):
      self.fn_ArchiveDir_addFromFile = value
      lib.Instance_setMethod(self.impl, "AddFromFile".encode('u8'), cb_ArchiveDir_addFromFile)

   def fn_unset_ArchiveDir_addFromFileAtPosition(self, position, name, input, stats, addMode, compression, ratio, newPosition):
      if ratio is None: ratio = ffi.NULL
      if newPosition is None: newPosition = ffi.NULL
      return lib.ArchiveDir_addFromFileAtPosition(self.impl, position, name, ffi.NULL if input is None else input.impl, ffi.NULL if stats is None else stats.impl, addMode, compression, ratio, newPosition)

   @property
   def addFromFileAtPosition(self):
      if hasattr(self, 'fn_ArchiveDir_addFromFileAtPosition'): return self.fn_ArchiveDir_addFromFileAtPosition
      else: return self.fn_unset_ArchiveDir_addFromFileAtPosition
   @addFromFileAtPosition.setter
   def addFromFileAtPosition(self, value):
      self.fn_ArchiveDir_addFromFileAtPosition = value
      lib.Instance_setMethod(self.impl, "AddFromFileAtPosition".encode('u8'), cb_ArchiveDir_addFromFileAtPosition)

   def fn_unset_ArchiveDir_delete(self, fileName):
      return lib.ArchiveDir_delete(self.impl, fileName)

   @property
   def delete(self):
      if hasattr(self, 'fn_ArchiveDir_delete'): return self.fn_ArchiveDir_delete
      else: return self.fn_unset_ArchiveDir_delete
   @delete.setter
   def delete(self, value):
      self.fn_ArchiveDir_delete = value
      lib.Instance_setMethod(self.impl, "Delete".encode('u8'), cb_ArchiveDir_delete)

   def fn_unset_ArchiveDir_fileExists(self, fileName):
      return lib.ArchiveDir_fileExists(self.impl, fileName)

   @property
   def fileExists(self):
      if hasattr(self, 'fn_ArchiveDir_fileExists'): return self.fn_ArchiveDir_fileExists
      else: return self.fn_unset_ArchiveDir_fileExists
   @fileExists.setter
   def fileExists(self, value):
      self.fn_ArchiveDir_fileExists = value
      lib.Instance_setMethod(self.impl, "FileExists".encode('u8'), cb_ArchiveDir_fileExists)

   def fn_unset_ArchiveDir_fileOpen(self, fileName):
      return pyOrNewObject(File, lib.ArchiveDir_fileOpen(self.impl, fileName))

   @property
   def fileOpen(self):
      if hasattr(self, 'fn_ArchiveDir_fileOpen'): return self.fn_ArchiveDir_fileOpen
      else: return self.fn_unset_ArchiveDir_fileOpen
   @fileOpen.setter
   def fileOpen(self, value):
      self.fn_ArchiveDir_fileOpen = value
      lib.Instance_setMethod(self.impl, "FileOpen".encode('u8'), cb_ArchiveDir_fileOpen)

   def fn_unset_ArchiveDir_move(self, name, to):
      return lib.ArchiveDir_move(self.impl, name, ffi.NULL if to is None else to.impl)

   @property
   def move(self):
      if hasattr(self, 'fn_ArchiveDir_move'): return self.fn_ArchiveDir_move
      else: return self.fn_unset_ArchiveDir_move
   @move.setter
   def move(self, value):
      self.fn_ArchiveDir_move = value
      lib.Instance_setMethod(self.impl, "Move".encode('u8'), cb_ArchiveDir_move)

   def fn_unset_ArchiveDir_openDirectory(self, name, stats, addMode):
      return pyOrNewObject(ArchiveDir, lib.ArchiveDir_openDirectory(self.impl, name, ffi.NULL if stats is None else stats.impl, addMode))

   @property
   def openDirectory(self):
      if hasattr(self, 'fn_ArchiveDir_openDirectory'): return self.fn_ArchiveDir_openDirectory
      else: return self.fn_unset_ArchiveDir_openDirectory
   @openDirectory.setter
   def openDirectory(self, value):
      self.fn_ArchiveDir_openDirectory = value
      lib.Instance_setMethod(self.impl, "OpenDirectory".encode('u8'), cb_ArchiveDir_openDirectory)

   def fn_unset_ArchiveDir_rename(self, name, newName):
      return lib.ArchiveDir_rename(self.impl, name, newName)

   @property
   def rename(self):
      if hasattr(self, 'fn_ArchiveDir_rename'): return self.fn_ArchiveDir_rename
      else: return self.fn_unset_ArchiveDir_rename
   @rename.setter
   def rename(self, value):
      self.fn_ArchiveDir_rename = value
      lib.Instance_setMethod(self.impl, "Rename".encode('u8'), cb_ArchiveDir_rename)

class ArchiveOpenFlags(pyBaseClass):
   def __init__(self, writeAccess = False, buffered = False, exclusive = False, waitLock = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(writeAccess, ArchiveOpenFlags):
         self.impl = writeAccess.impl
      else:
         if isinstance(writeAccess, tuple):
            __tuple = writeAccess
            writeAccess = False
            if len(__tuple) > 0: writeAccess = __tuple[0]
            if len(__tuple) > 1: buffered = __tuple[1]
            if len(__tuple) > 2: exclusive = __tuple[2]
            if len(__tuple) > 3: waitLock = __tuple[3]
         self.impl = (
            (writeAccess << lib.ARCHIVEOPENFLAGS_writeAccess_SHIFT) |
            (buffered    << lib.ARCHIVEOPENFLAGS_buffered_SHIFT)    |
            (exclusive   << lib.ARCHIVEOPENFLAGS_exclusive_SHIFT)   |
            (waitLock    << lib.ARCHIVEOPENFLAGS_waitLock_SHIFT)    )

   @property
   def writeAccess(self): return ((((self.impl)) & lib.ARCHIVEOPENFLAGS_writeAccess_MASK) >> lib.ARCHIVEOPENFLAGS_writeAccess_SHIFT)
   @writeAccess.setter
   def writeAccess(self, value): self.impl = ((self.impl) & ~(lib.ARCHIVEOPENFLAGS_writeAccess_MASK)) | (((value)) << lib.ARCHIVEOPENFLAGS_writeAccess_SHIFT)

   @property
   def buffered(self): return ((((self.impl)) & lib.ARCHIVEOPENFLAGS_buffered_MASK) >> lib.ARCHIVEOPENFLAGS_buffered_SHIFT)
   @buffered.setter
   def buffered(self, value): self.impl = ((self.impl) & ~(lib.ARCHIVEOPENFLAGS_buffered_MASK)) | (((value)) << lib.ARCHIVEOPENFLAGS_buffered_SHIFT)

   @property
   def exclusive(self): return ((((self.impl)) & lib.ARCHIVEOPENFLAGS_exclusive_MASK) >> lib.ARCHIVEOPENFLAGS_exclusive_SHIFT)
   @exclusive.setter
   def exclusive(self, value): self.impl = ((self.impl) & ~(lib.ARCHIVEOPENFLAGS_exclusive_MASK)) | (((value)) << lib.ARCHIVEOPENFLAGS_exclusive_SHIFT)

   @property
   def waitLock(self): return ((((self.impl)) & lib.ARCHIVEOPENFLAGS_waitLock_MASK) >> lib.ARCHIVEOPENFLAGS_waitLock_SHIFT)
   @waitLock.setter
   def waitLock(self, value): self.impl = ((self.impl) & ~(lib.ARCHIVEOPENFLAGS_waitLock_MASK)) | (((value)) << lib.ARCHIVEOPENFLAGS_waitLock_SHIFT)

class Box(Struct):
   def __init__(self, left = 0, top = 0, right = 0, bottom = 0, width = None, height = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Box *", impl)
      else:
         if isinstance(left, tuple):
            __tuple = left
            left = 0
            if len(__tuple) > 0: left   = __tuple[0]
            if len(__tuple) > 1: top    = __tuple[1]
            if len(__tuple) > 2: right  = __tuple[2]
            if len(__tuple) > 3: bottom = __tuple[3]
         self.impl = ffi.new("eC_Box *", { 'left' : left, 'top' : top, 'right' : right, 'bottom' : bottom })
         if width is not None:  self.width       = width
         if height is not None: self.height      = height

   @property
   def left(self): return self.impl.left
   @left.setter
   def left(self, value): self.impl.left = value

   @property
   def top(self): return self.impl.top
   @top.setter
   def top(self, value): self.impl.top = value

   @property
   def right(self): return self.impl.right
   @right.setter
   def right(self, value): self.impl.right = value

   @property
   def bottom(self): return self.impl.bottom
   @bottom.setter
   def bottom(self, value): self.impl.bottom = value

   @property
   def width(self): return lib.Box_get_width(self.impl)
   @width.setter
   def width(self, value):
      lib.Box_set_width(self.impl, value)

   @property
   def height(self): return lib.Box_get_height(self.impl)
   @height.setter
   def height(self, value):
      lib.Box_set_height(self.impl, value)

   def clip(self, against = None):
      if against is not None and not isinstance(against, Box): against = Box(against)
      against = ffi.NULL if against is None else against.impl
      lib.Box_clip(ffi.cast("eC_Box *", self.impl), ffi.cast("eC_Box *", against))

   def clipOffset(self, against, x, y):
      if against is not None and not isinstance(against, Box): against = Box(against)
      against = ffi.NULL if against is None else against.impl
      lib.Box_clipOffset(ffi.cast("eC_Box *", self.impl), ffi.cast("eC_Box *", against), x, y)

   def isPointInside(self, point = None):
      if point is not None and not isinstance(point, Point): point = Point(point)
      point = ffi.NULL if point is None else point.impl
      return lib.Box_isPointInside(ffi.cast("eC_Box *", self.impl), ffi.cast("eC_Point *", point))

   def overlap(self, box = None):
      if box is not None and not isinstance(box, Box): box = Box(box)
      box = ffi.NULL if box is None else box.impl
      return lib.Box_overlap(ffi.cast("eC_Box *", self.impl), ffi.cast("eC_Box *", box))

class BufferedFile(File):
   class_members = [
                      'handle',
                      'bufferSize',
                      'bufferRead',
                   ]

   def init_args(self, args, kwArgs): init_args(BufferedFile, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def handle(self): return pyOrNewObject(File, lib.BufferedFile_get_handle(self.impl))
   @handle.setter
   def handle(self, value):
      if not isinstance(value, File): value = File(value)
      lib.BufferedFile_set_handle(self.impl, value.impl)

   @property
   def bufferSize(self): return lib.BufferedFile_get_bufferSize(self.impl)
   @bufferSize.setter
   def bufferSize(self, value):
      lib.BufferedFile_set_bufferSize(self.impl, value)

   @property
   def bufferRead(self): return lib.BufferedFile_get_bufferRead(self.impl)
   @bufferRead.setter
   def bufferRead(self, value):
      lib.BufferedFile_set_bufferRead(self.impl, value)

class CharCategory:
   none                 = lib.CharCategory_none
   Mn                   = lib.CharCategory_Mn
   markNonSpacing       = lib.CharCategory_markNonSpacing
   Mc                   = lib.CharCategory_Mc
   markSpacing          = lib.CharCategory_markSpacing
   Me                   = lib.CharCategory_Me
   markEnclosing        = lib.CharCategory_markEnclosing
   Nd                   = lib.CharCategory_Nd
   numberDecimalDigit   = lib.CharCategory_numberDecimalDigit
   Nl                   = lib.CharCategory_Nl
   numberLetter         = lib.CharCategory_numberLetter
   No                   = lib.CharCategory_No
   numberOther          = lib.CharCategory_numberOther
   Zs                   = lib.CharCategory_Zs
   separatorSpace       = lib.CharCategory_separatorSpace
   Zl                   = lib.CharCategory_Zl
   separatorLine        = lib.CharCategory_separatorLine
   Zp                   = lib.CharCategory_Zp
   separatorParagraph   = lib.CharCategory_separatorParagraph
   Cc                   = lib.CharCategory_Cc
   otherControl         = lib.CharCategory_otherControl
   Cf                   = lib.CharCategory_Cf
   otherFormat          = lib.CharCategory_otherFormat
   Cs                   = lib.CharCategory_Cs
   otherSurrogate       = lib.CharCategory_otherSurrogate
   Co                   = lib.CharCategory_Co
   otherPrivateUse      = lib.CharCategory_otherPrivateUse
   Cn                   = lib.CharCategory_Cn
   otherNotAssigned     = lib.CharCategory_otherNotAssigned
   Lu                   = lib.CharCategory_Lu
   letterUpperCase      = lib.CharCategory_letterUpperCase
   Ll                   = lib.CharCategory_Ll
   letterLowerCase      = lib.CharCategory_letterLowerCase
   Lt                   = lib.CharCategory_Lt
   letterTitleCase      = lib.CharCategory_letterTitleCase
   Lm                   = lib.CharCategory_Lm
   letterModifier       = lib.CharCategory_letterModifier
   Lo                   = lib.CharCategory_Lo
   letterOther          = lib.CharCategory_letterOther
   Pc                   = lib.CharCategory_Pc
   punctuationConnector = lib.CharCategory_punctuationConnector
   Pd                   = lib.CharCategory_Pd
   punctuationDash      = lib.CharCategory_punctuationDash
   Ps                   = lib.CharCategory_Ps
   punctuationOpen      = lib.CharCategory_punctuationOpen
   Pe                   = lib.CharCategory_Pe
   punctuationClose     = lib.CharCategory_punctuationClose
   Pi                   = lib.CharCategory_Pi
   punctuationInitial   = lib.CharCategory_punctuationInitial
   Pf                   = lib.CharCategory_Pf
   punctuationFinal     = lib.CharCategory_punctuationFinal
   Po                   = lib.CharCategory_Po
   punctuationOther     = lib.CharCategory_punctuationOther
   Sm                   = lib.CharCategory_Sm
   symbolMath           = lib.CharCategory_symbolMath
   Sc                   = lib.CharCategory_Sc
   symbolCurrency       = lib.CharCategory_symbolCurrency
   Sk                   = lib.CharCategory_Sk
   symbolModifier       = lib.CharCategory_symbolModifier
   So                   = lib.CharCategory_So
   symbolOther          = lib.CharCategory_symbolOther

class Condition:
   def __init__(self, name = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_Condition *", lib.Instance_new(lib.class_Condition))
         if name is not None: self.name      = name
         if name is not None: self.name = name

   @property
   def name(self): value = lib.Condition_get_name(ffi.cast("struct eC_Condition *", self.impl)); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @name.setter
   def name(self, value):
      lib.Condition_set_name(ffi.cast("struct eC_Condition *", self.impl), value.encode('u8'))

   def signal(self):
      lib.Condition_signal(ffi.cast("struct eC_Condition *", self.impl))

   def wait(self, mutex = None):
      if mutex is not None and not isinstance(mutex, Mutex): mutex = Mutex(mutex)
      mutex = ffi.NULL if mutex is None else mutex.impl
      lib.Condition_wait(ffi.cast("struct eC_Condition *", self.impl), ffi.cast("struct eC_Mutex *", mutex))

class ConsoleFile(File):
   class_members = []

   def init_args(self, args, kwArgs): init_args(ConsoleFile, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class DayOfTheWeek:
   sunday    = lib.DayOfTheWeek_sunday
   monday    = lib.DayOfTheWeek_monday
   tuesday   = lib.DayOfTheWeek_tuesday
   wednesday = lib.DayOfTheWeek_wednesday
   thursday  = lib.DayOfTheWeek_thursday
   friday    = lib.DayOfTheWeek_friday
   saturday  = lib.DayOfTheWeek_saturday

class DualPipe(File):
   class_members = []

   def init_args(self, args, kwArgs): init_args(DualPipe, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def getExitCode(self):
      return lib.DualPipe_getExitCode(self.impl)

   def getLinePeek(self, s, max):
      if isinstance(s, str): s = ffi.new("char[]", s.encode('u8'))
      elif s is None: s = ffi.NULL
      charsRead = ffi.new("int *")
      r = lib.DualPipe_getLinePeek(self.impl, s, max, charsRead)
      return r, charsRead[0]

   def getProcessID(self):
      return lib.DualPipe_getProcessID(self.impl)

   def peek(self):
      return lib.DualPipe_peek(self.impl)

   def terminate(self):
      lib.DualPipe_terminate(self.impl)

   def wait(self):
      lib.DualPipe_wait(self.impl)

class ECONGlobalSettings(GlobalSettingsDriver):
   class_members = []

   def init_args(self, args, kwArgs): init_args(ECONGlobalSettings, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class ECONParser(JSONParser):
   class_members = []

   def init_args(self, args, kwArgs): init_args(ECONParser, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class ErrorLevel:
   veryFatal = lib.ErrorLevel_veryFatal
   fatal     = lib.ErrorLevel_fatal
   major     = lib.ErrorLevel_major
   minor     = lib.ErrorLevel_minor

class Feet(Distance):
   def __init__(self, value = 0, impl = None):
      if impl is not None: self.impl = impl
      elif isinstance(value, Distance): self.impl = value.impl
      else: self.value = value

   # conv eC_Distance <-> eC_Meters
   @property
   def value(self): return self.impl * 3.28083985446533
   @value.setter
   def value(self, value): self.impl = value * 0.304800003767014

Feet.buc = Distance

class FileAttribs(Bool):
   def __init__(self, isFile = False, isArchive = False, isHidden = False, isReadOnly = False, isSystem = False, isTemporary = False, isDirectory = False, isDrive = False, isCDROM = False, isRemote = False, isRemovable = False, isServer = False, isShare = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(isFile, FileAttribs):
         self.impl = isFile.impl
      else:
         self.impl = (
            (isFile      << lib.FILEATTRIBS_isFile_SHIFT)      |
            (isArchive   << lib.FILEATTRIBS_isArchive_SHIFT)   |
            (isHidden    << lib.FILEATTRIBS_isHidden_SHIFT)    |
            (isReadOnly  << lib.FILEATTRIBS_isReadOnly_SHIFT)  |
            (isSystem    << lib.FILEATTRIBS_isSystem_SHIFT)    |
            (isTemporary << lib.FILEATTRIBS_isTemporary_SHIFT) |
            (isDirectory << lib.FILEATTRIBS_isDirectory_SHIFT) |
            (isDrive     << lib.FILEATTRIBS_isDrive_SHIFT)     |
            (isCDROM     << lib.FILEATTRIBS_isCDROM_SHIFT)     |
            (isRemote    << lib.FILEATTRIBS_isRemote_SHIFT)    |
            (isRemovable << lib.FILEATTRIBS_isRemovable_SHIFT) |
            (isServer    << lib.FILEATTRIBS_isServer_SHIFT)    |
            (isShare     << lib.FILEATTRIBS_isShare_SHIFT)     )

   @property
   def isFile(self): return ((((self.impl)) & lib.FILEATTRIBS_isFile_MASK) >> lib.FILEATTRIBS_isFile_SHIFT)
   @isFile.setter
   def isFile(self, value): self.impl = ((self.impl) & ~(lib.FILEATTRIBS_isFile_MASK)) | (((value)) << lib.FILEATTRIBS_isFile_SHIFT)

   @property
   def isArchive(self): return ((((self.impl)) & lib.FILEATTRIBS_isArchive_MASK) >> lib.FILEATTRIBS_isArchive_SHIFT)
   @isArchive.setter
   def isArchive(self, value): self.impl = ((self.impl) & ~(lib.FILEATTRIBS_isArchive_MASK)) | (((value)) << lib.FILEATTRIBS_isArchive_SHIFT)

   @property
   def isHidden(self): return ((((self.impl)) & lib.FILEATTRIBS_isHidden_MASK) >> lib.FILEATTRIBS_isHidden_SHIFT)
   @isHidden.setter
   def isHidden(self, value): self.impl = ((self.impl) & ~(lib.FILEATTRIBS_isHidden_MASK)) | (((value)) << lib.FILEATTRIBS_isHidden_SHIFT)

   @property
   def isReadOnly(self): return ((((self.impl)) & lib.FILEATTRIBS_isReadOnly_MASK) >> lib.FILEATTRIBS_isReadOnly_SHIFT)
   @isReadOnly.setter
   def isReadOnly(self, value): self.impl = ((self.impl) & ~(lib.FILEATTRIBS_isReadOnly_MASK)) | (((value)) << lib.FILEATTRIBS_isReadOnly_SHIFT)

   @property
   def isSystem(self): return ((((self.impl)) & lib.FILEATTRIBS_isSystem_MASK) >> lib.FILEATTRIBS_isSystem_SHIFT)
   @isSystem.setter
   def isSystem(self, value): self.impl = ((self.impl) & ~(lib.FILEATTRIBS_isSystem_MASK)) | (((value)) << lib.FILEATTRIBS_isSystem_SHIFT)

   @property
   def isTemporary(self): return ((((self.impl)) & lib.FILEATTRIBS_isTemporary_MASK) >> lib.FILEATTRIBS_isTemporary_SHIFT)
   @isTemporary.setter
   def isTemporary(self, value): self.impl = ((self.impl) & ~(lib.FILEATTRIBS_isTemporary_MASK)) | (((value)) << lib.FILEATTRIBS_isTemporary_SHIFT)

   @property
   def isDirectory(self): return ((((self.impl)) & lib.FILEATTRIBS_isDirectory_MASK) >> lib.FILEATTRIBS_isDirectory_SHIFT)
   @isDirectory.setter
   def isDirectory(self, value): self.impl = ((self.impl) & ~(lib.FILEATTRIBS_isDirectory_MASK)) | (((value)) << lib.FILEATTRIBS_isDirectory_SHIFT)

   @property
   def isDrive(self): return ((((self.impl)) & lib.FILEATTRIBS_isDrive_MASK) >> lib.FILEATTRIBS_isDrive_SHIFT)
   @isDrive.setter
   def isDrive(self, value): self.impl = ((self.impl) & ~(lib.FILEATTRIBS_isDrive_MASK)) | (((value)) << lib.FILEATTRIBS_isDrive_SHIFT)

   @property
   def isCDROM(self): return ((((self.impl)) & lib.FILEATTRIBS_isCDROM_MASK) >> lib.FILEATTRIBS_isCDROM_SHIFT)
   @isCDROM.setter
   def isCDROM(self, value): self.impl = ((self.impl) & ~(lib.FILEATTRIBS_isCDROM_MASK)) | (((value)) << lib.FILEATTRIBS_isCDROM_SHIFT)

   @property
   def isRemote(self): return ((((self.impl)) & lib.FILEATTRIBS_isRemote_MASK) >> lib.FILEATTRIBS_isRemote_SHIFT)
   @isRemote.setter
   def isRemote(self, value): self.impl = ((self.impl) & ~(lib.FILEATTRIBS_isRemote_MASK)) | (((value)) << lib.FILEATTRIBS_isRemote_SHIFT)

   @property
   def isRemovable(self): return ((((self.impl)) & lib.FILEATTRIBS_isRemovable_MASK) >> lib.FILEATTRIBS_isRemovable_SHIFT)
   @isRemovable.setter
   def isRemovable(self, value): self.impl = ((self.impl) & ~(lib.FILEATTRIBS_isRemovable_MASK)) | (((value)) << lib.FILEATTRIBS_isRemovable_SHIFT)

   @property
   def isServer(self): return ((((self.impl)) & lib.FILEATTRIBS_isServer_MASK) >> lib.FILEATTRIBS_isServer_SHIFT)
   @isServer.setter
   def isServer(self, value): self.impl = ((self.impl) & ~(lib.FILEATTRIBS_isServer_MASK)) | (((value)) << lib.FILEATTRIBS_isServer_SHIFT)

   @property
   def isShare(self): return ((((self.impl)) & lib.FILEATTRIBS_isShare_MASK) >> lib.FILEATTRIBS_isShare_SHIFT)
   @isShare.setter
   def isShare(self, value): self.impl = ((self.impl) & ~(lib.FILEATTRIBS_isShare_MASK)) | (((value)) << lib.FILEATTRIBS_isShare_SHIFT)

class FileListing(Struct):
   def __init__(self, directory = None, extensions = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_FileListing *", impl)
      else:
         if isinstance(directory, tuple):
            __tuple = directory
            directory = None
            if len(__tuple) > 0: directory  = __tuple[0]
            if len(__tuple) > 1: extensions = __tuple[1]
         self.impl = ffi.new("eC_FileListing *", { 'directory' : directory, 'extensions' : extensions })

   @property
   def directory(self): return self.impl.directory
   @directory.setter
   def directory(self, value):
      if isinstance(value, str): value = ffi.new("char[]", value.encode('u8'))
      elif value is None: value = ffi.NULL
      self.impl.directory = value

   @property
   def extensions(self): return self.impl.extensions
   @extensions.setter
   def extensions(self, value):
      if isinstance(value, str): value = ffi.new("char[]", value.encode('u8'))
      elif value is None: value = ffi.NULL
      self.impl.extensions = value

   @property
   def name(self): value = lib.FileListing_get_name(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')

   @property
   def path(self): value = lib.FileListing_get_path(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')

   @property
   def stats(self): value = FileStats(); lib.FileListing_get_stats(self.impl, ffi.cast("eC_FileStats *", value.impl)); return value

   def find(self):
      return lib.FileListing_find(ffi.cast("eC_FileListing *", self.impl))

   def stop(self):
      lib.FileListing_stop(ffi.cast("eC_FileListing *", self.impl))

class FileLock:
   unlocked  = lib.FileLock_unlocked
   shared    = lib.FileLock_shared
   exclusive = lib.FileLock_exclusive

@ffi.callback("eC_bool(eC_FileMonitor, eC_FileChange, const char *, const char *)")
def cb_FileMonitor_onDirNotify(__e, action, fileName, param):
   filemonitor = pyOrNewObject(FileMonitor, __e)
   return filemonitor.fn_FileMonitor_onDirNotify(filemonitor.userData, action, fileName.encode('u8'), param.encode('u8'))

@ffi.callback("eC_bool(eC_FileMonitor, eC_FileChange, const char *)")
def cb_FileMonitor_onFileNotify(__e, action, param):
   filemonitor = pyOrNewObject(FileMonitor, __e)
   return filemonitor.fn_FileMonitor_onFileNotify(filemonitor.userData, action, param.encode('u8'))

class FileMonitor(Instance):
   class_members = [
                      'userData',
                      'fileChange',
                      'fileName',
                      'directoryName',
                      'onDirNotify',
                      'onFileNotify',
                   ]

   def init_args(self, args, kwArgs): init_args(FileMonitor, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)
      if self.impl != ffi.NULL: lib.FileMonitor_set_userData(self.impl, self.impl)

   userData = None

   @property
   def fileChange(self): return None
   @fileChange.setter
   def fileChange(self, value):
      if not isinstance(value, FileChange): value = FileChange(value)
      lib.FileMonitor_set_fileChange(self.impl, value.impl)

   @property
   def fileName(self): value = lib.FileMonitor_get_fileName(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @fileName.setter
   def fileName(self, value):
      lib.FileMonitor_set_fileName(self.impl, value.encode('u8'))

   @property
   def directoryName(self): value = lib.FileMonitor_get_directoryName(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @directoryName.setter
   def directoryName(self, value):
      lib.FileMonitor_set_directoryName(self.impl, value.encode('u8'))

   def fn_unset_FileMonitor_onDirNotify(self, _ec_instance, action, fileName, param):
      return lib.FileMonitor_onDirNotify(self.impl, _ec_instance.impl, action, fileName, param)

   @property
   def onDirNotify(self):
      if hasattr(self, 'fn_FileMonitor_onDirNotify'): return self.fn_FileMonitor_onDirNotify
      else: return self.fn_unset_FileMonitor_onDirNotify
   @onDirNotify.setter
   def onDirNotify(self, value):
      self.fn_FileMonitor_onDirNotify = value
      lib.Instance_setMethod(self.impl, "OnDirNotify".encode('u8'), cb_FileMonitor_onDirNotify)

   def fn_unset_FileMonitor_onFileNotify(self, _ec_instance, action, param):
      return lib.FileMonitor_onFileNotify(self.impl, _ec_instance.impl, action, param)

   @property
   def onFileNotify(self):
      if hasattr(self, 'fn_FileMonitor_onFileNotify'): return self.fn_FileMonitor_onFileNotify
      else: return self.fn_unset_FileMonitor_onFileNotify
   @onFileNotify.setter
   def onFileNotify(self, value):
      self.fn_FileMonitor_onFileNotify = value
      lib.Instance_setMethod(self.impl, "OnFileNotify".encode('u8'), cb_FileMonitor_onFileNotify)

   def startMonitoring(self):
      lib.FileMonitor_startMonitoring(self.impl)

   def stopMonitoring(self):
      lib.FileMonitor_stopMonitoring(self.impl)

class FileOpenMode:
   read       = lib.FileOpenMode_read
   write      = lib.FileOpenMode_write
   append     = lib.FileOpenMode_append
   readWrite  = lib.FileOpenMode_readWrite
   writeRead  = lib.FileOpenMode_writeRead
   appendRead = lib.FileOpenMode_appendRead

class FileSeekMode:
   start   = lib.FileSeekMode_start
   current = lib.FileSeekMode_current
   end     = lib.FileSeekMode_end

class FileSize(pyBaseClass):
   def __init__(self, impl = 0):
      self.impl = impl

FileSize.buc = FileSize

class FileSize64(pyBaseClass):
   def __init__(self, impl = 0):
      self.impl = impl

FileSize64.buc = FileSize64

class FileStats(Struct):
   def __init__(self, attribs = None, size = 0, accessed = 0, modified = 0, created = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_FileStats *", impl)
      else:
         if isinstance(attribs, tuple):
            __tuple = attribs
            attribs = 0
            if len(__tuple) > 0: attribs  = __tuple[0]
            if len(__tuple) > 1: size     = __tuple[1]
            if len(__tuple) > 2: accessed = __tuple[2]
            if len(__tuple) > 3: modified = __tuple[3]
         if attribs is not None:
            if not isinstance(attribs, FileAttribs): attribs = FileAttribs(attribs)
            attribs = attribs.impl
         else:
            attribs = FileAttribs()
         if accessed is not None:
            if not isinstance(accessed, SecSince1970): accessed = SecSince1970(accessed)
            accessed = accessed.impl
         else:
            accessed = SecSince1970()
         if modified is not None:
            if not isinstance(modified, SecSince1970): modified = SecSince1970(modified)
            modified = modified.impl
         else:
            modified = SecSince1970()
         if created is not None:
            if not isinstance(created, SecSince1970): created = SecSince1970(created)
            created = created.impl
         else:
            created = SecSince1970()
         self.impl = ffi.new("eC_FileStats *", {
                                'attribs' : attribs,
                                'size' : size,
                                'accessed' : accessed,
                                'modified' : modified,
                                'created' : created
                             })

   @property
   def attribs(self): return FileAttribs(impl = self.impl.attribs)
   @attribs.setter
   def attribs(self, value):
      if not isinstance(value, FileAttribs): value = FileAttribs(value)
      self.impl.attribs = value.impl

   @property
   def size(self): return self.impl.size
   @size.setter
   def size(self, value): self.impl.size = value

   @property
   def accessed(self): return SecSince1970(impl = self.impl.accessed)
   @accessed.setter
   def accessed(self, value):
      if not isinstance(value, SecSince1970): value = SecSince1970(value)
      self.impl.accessed = value.impl

   @property
   def modified(self): return SecSince1970(impl = self.impl.modified)
   @modified.setter
   def modified(self, value):
      if not isinstance(value, SecSince1970): value = SecSince1970(value)
      self.impl.modified = value.impl

   @property
   def created(self): return SecSince1970(impl = self.impl.created)
   @created.setter
   def created(self, value):
      if not isinstance(value, SecSince1970): value = SecSince1970(value)
      self.impl.created = value.impl

class GlobalAppSettings(GlobalSettings):
   class_members = []

   def init_args(self, args, kwArgs): init_args(GlobalAppSettings, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def getGlobalValue(self, section, name, type, value):
      if isinstance(section, str): section = ffi.new("char[]", section.encode('u8'))
      elif section is None: section = ffi.NULL
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      if hasattr(value, 'impl'): value = value.impl
      if value is None: value = ffi.NULL
      return lib.GlobalAppSettings_getGlobalValue(self.impl, section, name, type, value)

   def putGlobalValue(self, section, name, type, value):
      if isinstance(section, str): section = ffi.new("char[]", section.encode('u8'))
      elif section is None: section = ffi.NULL
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      if hasattr(value, 'impl'): value = value.impl
      if value is None: value = ffi.NULL
      return lib.GlobalAppSettings_putGlobalValue(self.impl, section, name, type, value)

class GlobalSettingType:
   integer      = lib.GlobalSettingType_integer
   singleString = lib.GlobalSettingType_singleString
   stringList   = lib.GlobalSettingType_stringList

class GlobalSettingsData(Instance):
   class_members = []

   def init_args(self, args, kwArgs): init_args(GlobalSettingsData, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class GuiErrorCode(ErrorCode):
   driverNotSupported    = ErrorCode(impl = lib.GuiErrorCode_driverNotSupported)
   windowCreationFailed  = ErrorCode(impl = lib.GuiErrorCode_windowCreationFailed)
   graphicsLoadingFailed = ErrorCode(impl = lib.GuiErrorCode_graphicsLoadingFailed)
   modeSwitchFailed      = ErrorCode(impl = lib.GuiErrorCode_modeSwitchFailed)

class JSONFirstLetterCapitalization:
   keepCase  = lib.JSONFirstLetterCapitalization_keepCase
   upperCase = lib.JSONFirstLetterCapitalization_upperCase
   lowerCase = lib.JSONFirstLetterCapitalization_lowerCase

class JSONGlobalSettings(GlobalSettingsDriver):
   class_members = []

   def init_args(self, args, kwArgs): init_args(JSONGlobalSettings, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class JSONResult:
   syntaxError  = lib.JSONResult_syntaxError
   success      = lib.JSONResult_success
   typeMismatch = lib.JSONResult_typeMismatch
   noItem       = lib.JSONResult_noItem

class JSONTypeOptions(pyBaseClass):
   def __init__(self, numbersUseOGDFS = False, boolUseOGDFS = False, nullUseOGDFS = False, stringUseOGDFS = False, arrayUseOGDFS = False, objectUseOGDFS = False, stripQuotesForOGDFS = False, strictOGDFS = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(numbersUseOGDFS, JSONTypeOptions):
         self.impl = numbersUseOGDFS.impl
      else:
         self.impl = (
            (numbersUseOGDFS     << lib.JSONTYPEOPTIONS_numbersUseOGDFS_SHIFT)     |
            (boolUseOGDFS        << lib.JSONTYPEOPTIONS_boolUseOGDFS_SHIFT)        |
            (nullUseOGDFS        << lib.JSONTYPEOPTIONS_nullUseOGDFS_SHIFT)        |
            (stringUseOGDFS      << lib.JSONTYPEOPTIONS_stringUseOGDFS_SHIFT)      |
            (arrayUseOGDFS       << lib.JSONTYPEOPTIONS_arrayUseOGDFS_SHIFT)       |
            (objectUseOGDFS      << lib.JSONTYPEOPTIONS_objectUseOGDFS_SHIFT)      |
            (stripQuotesForOGDFS << lib.JSONTYPEOPTIONS_stripQuotesForOGDFS_SHIFT) |
            (strictOGDFS         << lib.JSONTYPEOPTIONS_strictOGDFS_SHIFT)         )

   @property
   def numbersUseOGDFS(self): return ((((self.impl)) & lib.JSONTYPEOPTIONS_numbersUseOGDFS_MASK) >> lib.JSONTYPEOPTIONS_numbersUseOGDFS_SHIFT)
   @numbersUseOGDFS.setter
   def numbersUseOGDFS(self, value): self.impl = ((self.impl) & ~(lib.JSONTYPEOPTIONS_numbersUseOGDFS_MASK)) | (((value)) << lib.JSONTYPEOPTIONS_numbersUseOGDFS_SHIFT)

   @property
   def boolUseOGDFS(self): return ((((self.impl)) & lib.JSONTYPEOPTIONS_boolUseOGDFS_MASK) >> lib.JSONTYPEOPTIONS_boolUseOGDFS_SHIFT)
   @boolUseOGDFS.setter
   def boolUseOGDFS(self, value): self.impl = ((self.impl) & ~(lib.JSONTYPEOPTIONS_boolUseOGDFS_MASK)) | (((value)) << lib.JSONTYPEOPTIONS_boolUseOGDFS_SHIFT)

   @property
   def nullUseOGDFS(self): return ((((self.impl)) & lib.JSONTYPEOPTIONS_nullUseOGDFS_MASK) >> lib.JSONTYPEOPTIONS_nullUseOGDFS_SHIFT)
   @nullUseOGDFS.setter
   def nullUseOGDFS(self, value): self.impl = ((self.impl) & ~(lib.JSONTYPEOPTIONS_nullUseOGDFS_MASK)) | (((value)) << lib.JSONTYPEOPTIONS_nullUseOGDFS_SHIFT)

   @property
   def stringUseOGDFS(self): return ((((self.impl)) & lib.JSONTYPEOPTIONS_stringUseOGDFS_MASK) >> lib.JSONTYPEOPTIONS_stringUseOGDFS_SHIFT)
   @stringUseOGDFS.setter
   def stringUseOGDFS(self, value): self.impl = ((self.impl) & ~(lib.JSONTYPEOPTIONS_stringUseOGDFS_MASK)) | (((value)) << lib.JSONTYPEOPTIONS_stringUseOGDFS_SHIFT)

   @property
   def arrayUseOGDFS(self): return ((((self.impl)) & lib.JSONTYPEOPTIONS_arrayUseOGDFS_MASK) >> lib.JSONTYPEOPTIONS_arrayUseOGDFS_SHIFT)
   @arrayUseOGDFS.setter
   def arrayUseOGDFS(self, value): self.impl = ((self.impl) & ~(lib.JSONTYPEOPTIONS_arrayUseOGDFS_MASK)) | (((value)) << lib.JSONTYPEOPTIONS_arrayUseOGDFS_SHIFT)

   @property
   def objectUseOGDFS(self): return ((((self.impl)) & lib.JSONTYPEOPTIONS_objectUseOGDFS_MASK) >> lib.JSONTYPEOPTIONS_objectUseOGDFS_SHIFT)
   @objectUseOGDFS.setter
   def objectUseOGDFS(self, value): self.impl = ((self.impl) & ~(lib.JSONTYPEOPTIONS_objectUseOGDFS_MASK)) | (((value)) << lib.JSONTYPEOPTIONS_objectUseOGDFS_SHIFT)

   @property
   def stripQuotesForOGDFS(self): return ((((self.impl)) & lib.JSONTYPEOPTIONS_stripQuotesForOGDFS_MASK) >> lib.JSONTYPEOPTIONS_stripQuotesForOGDFS_SHIFT)
   @stripQuotesForOGDFS.setter
   def stripQuotesForOGDFS(self, value): self.impl = ((self.impl) & ~(lib.JSONTYPEOPTIONS_stripQuotesForOGDFS_MASK)) | (((value)) << lib.JSONTYPEOPTIONS_stripQuotesForOGDFS_SHIFT)

   @property
   def strictOGDFS(self): return ((((self.impl)) & lib.JSONTYPEOPTIONS_strictOGDFS_MASK) >> lib.JSONTYPEOPTIONS_strictOGDFS_SHIFT)
   @strictOGDFS.setter
   def strictOGDFS(self, value): self.impl = ((self.impl) & ~(lib.JSONTYPEOPTIONS_strictOGDFS_MASK)) | (((value)) << lib.JSONTYPEOPTIONS_strictOGDFS_SHIFT)

class LoggingMode:
   noLogging = lib.LoggingMode_noLogging
   stdOut    = lib.LoggingMode_stdOut
   stdErr    = lib.LoggingMode_stdErr
   debug     = lib.LoggingMode_debug
   logFile   = lib.LoggingMode_logFile
   msgBox    = lib.LoggingMode_msgBox
   buffer    = lib.LoggingMode_buffer

class Month:
   january   = lib.Month_january
   february  = lib.Month_february
   march     = lib.Month_march
   april     = lib.Month_april
   may       = lib.Month_may
   june      = lib.Month_june
   july      = lib.Month_july
   august    = lib.Month_august
   september = lib.Month_september
   october   = lib.Month_october
   november  = lib.Month_november
   december  = lib.Month_december

   def getNumDays(self, year):
      return lib.Month_getNumDays(self.impl, year)

class MoveFileOptions(pyBaseClass):
   def __init__(self, overwrite = False, sync = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(overwrite, MoveFileOptions):
         self.impl = overwrite.impl
      else:
         if isinstance(overwrite, tuple):
            __tuple = overwrite
            overwrite = False
            if len(__tuple) > 0: overwrite = __tuple[0]
            if len(__tuple) > 1: sync = __tuple[1]
         self.impl = (
            (overwrite << lib.MOVEFILEOPTIONS_overwrite_SHIFT) |
            (sync      << lib.MOVEFILEOPTIONS_sync_SHIFT)      )

   @property
   def overwrite(self): return ((((self.impl)) & lib.MOVEFILEOPTIONS_overwrite_MASK) >> lib.MOVEFILEOPTIONS_overwrite_SHIFT)
   @overwrite.setter
   def overwrite(self, value): self.impl = ((self.impl) & ~(lib.MOVEFILEOPTIONS_overwrite_MASK)) | (((value)) << lib.MOVEFILEOPTIONS_overwrite_SHIFT)

   @property
   def sync(self): return ((((self.impl)) & lib.MOVEFILEOPTIONS_sync_MASK) >> lib.MOVEFILEOPTIONS_sync_SHIFT)
   @sync.setter
   def sync(self, value): self.impl = ((self.impl) & ~(lib.MOVEFILEOPTIONS_sync_MASK)) | (((value)) << lib.MOVEFILEOPTIONS_sync_SHIFT)

class OptionsMap(Map):
   class_members = []

   def init_args(self, args, kwArgs): init_args(OptionsMap, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      kwArgs['templateParams'] = "<String, JSONTypeOptions>"
      self.init_args(list(args), kwArgs)

class PipeOpenMode(pyBaseClass):
   def __init__(self, output = False, error = False, input = False, showWindow = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(output, PipeOpenMode):
         self.impl = output.impl
      else:
         if isinstance(output, tuple):
            __tuple = output
            output = False
            if len(__tuple) > 0: output = __tuple[0]
            if len(__tuple) > 1: error = __tuple[1]
            if len(__tuple) > 2: input = __tuple[2]
            if len(__tuple) > 3: showWindow = __tuple[3]
         self.impl = (
            (output     << lib.PIPEOPENMODE_output_SHIFT)     |
            (error      << lib.PIPEOPENMODE_error_SHIFT)      |
            (input      << lib.PIPEOPENMODE_input_SHIFT)      |
            (showWindow << lib.PIPEOPENMODE_showWindow_SHIFT) )

   @property
   def output(self): return ((((self.impl)) & lib.PIPEOPENMODE_output_MASK) >> lib.PIPEOPENMODE_output_SHIFT)
   @output.setter
   def output(self, value): self.impl = ((self.impl) & ~(lib.PIPEOPENMODE_output_MASK)) | (((value)) << lib.PIPEOPENMODE_output_SHIFT)

   @property
   def error(self): return ((((self.impl)) & lib.PIPEOPENMODE_error_MASK) >> lib.PIPEOPENMODE_error_SHIFT)
   @error.setter
   def error(self, value): self.impl = ((self.impl) & ~(lib.PIPEOPENMODE_error_MASK)) | (((value)) << lib.PIPEOPENMODE_error_SHIFT)

   @property
   def input(self): return ((((self.impl)) & lib.PIPEOPENMODE_input_MASK) >> lib.PIPEOPENMODE_input_SHIFT)
   @input.setter
   def input(self, value): self.impl = ((self.impl) & ~(lib.PIPEOPENMODE_input_MASK)) | (((value)) << lib.PIPEOPENMODE_input_SHIFT)

   @property
   def showWindow(self): return ((((self.impl)) & lib.PIPEOPENMODE_showWindow_MASK) >> lib.PIPEOPENMODE_showWindow_SHIFT)
   @showWindow.setter
   def showWindow(self, value): self.impl = ((self.impl) & ~(lib.PIPEOPENMODE_showWindow_MASK)) | (((value)) << lib.PIPEOPENMODE_showWindow_SHIFT)

class Point(Struct):
   def __init__(self, x = 0, y = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Point *", impl)
      else:
         if isinstance(x, tuple):
            __tuple = x
            x = 0
            if len(__tuple) > 0: x = __tuple[0]
            if len(__tuple) > 1: y = __tuple[1]
         self.impl = ffi.new("eC_Point *", { 'x' : x, 'y' : y })

   @property
   def x(self): return self.impl.x
   @x.setter
   def x(self, value): self.impl.x = value

   @property
   def y(self): return self.impl.y
   @y.setter
   def y(self, value): self.impl.y = value

class Pointd(Struct):
   def __init__(self, x = 0.0, y = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Pointd *", impl)
      else:
         if isinstance(x, tuple):
            __tuple = x
            x = 0.0
            if len(__tuple) > 0: x = __tuple[0]
            if len(__tuple) > 1: y = __tuple[1]
         self.impl = ffi.new("eC_Pointd *", { 'x' : x, 'y' : y })

   @property
   def x(self): return self.impl.x
   @x.setter
   def x(self, value): self.impl.x = value

   @property
   def y(self): return self.impl.y
   @y.setter
   def y(self, value): self.impl.y = value

class Pointf(Struct):
   def __init__(self, x = 0.0, y = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Pointf *", impl)
      else:
         if isinstance(x, tuple):
            __tuple = x
            x = 0.0
            if len(__tuple) > 0: x = __tuple[0]
            if len(__tuple) > 1: y = __tuple[1]
         self.impl = ffi.new("eC_Pointf *", { 'x' : x, 'y' : y })

   @property
   def x(self): return self.impl.x
   @x.setter
   def x(self, value): self.impl.x = value

   @property
   def y(self): return self.impl.y
   @y.setter
   def y(self, value): self.impl.y = value

class PredefinedCharCategories(CharCategories):
   none        = CharCategories(impl = lib.PredefinedCharCategories_none)
   marks       = CharCategories(impl = lib.PredefinedCharCategories_marks)
   numbers     = CharCategories(impl = lib.PredefinedCharCategories_numbers)
   separators  = CharCategories(impl = lib.PredefinedCharCategories_separators)
   others      = CharCategories(impl = lib.PredefinedCharCategories_others)
   letters     = CharCategories(impl = lib.PredefinedCharCategories_letters)
   punctuation = CharCategories(impl = lib.PredefinedCharCategories_punctuation)
   symbols     = CharCategories(impl = lib.PredefinedCharCategories_symbols)
   connector   = CharCategories(impl = lib.PredefinedCharCategories_connector)

class RepButton(Button):
   class_members = [
                      'pressing',
                      'delay',
                      'delay0',
                      'timer',
                      'timer2',
                   ]

   def init_args(self, args, kwArgs): init_args(RepButton, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def pressing(self): return IPTR(lib, ffi, self, RepButton).pressing
   @pressing.setter
   def pressing(self, value): IPTR(lib, ffi, self, RepButton).pressing = value

   @property
   def delay(self): return None
   @delay.setter
   def delay(self, value):
      if not isinstance(value, Time): value = Seconds(value)
      lib.RepButton_set_delay(self.impl, value.impl)

   @property
   def delay0(self): return None
   @delay0.setter
   def delay0(self, value):
      if not isinstance(value, Time): value = Seconds(value)
      lib.RepButton_set_delay0(self.impl, value.impl)

   @property
   def timer(self): return pyOrNewObject(Timer, IPTR(lib, ffi, self, RepButton).timer)
   @timer.setter
   def timer(self, value):
      if not isinstance(value, Timer): value = Timer(value)
      IPTR(lib, ffi, self, RepButton).timer = value.impl

   @property
   def timer2(self): return pyOrNewObject(Timer, IPTR(lib, ffi, self, RepButton).timer2)
   @timer2.setter
   def timer2(self, value):
      if not isinstance(value, Timer): value = Timer(value)
      IPTR(lib, ffi, self, RepButton).timer2 = value.impl

class Semaphore:
   def __init__(self, initCount = None, maxCount = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_Semaphore *", lib.Instance_new(lib.class_Semaphore))
         if isinstance(initCount, tuple):
            __tuple = initCount
            initCount = 0
            if len(__tuple) > 0: initCount = __tuple[0]
            if len(__tuple) > 1: maxCount  = __tuple[1]
         if initCount is not None: self.initCount      = initCount
         if maxCount is not None:  self.maxCount       = maxCount
         if initCount is not None: self.initCount = initCount
         if maxCount is not None:  self.maxCount  = maxCount

   @property
   def initCount(self): return lib.Semaphore_get_initCount(ffi.cast("struct eC_Semaphore *", self.impl))
   @initCount.setter
   def initCount(self, value):
      lib.Semaphore_set_initCount(ffi.cast("struct eC_Semaphore *", self.impl), value)

   @property
   def maxCount(self): return lib.Semaphore_get_maxCount(ffi.cast("struct eC_Semaphore *", self.impl))
   @maxCount.setter
   def maxCount(self, value):
      lib.Semaphore_set_maxCount(ffi.cast("struct eC_Semaphore *", self.impl), value)

   def release(self):
      lib.Semaphore_release(ffi.cast("struct eC_Semaphore *", self.impl))

   def tryWait(self):
      return lib.Semaphore_tryWait(ffi.cast("struct eC_Semaphore *", self.impl))

   def wait(self):
      lib.Semaphore_wait(ffi.cast("struct eC_Semaphore *", self.impl))

class SetBool:
   unset = lib.SetBool_unset
   false = lib.SetBool_false
   true  = lib.SetBool_true

class SettingsIOResult:
   error                       = lib.SettingsIOResult_error
   success                     = lib.SettingsIOResult_success
   fileNotFound                = lib.SettingsIOResult_fileNotFound
   fileNotCompatibleWithDriver = lib.SettingsIOResult_fileNotCompatibleWithDriver

class Size(Struct):
   def __init__(self, w = 0, h = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Size *", impl)
      else:
         if isinstance(w, tuple):
            __tuple = w
            w = 0
            if len(__tuple) > 0: w = __tuple[0]
            if len(__tuple) > 1: h = __tuple[1]
         if w is not None:
            if not isinstance(w, MinMaxValue): w = MinMaxValue(w)
            w = w.impl
         else:
            w = MinMaxValue()
         if h is not None:
            if not isinstance(h, MinMaxValue): h = MinMaxValue(h)
            h = h.impl
         else:
            h = MinMaxValue()
         self.impl = ffi.new("eC_Size *", { 'w' : w, 'h' : h })

   @property
   def w(self): return MinMaxValue(impl = self.impl.w)
   @w.setter
   def w(self, value):
      if not isinstance(value, MinMaxValue): value = MinMaxValue(value)
      self.impl.w = value.impl

   @property
   def h(self): return MinMaxValue(impl = self.impl.h)
   @h.setter
   def h(self, value):
      if not isinstance(value, MinMaxValue): value = MinMaxValue(value)
      self.impl.h = value.impl

class SysErrorCode(ErrorCode):
   allocationFailed = ErrorCode(impl = lib.SysErrorCode_allocationFailed)
   nameInexistant   = ErrorCode(impl = lib.SysErrorCode_nameInexistant)
   nameExists       = ErrorCode(impl = lib.SysErrorCode_nameExists)
   missingLibrary   = ErrorCode(impl = lib.SysErrorCode_missingLibrary)
   fileNotFound     = ErrorCode(impl = lib.SysErrorCode_fileNotFound)
   writeFailed      = ErrorCode(impl = lib.SysErrorCode_writeFailed)

class TempFile(File):
   class_members = [
                      'openMode',
                      'buffer',
                      'size',
                      'allocated',
                   ]

   def init_args(self, args, kwArgs): init_args(TempFile, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def openMode(self): return lib.TempFile_get_openMode(self.impl)
   @openMode.setter
   def openMode(self, value):
      lib.TempFile_set_openMode(self.impl, value)

   @property
   def buffer(self): return lib.TempFile_get_buffer(self.impl)
   @buffer.setter
   def buffer(self, value):
      lib.TempFile_set_buffer(self.impl, value)

   @property
   def size(self): return lib.TempFile_get_size(self.impl)
   @size.setter
   def size(self, value):
      lib.TempFile_set_size(self.impl, value)

   @property
   def allocated(self): return lib.TempFile_get_allocated(self.impl)
   @allocated.setter
   def allocated(self, value):
      lib.TempFile_set_allocated(self.impl, value)

   def stealBuffer(self):
      return lib.TempFile_stealBuffer(self.impl)

@ffi.callback("uint(eC_Thread)")
def cb_Thread_main(__e):
   thread = pyOrNewObject(Thread, __e)
   return thread.fn_Thread_main(thread)

class Thread(Instance):
   class_members = [
                      'created',
                      'main',
                   ]

   def init_args(self, args, kwArgs): init_args(Thread, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def created(self): return lib.Thread_get_created(self.impl)

   def create(self):
      lib.Thread_create(self.impl)

   def kill(self):
      lib.Thread_kill(self.impl)

   def fn_unset_Thread_main(self):
      return lib.Thread_main(self.impl)

   @property
   def main(self):
      if hasattr(self, 'fn_Thread_main'): return self.fn_Thread_main
      else: return self.fn_unset_Thread_main
   @main.setter
   def main(self, value):
      self.fn_Thread_main = value
      lib.Instance_setMethod(self.impl, "Main".encode('u8'), cb_Thread_main)

   def setPriority(self, priority):
      lib.Thread_setPriority(self.impl, priority)

   def wait(self):
      lib.Thread_wait(self.impl)

class ThreadPriority:
   normal       = lib.ThreadPriority_normal
   aboveNormal  = lib.ThreadPriority_aboveNormal
   belowNormal  = lib.ThreadPriority_belowNormal
   highest      = lib.ThreadPriority_highest
   lowest       = lib.ThreadPriority_lowest
   idle         = lib.ThreadPriority_idle
   timeCritical = lib.ThreadPriority_timeCritical

class TimeStamp(SecSince1970):
   def __init__(self, value = 0, impl = None):
      if impl is not None: self.impl = impl
      elif isinstance(value, SecSince1970): self.impl = value.impl
      else: self.impl = value
   @property
   def value(self): return self.impl
   @value.setter
   def value(self, value): self.impl = value

TimeStamp.buc = SecSince1970

class TimeStamp32(pyBaseClass):
   def __init__(self, impl = 0):
      self.impl = impl

TimeStamp32.buc = TimeStamp32

class UnicodeDecomposition(pyBaseClass):
   def __init__(self, canonical = False, compat = False, fraction = False, font = False, noBreak = False, initial = False, final = False, medial = False, isolated = False, circle = False, square = False, sub = False, super = False, small = False, vertical = False, wide = False, narrow = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(canonical, UnicodeDecomposition):
         self.impl = canonical.impl
      else:
         self.impl = (
            (canonical << lib.UNICODEDECOMPOSITION_canonical_SHIFT) |
            (compat    << lib.UNICODEDECOMPOSITION_compat_SHIFT)    |
            (fraction  << lib.UNICODEDECOMPOSITION_fraction_SHIFT)  |
            (font      << lib.UNICODEDECOMPOSITION_font_SHIFT)      |
            (noBreak   << lib.UNICODEDECOMPOSITION_noBreak_SHIFT)   |
            (initial   << lib.UNICODEDECOMPOSITION_initial_SHIFT)   |
            (final     << lib.UNICODEDECOMPOSITION_final_SHIFT)     |
            (medial    << lib.UNICODEDECOMPOSITION_medial_SHIFT)    |
            (isolated  << lib.UNICODEDECOMPOSITION_isolated_SHIFT)  |
            (circle    << lib.UNICODEDECOMPOSITION_circle_SHIFT)    |
            (square    << lib.UNICODEDECOMPOSITION_square_SHIFT)    |
            (sub       << lib.UNICODEDECOMPOSITION_sub_SHIFT)       |
            (super     << lib.UNICODEDECOMPOSITION_super_SHIFT)     |
            (small     << lib.UNICODEDECOMPOSITION_small_SHIFT)     |
            (vertical  << lib.UNICODEDECOMPOSITION_vertical_SHIFT)  |
            (wide      << lib.UNICODEDECOMPOSITION_wide_SHIFT)      |
            (narrow    << lib.UNICODEDECOMPOSITION_narrow_SHIFT)    )

   @property
   def canonical(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_canonical_MASK) >> lib.UNICODEDECOMPOSITION_canonical_SHIFT)
   @canonical.setter
   def canonical(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_canonical_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_canonical_SHIFT)

   @property
   def compat(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_compat_MASK) >> lib.UNICODEDECOMPOSITION_compat_SHIFT)
   @compat.setter
   def compat(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_compat_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_compat_SHIFT)

   @property
   def fraction(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_fraction_MASK) >> lib.UNICODEDECOMPOSITION_fraction_SHIFT)
   @fraction.setter
   def fraction(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_fraction_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_fraction_SHIFT)

   @property
   def font(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_font_MASK) >> lib.UNICODEDECOMPOSITION_font_SHIFT)
   @font.setter
   def font(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_font_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_font_SHIFT)

   @property
   def noBreak(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_noBreak_MASK) >> lib.UNICODEDECOMPOSITION_noBreak_SHIFT)
   @noBreak.setter
   def noBreak(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_noBreak_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_noBreak_SHIFT)

   @property
   def initial(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_initial_MASK) >> lib.UNICODEDECOMPOSITION_initial_SHIFT)
   @initial.setter
   def initial(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_initial_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_initial_SHIFT)

   @property
   def final(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_final_MASK) >> lib.UNICODEDECOMPOSITION_final_SHIFT)
   @final.setter
   def final(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_final_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_final_SHIFT)

   @property
   def medial(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_medial_MASK) >> lib.UNICODEDECOMPOSITION_medial_SHIFT)
   @medial.setter
   def medial(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_medial_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_medial_SHIFT)

   @property
   def isolated(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_isolated_MASK) >> lib.UNICODEDECOMPOSITION_isolated_SHIFT)
   @isolated.setter
   def isolated(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_isolated_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_isolated_SHIFT)

   @property
   def circle(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_circle_MASK) >> lib.UNICODEDECOMPOSITION_circle_SHIFT)
   @circle.setter
   def circle(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_circle_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_circle_SHIFT)

   @property
   def square(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_square_MASK) >> lib.UNICODEDECOMPOSITION_square_SHIFT)
   @square.setter
   def square(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_square_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_square_SHIFT)

   @property
   def sub(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_sub_MASK) >> lib.UNICODEDECOMPOSITION_sub_SHIFT)
   @sub.setter
   def sub(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_sub_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_sub_SHIFT)

   @property
   def super(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_super_MASK) >> lib.UNICODEDECOMPOSITION_super_SHIFT)
   @super.setter
   def super(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_super_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_super_SHIFT)

   @property
   def small(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_small_MASK) >> lib.UNICODEDECOMPOSITION_small_SHIFT)
   @small.setter
   def small(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_small_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_small_SHIFT)

   @property
   def vertical(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_vertical_MASK) >> lib.UNICODEDECOMPOSITION_vertical_SHIFT)
   @vertical.setter
   def vertical(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_vertical_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_vertical_SHIFT)

   @property
   def wide(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_wide_MASK) >> lib.UNICODEDECOMPOSITION_wide_SHIFT)
   @wide.setter
   def wide(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_wide_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_wide_SHIFT)

   @property
   def narrow(self): return ((((self.impl)) & lib.UNICODEDECOMPOSITION_narrow_MASK) >> lib.UNICODEDECOMPOSITION_narrow_SHIFT)
   @narrow.setter
   def narrow(self, value): self.impl = ((self.impl) & ~(lib.UNICODEDECOMPOSITION_narrow_MASK)) | (((value)) << lib.UNICODEDECOMPOSITION_narrow_SHIFT)

def archiveOpen(fileName, flags):
   if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
   elif fileName is None: fileName = ffi.NULL
   if flags is not None and not isinstance(flags, ArchiveOpenFlags): flags = ArchiveOpenFlags(flags)
   if flags is None: flags = ffi.NULL
   return pyOrNewObject(Archive, lib.eC_archiveOpen(fileName, flags))

def archiveQuerySize(fileName):
   if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
   elif fileName is None: fileName = ffi.NULL
   size = ffi.new("eC_FileSize *")
   r = lib.eC_archiveQuerySize(fileName, size)
   return r, FileSize(impl = size[0])

def changeWorkingDir(buf):
   if isinstance(buf, str): buf = ffi.new("char[]", buf.encode('u8'))
   elif buf is None: buf = ffi.NULL
   return lib.eC_changeWorkingDir(buf)

def charMatchCategories(ch, categories):
   if ch is not None and not isinstance(ch, unichar): ch = unichar(ch)
   if ch is None: ch = ffi.NULL
   if categories is not None and not isinstance(categories, CharCategories): categories = CharCategories(categories)
   if categories is None: categories = ffi.NULL
   return lib.eC_charMatchCategories(ch, categories)

def copyBytes(dest, source, count):
   if hasattr(dest, 'impl'): dest = dest.impl
   if dest is None: dest = ffi.NULL
   if hasattr(source, 'impl'): source = source.impl
   if source is None: source = ffi.NULL
   lib.eC_copyBytes(dest, source, count)

def copyBytesBy2(dest, source, count):
   if hasattr(dest, 'impl'): dest = dest.impl
   if dest is None: dest = ffi.NULL
   if hasattr(source, 'impl'): source = source.impl
   if source is None: source = ffi.NULL
   lib.eC_copyBytesBy2(dest, source, count)

def copyBytesBy4(dest, source, count):
   if hasattr(dest, 'impl'): dest = dest.impl
   if dest is None: dest = ffi.NULL
   if hasattr(source, 'impl'): source = source.impl
   if source is None: source = ffi.NULL
   lib.eC_copyBytesBy4(dest, source, count)

def copySystemPath(p):
   if isinstance(p, str): p = ffi.new("char[]", p.encode('u8'))
   elif p is None: p = ffi.NULL
   return lib.eC_copySystemPath(p)

def copyUnixPath(p):
   if isinstance(p, str): p = ffi.new("char[]", p.encode('u8'))
   elif p is None: p = ffi.NULL
   return lib.eC_copyUnixPath(p)

def createTemporaryDir(tempFileName, template):
   if isinstance(tempFileName, str): tempFileName = ffi.new("char[]", tempFileName.encode('u8'))
   elif tempFileName is None: tempFileName = ffi.NULL
   if isinstance(template, str): template = ffi.new("char[]", template.encode('u8'))
   elif template is None: template = ffi.NULL
   lib.eC_createTemporaryDir(tempFileName, template)

def createTemporaryFile(tempFileName, template):
   if isinstance(tempFileName, str): tempFileName = ffi.new("char[]", tempFileName.encode('u8'))
   elif tempFileName is None: tempFileName = ffi.NULL
   if isinstance(template, str): template = ffi.new("char[]", template.encode('u8'))
   elif template is None: template = ffi.NULL
   return pyOrNewObject(File, lib.eC_createTemporaryFile(tempFileName, template))

def deleteFile(fileName):
   if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
   elif fileName is None: fileName = ffi.NULL
   return lib.eC_deleteFile(fileName)

def dualPipeOpen(mode, commandLine):
   if mode is not None and not isinstance(mode, PipeOpenMode): mode = PipeOpenMode(mode)
   if mode is None: mode = ffi.NULL
   if isinstance(commandLine, str): commandLine = ffi.new("char[]", commandLine.encode('u8'))
   elif commandLine is None: commandLine = ffi.NULL
   return pyOrNewObject(DualPipe, lib.eC_dualPipeOpen(mode, commandLine))

def dualPipeOpenEnv(mode, env, commandLine):
   if mode is not None and not isinstance(mode, PipeOpenMode): mode = PipeOpenMode(mode)
   if mode is None: mode = ffi.NULL
   if isinstance(env, str): env = ffi.new("char[]", env.encode('u8'))
   elif env is None: env = ffi.NULL
   if isinstance(commandLine, str): commandLine = ffi.new("char[]", commandLine.encode('u8'))
   elif commandLine is None: commandLine = ffi.NULL
   return pyOrNewObject(DualPipe, lib.eC_dualPipeOpenEnv(mode, env, commandLine))

def dualPipeOpenEnvf(mode, env, command, *args):
   if mode is not None and not isinstance(mode, PipeOpenMode): mode = PipeOpenMode(mode)
   if mode is None: mode = ffi.NULL
   if isinstance(env, str): env = ffi.new("char[]", env.encode('u8'))
   elif env is None: env = ffi.NULL
   if isinstance(command, str): command = ffi.new("char[]", command.encode('u8'))
   elif command is None: command = ffi.NULL
   return pyOrNewObject(DualPipe, lib.eC_dualPipeOpenEnvf(mode, env, command, *ellipsisArgs(args)))

def dualPipeOpenf(mode, command, *args):
   if mode is not None and not isinstance(mode, PipeOpenMode): mode = PipeOpenMode(mode)
   if mode is None: mode = ffi.NULL
   if isinstance(command, str): command = ffi.new("char[]", command.encode('u8'))
   elif command is None: command = ffi.NULL
   return pyOrNewObject(DualPipe, lib.eC_dualPipeOpenf(mode, command, *ellipsisArgs(args)))

def dumpErrors(display):
   lib.eC_dumpErrors(display)

def execute(command, *args):
   if isinstance(command, str): command = ffi.new("char[]", command.encode('u8'))
   elif command is None: command = ffi.NULL
   return lib.eC_execute(command, *ellipsisArgs(args))

def executeEnv(env, command, *args):
   if isinstance(env, str): env = ffi.new("char[]", env.encode('u8'))
   elif env is None: env = ffi.NULL
   if isinstance(command, str): command = ffi.new("char[]", command.encode('u8'))
   elif command is None: command = ffi.NULL
   return lib.eC_executeEnv(env, command, *ellipsisArgs(args))

def executeWait(command, *args):
   if isinstance(command, str): command = ffi.new("char[]", command.encode('u8'))
   elif command is None: command = ffi.NULL
   return lib.eC_executeWait(command, *ellipsisArgs(args))

def fileExists(fileName):
   if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
   elif fileName is None: fileName = ffi.NULL
   return FileAttribs(impl = lib.eC_fileExists(fileName))

def fileFixCase(file):
   if isinstance(file, str): file = ffi.new("char[]", file.encode('u8'))
   elif file is None: file = ffi.NULL
   lib.eC_fileFixCase(file)

def fileGetSize(fileName):
   if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
   elif fileName is None: fileName = ffi.NULL
   size = ffi.new("eC_FileSize *")
   r = lib.eC_fileGetSize(fileName, size)
   return r, FileSize(impl = size[0])

def fileGetStats(fileName, stats = None):
   if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
   elif fileName is None: fileName = ffi.NULL
   if stats is not None and not isinstance(stats, FileStats): stats = FileStats(stats)
   stats = ffi.NULL if stats is None else stats.impl
   return lib.eC_fileGetStats(fileName, ffi.cast("eC_FileStats *", stats))

def fileOpen(fileName, mode):
   if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
   elif fileName is None: fileName = ffi.NULL
   return pyOrNewObject(File, lib.eC_fileOpen(fileName, mode))

def fileOpenBuffered(fileName, mode):
   if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
   elif fileName is None: fileName = ffi.NULL
   return pyOrNewObject(BufferedFile, lib.eC_fileOpenBuffered(fileName, mode))

def fileSetAttribs(fileName, attribs):
   if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
   elif fileName is None: fileName = ffi.NULL
   if attribs is not None and not isinstance(attribs, FileAttribs): attribs = FileAttribs(attribs)
   if attribs is None: attribs = ffi.NULL
   return lib.eC_fileSetAttribs(fileName, attribs)

def fileSetTime(fileName, created, accessed, modified):
   if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
   elif fileName is None: fileName = ffi.NULL
   if created is not None and not isinstance(created, SecSince1970): created = TimeStamp(created)
   if created is None: created = ffi.NULL
   if accessed is not None and not isinstance(accessed, SecSince1970): accessed = TimeStamp(accessed)
   if accessed is None: accessed = ffi.NULL
   if modified is not None and not isinstance(modified, SecSince1970): modified = TimeStamp(modified)
   if modified is None: modified = ffi.NULL
   return lib.eC_fileSetTime(fileName, created.impl, accessed.impl, modified.impl)

def fileTruncate(fileName, size):
   if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
   elif fileName is None: fileName = ffi.NULL
   return lib.eC_fileTruncate(fileName, size)

def fillBytes(area, value, count):
   if hasattr(area, 'impl'): area = area.impl
   if area is None: area = ffi.NULL
   lib.eC_fillBytes(area, value, count)

def fillBytesBy2(area, value, count):
   if hasattr(area, 'impl'): area = area.impl
   if area is None: area = ffi.NULL
   lib.eC_fillBytesBy2(area, value, count)

def fillBytesBy4(area, value, count):
   if hasattr(area, 'impl'): area = area.impl
   if area is None: area = ffi.NULL
   lib.eC_fillBytesBy4(area, value, count)

def getAlNum(input, string, max):
   if isinstance(input, str): input = ffi.new("char[]", input.encode('u8'))
   elif input is None: input = ffi.NULL
   if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
   elif string is None: string = ffi.NULL
   return lib.eC_getAlNum(input, string, max)

def getCharCategory(ch):
   if ch is not None and not isinstance(ch, unichar): ch = unichar(ch)
   if ch is None: ch = ffi.NULL
   return lib.eC_getCharCategory(ch)

def getCombiningClass(ch):
   if ch is not None and not isinstance(ch, unichar): ch = unichar(ch)
   if ch is None: ch = ffi.NULL
   return lib.eC_getCombiningClass(ch)

def getEnvironment(envName, envValue, max):
   if isinstance(envName, str): envName = ffi.new("char[]", envName.encode('u8'))
   elif envName is None: envName = ffi.NULL
   if isinstance(envValue, str): envValue = ffi.new("char[]", envValue.encode('u8'))
   elif envValue is None: envValue = ffi.NULL
   return lib.eC_getEnvironment(envName, envValue, max)

def getFreeSpace(path):
   if isinstance(path, str): path = ffi.new("char[]", path.encode('u8'))
   elif path is None: path = ffi.NULL
   size = ffi.new("eC_FileSize64 *")
   lib.eC_getFreeSpace(path, size)
   return FileSize64(impl = size[0])

def getLastErrorCode():
   return lib.eC_getLastErrorCode()

def getRandom(lo, hi):
   return lib.eC_getRandom(lo, hi)

def getSlashPathBuffer(d, p):
   if isinstance(d, str): d = ffi.new("char[]", d.encode('u8'))
   elif d is None: d = ffi.NULL
   if isinstance(p, str): p = ffi.new("char[]", p.encode('u8'))
   elif p is None: p = ffi.NULL
   return lib.eC_getSlashPathBuffer(d, p)

def getSystemPathBuffer(d, p):
   if isinstance(d, str): d = ffi.new("char[]", d.encode('u8'))
   elif d is None: d = ffi.NULL
   if isinstance(p, str): p = ffi.new("char[]", p.encode('u8'))
   elif p is None: p = ffi.NULL
   return lib.eC_getSystemPathBuffer(d, p)

def getTime():
   return Time(impl = lib.eC_getTime())

def getWorkingDir(buf, size):
   if isinstance(buf, str): buf = ffi.new("char[]", buf.encode('u8'))
   elif buf is None: buf = ffi.NULL
   return lib.eC_getWorkingDir(buf, size)

def __e_log(text):
   if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
   elif text is None: text = ffi.NULL
   lib.eC___e_log(text)

def logErrorCode(errorCode, details):
   if errorCode is not None and not isinstance(errorCode, ErrorCode): errorCode = ErrorCode(errorCode)
   if errorCode is None: errorCode = ffi.NULL
   if isinstance(details, str): details = ffi.new("char[]", details.encode('u8'))
   elif details is None: details = ffi.NULL
   lib.eC_logErrorCode(errorCode, details)

def __e_logf(format, *args):
   if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
   elif format is None: format = ffi.NULL
   lib.eC___e_logf(format, *ellipsisArgs(args))

def makeDir(path):
   if isinstance(path, str): path = ffi.new("char[]", path.encode('u8'))
   elif path is None: path = ffi.NULL
   return lib.eC_makeDir(path)

def makeSlashPath(p):
   if isinstance(p, str): p = ffi.new("char[]", p.encode('u8'))
   elif p is None: p = ffi.NULL
   lib.eC_makeSlashPath(p)

def makeSystemPath(p):
   if isinstance(p, str): p = ffi.new("char[]", p.encode('u8'))
   elif p is None: p = ffi.NULL
   lib.eC_makeSystemPath(p)

def moveBytes(dest, source, count):
   if hasattr(dest, 'impl'): dest = dest.impl
   if dest is None: dest = ffi.NULL
   if hasattr(source, 'impl'): source = source.impl
   if source is None: source = ffi.NULL
   lib.eC_moveBytes(dest, source, count)

def moveFile(source, dest):
   if isinstance(source, str): source = ffi.new("char[]", source.encode('u8'))
   elif source is None: source = ffi.NULL
   if isinstance(dest, str): dest = ffi.new("char[]", dest.encode('u8'))
   elif dest is None: dest = ffi.NULL
   return lib.eC_moveFile(source, dest)

def moveFileEx(source, dest, options):
   if isinstance(source, str): source = ffi.new("char[]", source.encode('u8'))
   elif source is None: source = ffi.NULL
   if isinstance(dest, str): dest = ffi.new("char[]", dest.encode('u8'))
   elif dest is None: dest = ffi.NULL
   if options is not None and not isinstance(options, MoveFileOptions): options = MoveFileOptions(options)
   if options is None: options = ffi.NULL
   return lib.eC_moveFileEx(source, dest, options)

def printECONObject(objectType, object, indent):
   if objectType is not None and not isinstance(objectType, Class): objectType = Class(objectType)
   objectType = ffi.NULL if objectType is None else objectType.impl
   if hasattr(object, 'impl'): object = object.impl
   if object is None: object = ffi.NULL
   return pyOrNewObject(String, lib.eC_printECONObject(ffi.cast("struct eC_Class *", objectType), object, indent))

def printObjectNotationString(objectType, object, onType, indent, indentFirst, capitalize):
   if objectType is not None and not isinstance(objectType, Class): objectType = Class(objectType)
   objectType = ffi.NULL if objectType is None else objectType.impl
   if hasattr(object, 'impl'): object = object.impl
   if object is None: object = ffi.NULL
   return pyOrNewObject(String, lib.eC_printObjectNotationString(ffi.cast("struct eC_Class *", objectType), object, onType, indent, indentFirst, capitalize))

def randomSeed(seed):
   lib.eC_randomSeed(seed)

def removeDir(path):
   if isinstance(path, str): path = ffi.new("char[]", path.encode('u8'))
   elif path is None: path = ffi.NULL
   return lib.eC_removeDir(path)

def renameFile(oldName, newName):
   if isinstance(oldName, str): oldName = ffi.new("char[]", oldName.encode('u8'))
   elif oldName is None: oldName = ffi.NULL
   if isinstance(newName, str): newName = ffi.new("char[]", newName.encode('u8'))
   elif newName is None: newName = ffi.NULL
   return lib.eC_renameFile(oldName, newName)

def resetError():
   lib.eC_resetError()

def setEnvironment(envName, envValue):
   if isinstance(envName, str): envName = ffi.new("char[]", envName.encode('u8'))
   elif envName is None: envName = ffi.NULL
   if isinstance(envValue, str): envValue = ffi.new("char[]", envValue.encode('u8'))
   elif envValue is None: envValue = ffi.NULL
   lib.eC_setEnvironment(envName, envValue)

def setErrorLevel(level):
   lib.eC_setErrorLevel(level)

def setLoggingMode(mode, where):
   if hasattr(where, 'impl'): where = where.impl
   if where is None: where = ffi.NULL
   lib.eC_setLoggingMode(mode, where)

def shellOpen(fileName, *args):
   if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
   elif fileName is None: fileName = ffi.NULL
   return lib.eC_shellOpen(fileName, *ellipsisArgs(args))

def __sleep(seconds):
   if seconds is not None and not isinstance(seconds, Time): seconds = Seconds(seconds)
   if seconds is None: seconds = ffi.NULL
   lib.eC___sleep(seconds.impl)

def stringIndent(base, nSpaces, indentFirst):
   if isinstance(base, str): base = ffi.new("char[]", base.encode('u8'))
   elif base is None: base = ffi.NULL
   return pyOrNewObject(String, lib.eC_stringIndent(base, nSpaces, indentFirst))

def uTF16BEtoUTF8Buffer(source, dest, max):
   return lib.eC_uTF16BEtoUTF8Buffer(source, dest, max)

def uTF8toISO8859_1(source, dest, max):
   if isinstance(source, str): source = ffi.new("char[]", source.encode('u8'))
   elif source is None: source = ffi.NULL
   if isinstance(dest, str): dest = ffi.new("char[]", dest.encode('u8'))
   elif dest is None: dest = ffi.NULL
   return lib.eC_uTF8toISO8859_1(source, dest, max)

def uTF8toUTF16BufferLen(source, max, len):
   if isinstance(source, str): source = ffi.new("char[]", source.encode('u8'))
   elif source is None: source = ffi.NULL
   dest = ffi.new("uint16 *")
   r = lib.eC_uTF8toUTF16BufferLen(source, dest, max, len)
   return r, dest[0]

def uTF8toUTF16Len(source, byteCount):
   if isinstance(source, str): source = ffi.new("char[]", source.encode('u8'))
   elif source is None: source = ffi.NULL
   wordCount = ffi.new("int *")
   r = lib.eC_uTF8toUTF16Len(source, byteCount, wordCount)
   return r, wordCount[0]

def unsetEnvironment(envName):
   if isinstance(envName, str): envName = ffi.new("char[]", envName.encode('u8'))
   elif envName is None: envName = ffi.NULL
   lib.eC_unsetEnvironment(envName)

def writeECONObject(f, objectType, object, indent):
   if f is not None and not isinstance(f, File): f = File(f)
   f = ffi.NULL if f is None else f.impl
   if objectType is not None and not isinstance(objectType, Class): objectType = Class(objectType)
   objectType = ffi.NULL if objectType is None else objectType.impl
   if hasattr(object, 'impl'): object = object.impl
   if object is None: object = ffi.NULL
   return lib.eC_writeECONObject(f, ffi.cast("struct eC_Class *", objectType), object, indent)

def writeJSONObject(f, objectType, object, indent):
   if f is not None and not isinstance(f, File): f = File(f)
   f = ffi.NULL if f is None else f.impl
   if objectType is not None and not isinstance(objectType, Class): objectType = Class(objectType)
   objectType = ffi.NULL if objectType is None else objectType.impl
   if hasattr(object, 'impl'): object = object.impl
   if object is None: object = ffi.NULL
   return lib.eC_writeJSONObject(f, ffi.cast("struct eC_Class *", objectType), object, indent)

def writeJSONObject2(f, objectType, object, indent, capitalize):
   if f is not None and not isinstance(f, File): f = File(f)
   f = ffi.NULL if f is None else f.impl
   if objectType is not None and not isinstance(objectType, Class): objectType = Class(objectType)
   objectType = ffi.NULL if objectType is None else objectType.impl
   if hasattr(object, 'impl'): object = object.impl
   if object is None: object = ffi.NULL
   return lib.eC_writeJSONObject2(f, ffi.cast("struct eC_Class *", objectType), object, indent, capitalize)

def writeJSONObjectMapped(f, objectType, object, indent, stringMap = None):
   if f is not None and not isinstance(f, File): f = File(f)
   f = ffi.NULL if f is None else f.impl
   if objectType is not None and not isinstance(objectType, Class): objectType = Class(objectType)
   objectType = ffi.NULL if objectType is None else objectType.impl
   if hasattr(object, 'impl'): object = object.impl
   if object is None: object = ffi.NULL
   return lib.eC_writeJSONObjectMapped(f, ffi.cast("struct eC_Class *", objectType), object, indent, Map.impl)

def writeONString(f, s, eCON, indent):
   if f is not None and not isinstance(f, File): f = File(f)
   f = ffi.NULL if f is None else f.impl
   if isinstance(s, str): s = ffi.new("char[]", s.encode('u8'))
   elif s is None: s = ffi.NULL
   return lib.eC_writeONString(f, s, eCON, indent)

def accenti(string = None):
   if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
   elif string is None: string = ffi.NULL
   return pyOrNewObject(String, lib.eC_accenti(string))

def casei(string = None):
   if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
   elif string is None: string = ffi.NULL
   return pyOrNewObject(String, lib.eC_casei(string))

def debugBreakpoint():
   lib.eC_debugBreakpoint()

def encodeArrayToString(array = None):
   return pyOrNewObject(String, lib.eC_encodeArrayToString(Array.impl))

def normalizeNFC(string = None):
   if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
   elif string is None: string = ffi.NULL
   return pyOrNewObject(String, lib.eC_normalizeNFC(string))

def normalizeNFD(string = None):
   if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
   elif string is None: string = ffi.NULL
   return pyOrNewObject(String, lib.eC_normalizeNFD(string))

def normalizeNFKC(string = None):
   if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
   elif string is None: string = ffi.NULL
   return pyOrNewObject(String, lib.eC_normalizeNFKC(string))

def normalizeNFKD(string = None):
   if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
   elif string is None: string = ffi.NULL
   return pyOrNewObject(String, lib.eC_normalizeNFKD(string))

def normalizeNFKDArray(string = None):
   if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
   elif string is None: string = ffi.NULL
   return pyOrNewObject(Array, lib.eC_normalizeNFKDArray(string), "<unichar>")

def normalizeUnicode(string, type, compose):
   if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
   elif string is None: string = ffi.NULL
   if type is not None and not isinstance(type, UnicodeDecomposition): type = UnicodeDecomposition(type)
   if type is None: type = ffi.NULL
   return pyOrNewObject(String, lib.eC_normalizeUnicode(string, type, compose))

def normalizeUnicodeArray(string, type, compose):
   if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
   elif string is None: string = ffi.NULL
   if type is not None and not isinstance(type, UnicodeDecomposition): type = UnicodeDecomposition(type)
   if type is None: type = ffi.NULL
   return pyOrNewObject(Array, lib.eC_normalizeUnicodeArray(string, type, compose), "<unichar>")

def stripUnicodeCategory(string, c):
   if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
   elif string is None: string = ffi.NULL
   return pyOrNewObject(String, lib.eC_stripUnicodeCategory(string, c))

class Bitmap(Instance):
   class_members = [
                      'width',
                      'height',
                      'pixelFormat',
                      'picture',
                      'stride',
                      'size',
                      'sizeBytes',
                      'palette',
                      'allocatePalette',
                      'transparent',
                      'shadeShift',
                      'paletteShades',
                      'alphaBlend',
                      'displaySystem',
                      'driver',
                      'driverData',
                      'keepData',
                      'mipMaps',
                      'sRGB2Linear',
                      'numMipMaps',
                      'bitmaps',
                   ]

   def init_args(self, args, kwArgs): init_args(Bitmap, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def width(self): return IPTR(lib, ffi, self, Bitmap).width
   @width.setter
   def width(self, value): IPTR(lib, ffi, self, Bitmap).width = value

   @property
   def height(self): return IPTR(lib, ffi, self, Bitmap).height
   @height.setter
   def height(self, value): IPTR(lib, ffi, self, Bitmap).height = value

   @property
   def pixelFormat(self): return PixelFormat(impl = IPTR(lib, ffi, self, Bitmap).pixelFormat)
   @pixelFormat.setter
   def pixelFormat(self, value): IPTR(lib, ffi, self, Bitmap).pixelFormat = value.impl

   @property
   def picture(self): return IPTR(lib, ffi, self, Bitmap).picture
   @picture.setter
   def picture(self, value): IPTR(lib, ffi, self, Bitmap).picture = value

   @property
   def stride(self): return IPTR(lib, ffi, self, Bitmap).stride
   @stride.setter
   def stride(self, value): IPTR(lib, ffi, self, Bitmap).stride = value

   @property
   def size(self): return IPTR(lib, ffi, self, Bitmap).size
   @size.setter
   def size(self, value): IPTR(lib, ffi, self, Bitmap).size = value

   @property
   def sizeBytes(self): return IPTR(lib, ffi, self, Bitmap).sizeBytes
   @sizeBytes.setter
   def sizeBytes(self, value): IPTR(lib, ffi, self, Bitmap).sizeBytes = value

   @property
   def palette(self): return IPTR(lib, ffi, self, Bitmap).palette
   @palette.setter
   def palette(self, value): IPTR(lib, ffi, self, Bitmap).palette = value

   @property
   def allocatePalette(self): return IPTR(lib, ffi, self, Bitmap).allocatePalette
   @allocatePalette.setter
   def allocatePalette(self, value): IPTR(lib, ffi, self, Bitmap).allocatePalette = value

   @property
   def transparent(self): return IPTR(lib, ffi, self, Bitmap).transparent
   @transparent.setter
   def transparent(self, value): IPTR(lib, ffi, self, Bitmap).transparent = value

   @property
   def shadeShift(self): return IPTR(lib, ffi, self, Bitmap).shadeShift
   @shadeShift.setter
   def shadeShift(self, value): IPTR(lib, ffi, self, Bitmap).shadeShift = value

   @property
   def paletteShades(self): return IPTR(lib, ffi, self, Bitmap).paletteShades
   @paletteShades.setter
   def paletteShades(self, value): IPTR(lib, ffi, self, Bitmap).paletteShades = value

   @property
   def alphaBlend(self): return IPTR(lib, ffi, self, Bitmap).alphaBlend
   @alphaBlend.setter
   def alphaBlend(self, value): IPTR(lib, ffi, self, Bitmap).alphaBlend = value

   @property
   def displaySystem(self): return pyOrNewObject(DisplaySystem, IPTR(lib, ffi, self, Bitmap).displaySystem)
   @displaySystem.setter
   def displaySystem(self, value):
      if not isinstance(value, DisplaySystem): value = DisplaySystem(value)
      IPTR(lib, ffi, self, Bitmap).displaySystem = value.impl

   @property
   def driver(self): return IPTR(lib, ffi, self, Bitmap).driver
   @driver.setter
   def driver(self, value): IPTR(lib, ffi, self, Bitmap).driver = value

   @property
   def driverData(self): return IPTR(lib, ffi, self, Bitmap).driverData
   @driverData.setter
   def driverData(self, value): IPTR(lib, ffi, self, Bitmap).driverData = value

   @property
   def keepData(self): return IPTR(lib, ffi, self, Bitmap).keepData
   @keepData.setter
   def keepData(self, value): IPTR(lib, ffi, self, Bitmap).keepData = value

   @property
   def mipMaps(self): return IPTR(lib, ffi, self, Bitmap).mipMaps
   @mipMaps.setter
   def mipMaps(self, value): IPTR(lib, ffi, self, Bitmap).mipMaps = value

   @property
   def sRGB2Linear(self): return IPTR(lib, ffi, self, Bitmap).sRGB2Linear
   @sRGB2Linear.setter
   def sRGB2Linear(self, value): IPTR(lib, ffi, self, Bitmap).sRGB2Linear = value

   @property
   def numMipMaps(self): return IPTR(lib, ffi, self, Bitmap).numMipMaps
   @numMipMaps.setter
   def numMipMaps(self, value): IPTR(lib, ffi, self, Bitmap).numMipMaps = value

   @property
   def bitmaps(self): return IPTR(lib, ffi, self, Bitmap).bitmaps
   @bitmaps.setter
   def bitmaps(self, value): IPTR(lib, ffi, self, Bitmap).bitmaps = value

   def allocate(self, driverName, width, height, stride, format, allocatePalette):
      if isinstance(driverName, str): driverName = ffi.new("char[]", driverName.encode('u8'))
      elif driverName is None: driverName = ffi.NULL
      return lib.Bitmap_allocate(self.impl, driverName, width, height, stride, format, allocatePalette)

   def allocateDD(self, displaySystem, width, height):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Bitmap_allocateDD(self.impl, displaySystem, width, height)

   def convert(self, displaySystem, format):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      palette = ffi.new("eC_ColorAlpha *")
      r = lib.Bitmap_convert(self.impl, displaySystem, format, palette)
      return r, ColorAlpha(impl = palette[0])

   def copy(self, source = None):
      if source is not None and not isinstance(source, Bitmap): source = Bitmap(source)
      source = ffi.NULL if source is None else source.impl
      return lib.Bitmap_copy(self.impl, source)

   def copy2(self, source, moveStuff):
      if source is not None and not isinstance(source, Bitmap): source = Bitmap(source)
      source = ffi.NULL if source is None else source.impl
      return lib.Bitmap_copy2(self.impl, source, moveStuff)

   def free(self):
      lib.Bitmap_free(self.impl)

   def getSurface(self, x, y, clip = None):
      if clip is not None and not isinstance(clip, Box): clip = Box(clip)
      clip = ffi.NULL if clip is None else clip.impl
      return pyOrNewObject(Surface, lib.Bitmap_getSurface(self.impl, x, y, ffi.cast("eC_Box *", clip)))

   def grab(self, src, x, y):
      if src is not None and not isinstance(src, Bitmap): src = Bitmap(src)
      src = ffi.NULL if src is None else src.impl
      lib.Bitmap_grab(self.impl, src, x, y)

   def load(self, fileName, type, displaySystem = None):
      if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
      elif fileName is None: fileName = ffi.NULL
      if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
      elif type is None: type = ffi.NULL
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Bitmap_load(self.impl, fileName, type, displaySystem)

   def loadFromFile(self, file, type, displaySystem = None):
      if file is not None and not isinstance(file, File): file = File(file)
      file = ffi.NULL if file is None else file.impl
      if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
      elif type is None: type = ffi.NULL
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Bitmap_loadFromFile(self.impl, file, type, displaySystem)

   def loadGrayed(self, fileName, type, displaySystem = None):
      if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
      elif fileName is None: fileName = ffi.NULL
      if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
      elif type is None: type = ffi.NULL
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Bitmap_loadGrayed(self.impl, fileName, type, displaySystem)

   def loadMipMaps(self, fileName, type, displaySystem = None):
      if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
      elif fileName is None: fileName = ffi.NULL
      if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
      elif type is None: type = ffi.NULL
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Bitmap_loadMipMaps(self.impl, fileName, type, displaySystem)

   def loadMonochrome(self, fileName, type, displaySystem = None):
      if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
      elif fileName is None: fileName = ffi.NULL
      if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
      elif type is None: type = ffi.NULL
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Bitmap_loadMonochrome(self.impl, fileName, type, displaySystem)

   def loadT(self, fileName, type, displaySystem = None):
      if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
      elif fileName is None: fileName = ffi.NULL
      if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
      elif type is None: type = ffi.NULL
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Bitmap_loadT(self.impl, fileName, type, displaySystem)

   def loadTMipMaps(self, fileName, type, displaySystem = None):
      if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
      elif fileName is None: fileName = ffi.NULL
      if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
      elif type is None: type = ffi.NULL
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Bitmap_loadTMipMaps(self.impl, fileName, type, displaySystem)

   def makeDD(self, displaySystem = None):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Bitmap_makeDD(self.impl, displaySystem)

   def makeMipMaps(self, displaySystem = None):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Bitmap_makeMipMaps(self.impl, displaySystem)

   def processDD(self, mipMaps, cubeMapFace, compress, maxTextureSize, makePow2, enforcedWidth, enforcedHeight):
      return pyOrNewObject(Bitmap, lib.Bitmap_processDD(self.impl, mipMaps, cubeMapFace, compress, maxTextureSize, makePow2, enforcedWidth, enforcedHeight))

   def quantize(self, start, end):
      return lib.Bitmap_quantize(self.impl, start, end)

   def save(self, fileName, type, options):
      if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
      elif fileName is None: fileName = ffi.NULL
      if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
      elif type is None: type = ffi.NULL
      if hasattr(options, 'impl'): options = options.impl
      if options is None: options = ffi.NULL
      return lib.Bitmap_save(self.impl, fileName, type, options)

   def smoothEdges(self, size):
      lib.Bitmap_smoothEdges(self.impl, size)

@ffi.callback("int(eC_FontManagerRenderer, int, int)")
def cb_FontManagerRenderer_createTexture(__e, width, height):
   fontmanagerrenderer = pyOrNewObject(FontManagerRenderer, __e)
   return fontmanagerrenderer.fn_FontManagerRenderer_createTexture(fontmanagerrenderer, width, height)

@ffi.callback("void(eC_FontManagerRenderer, int, int, int, eC_bool)")
def cb_FontManagerRenderer_drawImage(__e, targetx, targety, imageIndex, useExtColor):
   fontmanagerrenderer = pyOrNewObject(FontManagerRenderer, __e)
   fontmanagerrenderer.fn_FontManagerRenderer_drawImage(fontmanagerrenderer, targetx, targety, imageIndex, useExtColor)

@ffi.callback("void(eC_FontManagerRenderer, byte *, int, int, int, int, int, int)")
def cb_FontManagerRenderer_drawImageAlt(__e, texdata, targetx, targety, offsetx, offsety, width, height):
   fontmanagerrenderer = pyOrNewObject(FontManagerRenderer, __e)
   fontmanagerrenderer.fn_FontManagerRenderer_drawImageAlt(fontmanagerrenderer, texdata, targetx, targety, offsetx, offsety, width, height)

@ffi.callback("void(eC_FontManagerRenderer, int, int, int)")
def cb_FontManagerRenderer_drawImageCursor(__e, targetx, targety, imageIndex):
   fontmanagerrenderer = pyOrNewObject(FontManagerRenderer, __e)
   fontmanagerrenderer.fn_FontManagerRenderer_drawImageCursor(fontmanagerrenderer, targetx, targety, imageIndex)

@ffi.callback("void(eC_FontManagerRenderer, float, float, float, float, int, eC_bool)")
def cb_FontManagerRenderer_drawImageFloat(__e, targetx, targety, angsin, angcos, imageIndex, useExtColor):
   fontmanagerrenderer = pyOrNewObject(FontManagerRenderer, __e)
   fontmanagerrenderer.fn_FontManagerRenderer_drawImageFloat(fontmanagerrenderer, targetx, targety, angsin, angcos, imageIndex, useExtColor)

@ffi.callback("void(eC_FontManagerRenderer)")
def cb_FontManagerRenderer_flush(__e):
   fontmanagerrenderer = pyOrNewObject(FontManagerRenderer, __e)
   fontmanagerrenderer.fn_FontManagerRenderer_flush(fontmanagerrenderer)

@ffi.callback("eC_bool(eC_FontManagerRenderer, int)")
def cb_FontManagerRenderer_init(__e, channelCount):
   fontmanagerrenderer = pyOrNewObject(FontManagerRenderer, __e)
   return fontmanagerrenderer.fn_FontManagerRenderer_init(fontmanagerrenderer, channelCount)

@ffi.callback("int(eC_FontManagerRenderer, int, int, int, int)")
def cb_FontManagerRenderer_registerImage(__e, offsetx, offsety, width, height):
   fontmanagerrenderer = pyOrNewObject(FontManagerRenderer, __e)
   return fontmanagerrenderer.fn_FontManagerRenderer_registerImage(fontmanagerrenderer, offsetx, offsety, width, height)

@ffi.callback("void(eC_FontManagerRenderer)")
def cb_FontManagerRenderer_resetImages(__e):
   fontmanagerrenderer = pyOrNewObject(FontManagerRenderer, __e)
   fontmanagerrenderer.fn_FontManagerRenderer_resetImages(fontmanagerrenderer)

@ffi.callback("int(eC_FontManagerRenderer, int, int)")
def cb_FontManagerRenderer_resizeTexture(__e, width, height):
   fontmanagerrenderer = pyOrNewObject(FontManagerRenderer, __e)
   return fontmanagerrenderer.fn_FontManagerRenderer_resizeTexture(fontmanagerrenderer, width, height)

@ffi.callback("void(eC_FontManagerRenderer, uint)")
def cb_FontManagerRenderer_setLayer(__e, layerIndex):
   fontmanagerrenderer = pyOrNewObject(FontManagerRenderer, __e)
   fontmanagerrenderer.fn_FontManagerRenderer_setLayer(fontmanagerrenderer, layerIndex)

@ffi.callback("void(eC_FontManagerRenderer, int *, const byte *)")
def cb_FontManagerRenderer_updateTexture(__e, rect, data):
   fontmanagerrenderer = pyOrNewObject(FontManagerRenderer, __e)
   fontmanagerrenderer.fn_FontManagerRenderer_updateTexture(fontmanagerrenderer, rect, data)

class FontManagerRenderer(Instance):
   class_members = [
                      'fm',
                      'createTexture',
                      'drawImage',
                      'drawImageAlt',
                      'drawImageCursor',
                      'drawImageFloat',
                      'flush',
                      'init',
                      'registerImage',
                      'resetImages',
                      'resizeTexture',
                      'setLayer',
                      'updateTexture',
                   ]

   def init_args(self, args, kwArgs): init_args(FontManagerRenderer, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def fm(self): return pyOrNewObject(FontManager, IPTR(lib, ffi, self, FontManagerRenderer).fm)
   @fm.setter
   def fm(self, value):
      if not isinstance(value, FontManager): value = FontManager(value)
      IPTR(lib, ffi, self, FontManagerRenderer).fm = value.impl

   def fn_unset_FontManagerRenderer_createTexture(self, width, height):
      return lib.FontManagerRenderer_createTexture(self.impl, width, height)

   @property
   def createTexture(self):
      if hasattr(self, 'fn_FontManagerRenderer_createTexture'): return self.fn_FontManagerRenderer_createTexture
      else: return self.fn_unset_FontManagerRenderer_createTexture
   @createTexture.setter
   def createTexture(self, value):
      self.fn_FontManagerRenderer_createTexture = value
      lib.Instance_setMethod(self.impl, "createTexture".encode('u8'), cb_FontManagerRenderer_createTexture)

   def fn_unset_FontManagerRenderer_drawImage(self, targetx, targety, imageIndex, useExtColor):
      return lib.FontManagerRenderer_drawImage(self.impl, targetx, targety, imageIndex, useExtColor)

   @property
   def drawImage(self):
      if hasattr(self, 'fn_FontManagerRenderer_drawImage'): return self.fn_FontManagerRenderer_drawImage
      else: return self.fn_unset_FontManagerRenderer_drawImage
   @drawImage.setter
   def drawImage(self, value):
      self.fn_FontManagerRenderer_drawImage = value
      lib.Instance_setMethod(self.impl, "drawImage".encode('u8'), cb_FontManagerRenderer_drawImage)

   def fn_unset_FontManagerRenderer_drawImageAlt(self, texdata, targetx, targety, offsetx, offsety, width, height):
      return lib.FontManagerRenderer_drawImageAlt(self.impl, texdata, targetx, targety, offsetx, offsety, width, height)

   @property
   def drawImageAlt(self):
      if hasattr(self, 'fn_FontManagerRenderer_drawImageAlt'): return self.fn_FontManagerRenderer_drawImageAlt
      else: return self.fn_unset_FontManagerRenderer_drawImageAlt
   @drawImageAlt.setter
   def drawImageAlt(self, value):
      self.fn_FontManagerRenderer_drawImageAlt = value
      lib.Instance_setMethod(self.impl, "drawImageAlt".encode('u8'), cb_FontManagerRenderer_drawImageAlt)

   def fn_unset_FontManagerRenderer_drawImageCursor(self, targetx, targety, imageIndex):
      return lib.FontManagerRenderer_drawImageCursor(self.impl, targetx, targety, imageIndex)

   @property
   def drawImageCursor(self):
      if hasattr(self, 'fn_FontManagerRenderer_drawImageCursor'): return self.fn_FontManagerRenderer_drawImageCursor
      else: return self.fn_unset_FontManagerRenderer_drawImageCursor
   @drawImageCursor.setter
   def drawImageCursor(self, value):
      self.fn_FontManagerRenderer_drawImageCursor = value
      lib.Instance_setMethod(self.impl, "drawImageCursor".encode('u8'), cb_FontManagerRenderer_drawImageCursor)

   def fn_unset_FontManagerRenderer_drawImageFloat(self, targetx, targety, angsin, angcos, imageIndex, useExtColor):
      return lib.FontManagerRenderer_drawImageFloat(self.impl, targetx, targety, angsin, angcos, imageIndex, useExtColor)

   @property
   def drawImageFloat(self):
      if hasattr(self, 'fn_FontManagerRenderer_drawImageFloat'): return self.fn_FontManagerRenderer_drawImageFloat
      else: return self.fn_unset_FontManagerRenderer_drawImageFloat
   @drawImageFloat.setter
   def drawImageFloat(self, value):
      self.fn_FontManagerRenderer_drawImageFloat = value
      lib.Instance_setMethod(self.impl, "drawImageFloat".encode('u8'), cb_FontManagerRenderer_drawImageFloat)

   def fn_unset_FontManagerRenderer_flush(self):
      return lib.FontManagerRenderer_flush(self.impl)

   @property
   def flush(self):
      if hasattr(self, 'fn_FontManagerRenderer_flush'): return self.fn_FontManagerRenderer_flush
      else: return self.fn_unset_FontManagerRenderer_flush
   @flush.setter
   def flush(self, value):
      self.fn_FontManagerRenderer_flush = value
      lib.Instance_setMethod(self.impl, "flush".encode('u8'), cb_FontManagerRenderer_flush)

   def fn_unset_FontManagerRenderer_init(self, channelCount):
      return lib.FontManagerRenderer_init(self.impl, channelCount)

   @property
   def init(self):
      if hasattr(self, 'fn_FontManagerRenderer_init'): return self.fn_FontManagerRenderer_init
      else: return self.fn_unset_FontManagerRenderer_init
   @init.setter
   def init(self, value):
      self.fn_FontManagerRenderer_init = value
      lib.Instance_setMethod(self.impl, "init".encode('u8'), cb_FontManagerRenderer_init)

   def fn_unset_FontManagerRenderer_registerImage(self, offsetx, offsety, width, height):
      return lib.FontManagerRenderer_registerImage(self.impl, offsetx, offsety, width, height)

   @property
   def registerImage(self):
      if hasattr(self, 'fn_FontManagerRenderer_registerImage'): return self.fn_FontManagerRenderer_registerImage
      else: return self.fn_unset_FontManagerRenderer_registerImage
   @registerImage.setter
   def registerImage(self, value):
      self.fn_FontManagerRenderer_registerImage = value
      lib.Instance_setMethod(self.impl, "registerImage".encode('u8'), cb_FontManagerRenderer_registerImage)

   def fn_unset_FontManagerRenderer_resetImages(self):
      return lib.FontManagerRenderer_resetImages(self.impl)

   @property
   def resetImages(self):
      if hasattr(self, 'fn_FontManagerRenderer_resetImages'): return self.fn_FontManagerRenderer_resetImages
      else: return self.fn_unset_FontManagerRenderer_resetImages
   @resetImages.setter
   def resetImages(self, value):
      self.fn_FontManagerRenderer_resetImages = value
      lib.Instance_setMethod(self.impl, "resetImages".encode('u8'), cb_FontManagerRenderer_resetImages)

   def fn_unset_FontManagerRenderer_resizeTexture(self, width, height):
      return lib.FontManagerRenderer_resizeTexture(self.impl, width, height)

   @property
   def resizeTexture(self):
      if hasattr(self, 'fn_FontManagerRenderer_resizeTexture'): return self.fn_FontManagerRenderer_resizeTexture
      else: return self.fn_unset_FontManagerRenderer_resizeTexture
   @resizeTexture.setter
   def resizeTexture(self, value):
      self.fn_FontManagerRenderer_resizeTexture = value
      lib.Instance_setMethod(self.impl, "resizeTexture".encode('u8'), cb_FontManagerRenderer_resizeTexture)

   def fn_unset_FontManagerRenderer_setLayer(self, layerIndex):
      return lib.FontManagerRenderer_setLayer(self.impl, layerIndex)

   @property
   def setLayer(self):
      if hasattr(self, 'fn_FontManagerRenderer_setLayer'): return self.fn_FontManagerRenderer_setLayer
      else: return self.fn_unset_FontManagerRenderer_setLayer
   @setLayer.setter
   def setLayer(self, value):
      self.fn_FontManagerRenderer_setLayer = value
      lib.Instance_setMethod(self.impl, "setLayer".encode('u8'), cb_FontManagerRenderer_setLayer)

   def fn_unset_FontManagerRenderer_updateTexture(self, rect, data):
      if rect is None: rect = ffi.NULL
      return lib.FontManagerRenderer_updateTexture(self.impl, rect, data)

   @property
   def updateTexture(self):
      if hasattr(self, 'fn_FontManagerRenderer_updateTexture'): return self.fn_FontManagerRenderer_updateTexture
      else: return self.fn_unset_FontManagerRenderer_updateTexture
   @updateTexture.setter
   def updateTexture(self, value):
      self.fn_FontManagerRenderer_updateTexture = value
      lib.Instance_setMethod(self.impl, "updateTexture".encode('u8'), cb_FontManagerRenderer_updateTexture)

class Resource(Instance):
   class_members = []

   def init_args(self, args, kwArgs): init_args(Resource, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class Alignment:
   left   = lib.Alignment_left
   right  = lib.Alignment_right
   center = lib.Alignment_center

class AlphaWriteMode:
   dontWrite = lib.AlphaWriteMode_dontWrite
   write     = lib.AlphaWriteMode_write
   blend     = lib.AlphaWriteMode_blend

class BitmapFormat(Instance):
   class_members = []

   def init_args(self, args, kwArgs): init_args(BitmapFormat, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class BitmapResource(Resource):
   class_members = [
                      'fileName',
                      'grayed',
                      'monochrome',
                      'transparent',
                      'alphaBlend',
                      'mipMaps',
                      'keepData',
                      'bitmap',
                      'window',
                   ]

   def init_args(self, args, kwArgs): init_args(BitmapResource, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def fileName(self): value = lib.BitmapResource_get_fileName(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @fileName.setter
   def fileName(self, value):
      lib.BitmapResource_set_fileName(self.impl, value.encode('u8'))

   @property
   def grayed(self): return lib.BitmapResource_get_grayed(self.impl)
   @grayed.setter
   def grayed(self, value):
      lib.BitmapResource_set_grayed(self.impl, value)

   @property
   def monochrome(self): return lib.BitmapResource_get_monochrome(self.impl)
   @monochrome.setter
   def monochrome(self, value):
      lib.BitmapResource_set_monochrome(self.impl, value)

   @property
   def transparent(self): return lib.BitmapResource_get_transparent(self.impl)
   @transparent.setter
   def transparent(self, value):
      lib.BitmapResource_set_transparent(self.impl, value)
   # @transparent.isset # tofix: how do we get isset?
   # def transparent(self): lib.BitmapResource_isSet_transparent(self.impl)

   @property
   def alphaBlend(self): return lib.BitmapResource_get_alphaBlend(self.impl)
   @alphaBlend.setter
   def alphaBlend(self, value):
      lib.BitmapResource_set_alphaBlend(self.impl, value)
   # @alphaBlend.isset # tofix: how do we get isset?
   # def alphaBlend(self): lib.BitmapResource_isSet_alphaBlend(self.impl)

   @property
   def mipMaps(self): return lib.BitmapResource_get_mipMaps(self.impl)
   @mipMaps.setter
   def mipMaps(self, value):
      lib.BitmapResource_set_mipMaps(self.impl, value)
   # @mipMaps.isset # tofix: how do we get isset?
   # def mipMaps(self): lib.BitmapResource_isSet_mipMaps(self.impl)

   @property
   def keepData(self): return lib.BitmapResource_get_keepData(self.impl)
   @keepData.setter
   def keepData(self, value):
      lib.BitmapResource_set_keepData(self.impl, value)

   @property
   def bitmap(self): return pyOrNewObject(Bitmap, lib.BitmapResource_get_bitmap(self.impl))
   @bitmap.setter
   def bitmap(self, value):
      if not isinstance(value, Bitmap): value = Bitmap(value)
      lib.BitmapResource_set_bitmap(self.impl, value.impl)

   @property
   def window(self): return None
   @window.setter
   def window(self, value):
      if not isinstance(value, Window): value = Window(value)
      lib.BitmapResource_set_window(self.impl, value.impl)

class ClearType:
   colorBuffer   = lib.ClearType_colorBuffer
   depthBuffer   = lib.ClearType_depthBuffer
   colorAndDepth = lib.ClearType_colorAndDepth

class Color444(pyBaseClass):
   def __init__(self, r = 0, g = 0, b = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(r, Color444):
         self.impl = r.impl
      else:
         if isinstance(r, tuple):
            __tuple = r
            r = 0
            if len(__tuple) > 0: r = __tuple[0]
            if len(__tuple) > 1: g = __tuple[1]
            if len(__tuple) > 2: b = __tuple[2]
         elif isinstance(r, Color):
            self.impl = lib.Color444_from_Color(r.impl)
            return
         self.impl = (
            (r << lib.COLOR444_r_SHIFT) |
            (g << lib.COLOR444_g_SHIFT) |
            (b << lib.COLOR444_b_SHIFT) )

   @property
   def r(self): return ((((self.impl)) & lib.COLOR444_r_MASK) >> lib.COLOR444_r_SHIFT)
   @r.setter
   def r(self, value): self.impl = ((self.impl) & ~(lib.COLOR444_r_MASK)) | (((value)) << lib.COLOR444_r_SHIFT)

   @property
   def g(self): return ((((self.impl)) & lib.COLOR444_g_MASK) >> lib.COLOR444_g_SHIFT)
   @g.setter
   def g(self, value): self.impl = ((self.impl) & ~(lib.COLOR444_g_MASK)) | (((value)) << lib.COLOR444_g_SHIFT)

   @property
   def b(self): return ((((self.impl)) & lib.COLOR444_b_MASK) >> lib.COLOR444_b_SHIFT)
   @b.setter
   def b(self, value): self.impl = ((self.impl) & ~(lib.COLOR444_b_MASK)) | (((value)) << lib.COLOR444_b_SHIFT)

   # def Color444_to_Color(self): return Color(impl = lib.Color444_to_Color(self.impl))

   # here is an unhandled conversion: Color444::Color (BitClass 2 BitClass)
   # Color444_to_Color
   # Color444_from_Color

class Color555(pyBaseClass):
   def __init__(self, r = 0, g = 0, b = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(r, Color555):
         self.impl = r.impl
      else:
         if isinstance(r, tuple):
            __tuple = r
            r = 0
            if len(__tuple) > 0: r = __tuple[0]
            if len(__tuple) > 1: g = __tuple[1]
            if len(__tuple) > 2: b = __tuple[2]
         elif isinstance(r, Color):
            self.impl = lib.Color555_from_Color(r.impl)
            return
         self.impl = (
            (r << lib.COLOR555_r_SHIFT) |
            (g << lib.COLOR555_g_SHIFT) |
            (b << lib.COLOR555_b_SHIFT) )

   @property
   def r(self): return ((((self.impl)) & lib.COLOR555_r_MASK) >> lib.COLOR555_r_SHIFT)
   @r.setter
   def r(self, value): self.impl = ((self.impl) & ~(lib.COLOR555_r_MASK)) | (((value)) << lib.COLOR555_r_SHIFT)

   @property
   def g(self): return ((((self.impl)) & lib.COLOR555_g_MASK) >> lib.COLOR555_g_SHIFT)
   @g.setter
   def g(self, value): self.impl = ((self.impl) & ~(lib.COLOR555_g_MASK)) | (((value)) << lib.COLOR555_g_SHIFT)

   @property
   def b(self): return ((((self.impl)) & lib.COLOR555_b_MASK) >> lib.COLOR555_b_SHIFT)
   @b.setter
   def b(self, value): self.impl = ((self.impl) & ~(lib.COLOR555_b_MASK)) | (((value)) << lib.COLOR555_b_SHIFT)

   # def Color555_to_Color(self): return Color(impl = lib.Color555_to_Color(self.impl))

   # here is an unhandled conversion: Color555::Color (BitClass 2 BitClass)
   # Color555_to_Color
   # Color555_from_Color

class Color565(pyBaseClass):
   def __init__(self, r = 0, g = 0, b = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(r, Color565):
         self.impl = r.impl
      else:
         if isinstance(r, tuple):
            __tuple = r
            r = 0
            if len(__tuple) > 0: r = __tuple[0]
            if len(__tuple) > 1: g = __tuple[1]
            if len(__tuple) > 2: b = __tuple[2]
         elif isinstance(r, Color):
            self.impl = lib.Color565_from_Color(r.impl)
            return
         self.impl = (
            (r << lib.COLOR565_r_SHIFT) |
            (g << lib.COLOR565_g_SHIFT) |
            (b << lib.COLOR565_b_SHIFT) )

   @property
   def r(self): return ((((self.impl)) & lib.COLOR565_r_MASK) >> lib.COLOR565_r_SHIFT)
   @r.setter
   def r(self, value): self.impl = ((self.impl) & ~(lib.COLOR565_r_MASK)) | (((value)) << lib.COLOR565_r_SHIFT)

   @property
   def g(self): return ((((self.impl)) & lib.COLOR565_g_MASK) >> lib.COLOR565_g_SHIFT)
   @g.setter
   def g(self, value): self.impl = ((self.impl) & ~(lib.COLOR565_g_MASK)) | (((value)) << lib.COLOR565_g_SHIFT)

   @property
   def b(self): return ((((self.impl)) & lib.COLOR565_b_MASK) >> lib.COLOR565_b_SHIFT)
   @b.setter
   def b(self, value): self.impl = ((self.impl) & ~(lib.COLOR565_b_MASK)) | (((value)) << lib.COLOR565_b_SHIFT)

   # def Color565_to_Color(self): return Color(impl = lib.Color565_to_Color(self.impl))

   # here is an unhandled conversion: Color565::Color (BitClass 2 BitClass)
   # Color565_to_Color
   # Color565_from_Color

class ColorCMYK(Struct):
   def __init__(self, c = 0.0, m = 0.0, y = 0.0, k = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_ColorCMYK *", impl)
      else:
         if isinstance(c, tuple):
            __tuple = c
            c = 0.0
            if len(__tuple) > 0: c = __tuple[0]
            if len(__tuple) > 1: m = __tuple[1]
            if len(__tuple) > 2: y = __tuple[2]
            if len(__tuple) > 3: k = __tuple[3]
         elif isinstance(c, ColorRGB):
            self.impl = ffi.new("eC_ColorCMYK *")
            lib.ColorCMYK_from_ColorRGB(self.impl, c.impl)
            return
         self.impl = ffi.new("eC_ColorCMYK *", { 'c' : c, 'm' : m, 'y' : y, 'k' : k })

   @property
   def c(self): return self.impl.c
   @c.setter
   def c(self, value): self.impl.c = value

   @property
   def m(self): return self.impl.m
   @m.setter
   def m(self, value): self.impl.m = value

   @property
   def y(self): return self.impl.y
   @y.setter
   def y(self, value): self.impl.y = value

   @property
   def k(self): return self.impl.k
   @k.setter
   def k(self, value): self.impl.k = value

   # def ColorCMYK_to_ColorRGB(self): value = ColorRGB(); lib.ColorCMYK_to_ColorRGB(self.impl, ffi.cast("eC_ColorRGB *", value.impl)); return

   # here is an unhandled conversion: ColorCMYK::ColorRGB (StructClass 2 StructClass)
   # ColorCMYK_to_ColorRGB
   # ColorCMYK_from_ColorRGB

class ColorHSV(Struct):
   def __init__(self, h = 0, s = 0.0, v = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_ColorHSV *", impl)
      else:
         if isinstance(h, tuple):
            __tuple = h
            h = 0
            if len(__tuple) > 0: h = __tuple[0]
            if len(__tuple) > 1: s = __tuple[1]
            if len(__tuple) > 2: v = __tuple[2]
         elif isinstance(h, ColorRGB):
            self.impl = ffi.new("eC_ColorHSV *")
            lib.ColorHSV_from_ColorRGB(self.impl, h.impl)
            return
         if h is not None:
            if not isinstance(h, Angle): h = Degrees(h)
            h = h.impl
         else:
            h = Degrees()
         self.impl = ffi.new("eC_ColorHSV *", { 'h' : h, 's' : s, 'v' : v })

   @property
   def h(self): return Degrees(impl = self.impl.h)
   @h.setter
   def h(self, value):
      if not isinstance(value, Angle): value = Degrees(value)
      self.impl.h = value.impl

   @property
   def s(self): return self.impl.s
   @s.setter
   def s(self, value): self.impl.s = value

   @property
   def v(self): return self.impl.v
   @v.setter
   def v(self, value): self.impl.v = value

   # def ColorHSV_to_ColorRGB(self): value = ColorRGB(); lib.ColorHSV_to_ColorRGB(self.impl, ffi.cast("eC_ColorRGB *", value.impl)); return

   # here is an unhandled conversion: ColorHSV::ColorRGB (StructClass 2 StructClass)
   # ColorHSV_to_ColorRGB
   # ColorHSV_from_ColorRGB

class ColorKey(Struct):
   def __init__(self, color = None, percent = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_ColorKey *", impl)
      else:
         if isinstance(color, tuple):
            __tuple = color
            color = 0
            if len(__tuple) > 0: color   = __tuple[0]
            if len(__tuple) > 1: percent = __tuple[1]
         if color is not None:
            if not isinstance(color, ColorAlpha): color = ColorAlpha(color)
            color = color.impl
         else:
            color = ColorAlpha()
         self.impl = ffi.new("eC_ColorKey *", { 'color' : color, 'percent' : percent })

   @property
   def color(self): return ColorAlpha(impl = self.impl.color)
   @color.setter
   def color(self, value):
      if not isinstance(value, ColorAlpha): value = ColorAlpha(value)
      self.impl.color = value.impl

   @property
   def percent(self): return self.impl.percent
   @percent.setter
   def percent(self, value): self.impl.percent = value

class ColorLab(Struct):
   def __init__(self, l = 0.0, a = 0.0, b = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_ColorLab *", impl)
      else:
         if isinstance(l, tuple):
            __tuple = l
            l = 0.0
            if len(__tuple) > 0: l = __tuple[0]
            if len(__tuple) > 1: a = __tuple[1]
            if len(__tuple) > 2: b = __tuple[2]
         elif isinstance(l, ColorRGB):
            self.impl = ffi.new("eC_ColorLab *")
            lib.ColorLab_from_ColorRGB(self.impl, l.impl)
            return
         self.impl = ffi.new("eC_ColorLab *", { 'l' : l, 'a' : a, 'b' : b })

   @property
   def l(self): return self.impl.l
   @l.setter
   def l(self, value): self.impl.l = value

   @property
   def a(self): return self.impl.a
   @a.setter
   def a(self, value): self.impl.a = value

   @property
   def b(self): return self.impl.b
   @b.setter
   def b(self, value): self.impl.b = value

   # def ColorLab_to_ColorRGB(self): value = ColorRGB(); lib.ColorLab_to_ColorRGB(self.impl, ffi.cast("eC_ColorRGB *", value.impl)); return

   # here is an unhandled conversion: ColorLab::ColorRGB (StructClass 2 StructClass)
   # ColorLab_to_ColorRGB
   # ColorLab_from_ColorRGB

class ColorRGBAf(Struct):
   def __init__(self, r = 0.0, g = 0.0, b = 0.0, a = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_ColorRGBAf *", impl)
      else:
         if isinstance(r, tuple):
            __tuple = r
            r = 0.0
            if len(__tuple) > 0: r = __tuple[0]
            if len(__tuple) > 1: g = __tuple[1]
            if len(__tuple) > 2: b = __tuple[2]
            if len(__tuple) > 3: a = __tuple[3]
         elif isinstance(r, ColorAlpha):
            self.impl = ffi.new("eC_ColorRGBAf *")
            lib.ColorRGBAf_from_ColorAlpha(self.impl, r)
            return
         elif isinstance(r, Color):
            self.impl = ffi.new("eC_ColorRGBAf *")
            lib.ColorRGBAf_from_Color(self.impl, r)
            return
         self.impl = ffi.new("eC_ColorRGBAf *", { 'r' : r, 'g' : g, 'b' : b, 'a' : a })

   @property
   def r(self): return self.impl.r
   @r.setter
   def r(self, value): self.impl.r = value

   @property
   def g(self): return self.impl.g
   @g.setter
   def g(self, value): self.impl.g = value

   @property
   def b(self): return self.impl.b
   @b.setter
   def b(self, value): self.impl.b = value

   @property
   def a(self): return self.impl.a
   @a.setter
   def a(self, value): self.impl.a = value

   # def ColorRGBAf_to_ColorAlpha(self): return ColorAlpha(impl = lib.ColorRGBAf_to_ColorAlpha(self.impl))

   # here is an unhandled conversion: ColorRGBAf::ColorAlpha (StructClass 2 BitClass)
   # ColorRGBAf_to_ColorAlpha
   # ColorRGBAf_from_ColorAlpha

   # def ColorRGBAf_to_Color(self): return Color(impl = lib.ColorRGBAf_to_Color(self.impl))

   # here is an unhandled conversion: ColorRGBAf::Color (StructClass 2 BitClass)
   # ColorRGBAf_to_Color
   # ColorRGBAf_from_Color

class CubeMap(Bitmap):
   class_members = []

   def init_args(self, args, kwArgs): init_args(CubeMap, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def load(self, displaySystem, names, extension, oldStyle):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      if isinstance(extension, str): extension = ffi.new("char[]", extension.encode('u8'))
      elif extension is None: extension = ffi.NULL
      return lib.CubeMap_load(self.impl, displaySystem, names, extension, oldStyle)

   def loadFromFiles(self, displaySystem, files, extension, oldStyle):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      if isinstance(extension, str): extension = ffi.new("char[]", extension.encode('u8'))
      elif extension is None: extension = ffi.NULL
      return lib.CubeMap_loadFromFiles(self.impl, displaySystem, files, extension, oldStyle)

class DefinedColor(Color):
   black                = Color(impl = lib.DefinedColor_black)
   dimGray              = Color(impl = lib.DefinedColor_dimGray)
   dimGrey              = Color(impl = lib.DefinedColor_dimGrey)
   gray                 = Color(impl = lib.DefinedColor_gray)
   darkGray             = Color(impl = lib.DefinedColor_darkGray)
   darkGrey             = Color(impl = lib.DefinedColor_darkGrey)
   silver               = Color(impl = lib.DefinedColor_silver)
   lightGray            = Color(impl = lib.DefinedColor_lightGray)
   lightGrey            = Color(impl = lib.DefinedColor_lightGrey)
   gainsboro            = Color(impl = lib.DefinedColor_gainsboro)
   whiteSmoke           = Color(impl = lib.DefinedColor_whiteSmoke)
   white                = Color(impl = lib.DefinedColor_white)
   rosyBrown            = Color(impl = lib.DefinedColor_rosyBrown)
   indianRed            = Color(impl = lib.DefinedColor_indianRed)
   brown                = Color(impl = lib.DefinedColor_brown)
   fireBrick            = Color(impl = lib.DefinedColor_fireBrick)
   lightCoral           = Color(impl = lib.DefinedColor_lightCoral)
   maroon               = Color(impl = lib.DefinedColor_maroon)
   darkRed              = Color(impl = lib.DefinedColor_darkRed)
   red                  = Color(impl = lib.DefinedColor_red)
   snow                 = Color(impl = lib.DefinedColor_snow)
   mistyRose            = Color(impl = lib.DefinedColor_mistyRose)
   salmon               = Color(impl = lib.DefinedColor_salmon)
   tomato               = Color(impl = lib.DefinedColor_tomato)
   darkSalmon           = Color(impl = lib.DefinedColor_darkSalmon)
   coral                = Color(impl = lib.DefinedColor_coral)
   orangeRed            = Color(impl = lib.DefinedColor_orangeRed)
   lightSalmon          = Color(impl = lib.DefinedColor_lightSalmon)
   sienna               = Color(impl = lib.DefinedColor_sienna)
   seaShell             = Color(impl = lib.DefinedColor_seaShell)
   chocolate            = Color(impl = lib.DefinedColor_chocolate)
   saddleBrown          = Color(impl = lib.DefinedColor_saddleBrown)
   sandyBrown           = Color(impl = lib.DefinedColor_sandyBrown)
   peachPuff            = Color(impl = lib.DefinedColor_peachPuff)
   peru                 = Color(impl = lib.DefinedColor_peru)
   linen                = Color(impl = lib.DefinedColor_linen)
   bisque               = Color(impl = lib.DefinedColor_bisque)
   darkOrange           = Color(impl = lib.DefinedColor_darkOrange)
   burlyWood            = Color(impl = lib.DefinedColor_burlyWood)
   tan                  = Color(impl = lib.DefinedColor_tan)
   antiqueWhite         = Color(impl = lib.DefinedColor_antiqueWhite)
   navajoWhite          = Color(impl = lib.DefinedColor_navajoWhite)
   blanchedAlmond       = Color(impl = lib.DefinedColor_blanchedAlmond)
   papayaWhip           = Color(impl = lib.DefinedColor_papayaWhip)
   mocassin             = Color(impl = lib.DefinedColor_mocassin)
   moccasin             = Color(impl = lib.DefinedColor_moccasin)
   orange               = Color(impl = lib.DefinedColor_orange)
   wheat                = Color(impl = lib.DefinedColor_wheat)
   oldLace              = Color(impl = lib.DefinedColor_oldLace)
   floralWhite          = Color(impl = lib.DefinedColor_floralWhite)
   darkGoldenrod        = Color(impl = lib.DefinedColor_darkGoldenrod)
   goldenrod            = Color(impl = lib.DefinedColor_goldenrod)
   cornsilk             = Color(impl = lib.DefinedColor_cornsilk)
   gold                 = Color(impl = lib.DefinedColor_gold)
   khaki                = Color(impl = lib.DefinedColor_khaki)
   lemonChiffon         = Color(impl = lib.DefinedColor_lemonChiffon)
   paleGoldenrod        = Color(impl = lib.DefinedColor_paleGoldenrod)
   darkKhaki            = Color(impl = lib.DefinedColor_darkKhaki)
   beige                = Color(impl = lib.DefinedColor_beige)
   lightGoldenRodYellow = Color(impl = lib.DefinedColor_lightGoldenRodYellow)
   olive                = Color(impl = lib.DefinedColor_olive)
   yellow               = Color(impl = lib.DefinedColor_yellow)
   lightYellow          = Color(impl = lib.DefinedColor_lightYellow)
   ivory                = Color(impl = lib.DefinedColor_ivory)
   oliveDrab            = Color(impl = lib.DefinedColor_oliveDrab)
   yellowGreen          = Color(impl = lib.DefinedColor_yellowGreen)
   darkOliveGreen       = Color(impl = lib.DefinedColor_darkOliveGreen)
   greenYellow          = Color(impl = lib.DefinedColor_greenYellow)
   chartreuse           = Color(impl = lib.DefinedColor_chartreuse)
   lawnGreen            = Color(impl = lib.DefinedColor_lawnGreen)
   darkSeaGreen         = Color(impl = lib.DefinedColor_darkSeaGreen)
   forestGreen          = Color(impl = lib.DefinedColor_forestGreen)
   limeGreen            = Color(impl = lib.DefinedColor_limeGreen)
   lightGreen           = Color(impl = lib.DefinedColor_lightGreen)
   paleGreen            = Color(impl = lib.DefinedColor_paleGreen)
   darkGreen            = Color(impl = lib.DefinedColor_darkGreen)
   green                = Color(impl = lib.DefinedColor_green)
   lime                 = Color(impl = lib.DefinedColor_lime)
   honeyDew             = Color(impl = lib.DefinedColor_honeyDew)
   seaGreen             = Color(impl = lib.DefinedColor_seaGreen)
   mediumSeaGreen       = Color(impl = lib.DefinedColor_mediumSeaGreen)
   springGreen          = Color(impl = lib.DefinedColor_springGreen)
   mintCream            = Color(impl = lib.DefinedColor_mintCream)
   mediumSpringGreen    = Color(impl = lib.DefinedColor_mediumSpringGreen)
   mediumAquaMarine     = Color(impl = lib.DefinedColor_mediumAquaMarine)
   aquamarine           = Color(impl = lib.DefinedColor_aquamarine)
   turquoise            = Color(impl = lib.DefinedColor_turquoise)
   lightSeaGreen        = Color(impl = lib.DefinedColor_lightSeaGreen)
   mediumTurquoise      = Color(impl = lib.DefinedColor_mediumTurquoise)
   darkSlateGray        = Color(impl = lib.DefinedColor_darkSlateGray)
   darkSlateGrey        = Color(impl = lib.DefinedColor_darkSlateGrey)
   paleTurquoise        = Color(impl = lib.DefinedColor_paleTurquoise)
   teal                 = Color(impl = lib.DefinedColor_teal)
   darkCyan             = Color(impl = lib.DefinedColor_darkCyan)
   aqua                 = Color(impl = lib.DefinedColor_aqua)
   cyan                 = Color(impl = lib.DefinedColor_cyan)
   lightCyan            = Color(impl = lib.DefinedColor_lightCyan)
   azure                = Color(impl = lib.DefinedColor_azure)
   darkTurquoise        = Color(impl = lib.DefinedColor_darkTurquoise)
   cadetBlue            = Color(impl = lib.DefinedColor_cadetBlue)
   powderBlue           = Color(impl = lib.DefinedColor_powderBlue)
   lightBlue            = Color(impl = lib.DefinedColor_lightBlue)
   deepSkyBlue          = Color(impl = lib.DefinedColor_deepSkyBlue)
   skyBlue              = Color(impl = lib.DefinedColor_skyBlue)
   lightSkyBlue         = Color(impl = lib.DefinedColor_lightSkyBlue)
   steelBlue            = Color(impl = lib.DefinedColor_steelBlue)
   aliceBlue            = Color(impl = lib.DefinedColor_aliceBlue)
   dodgerBlue           = Color(impl = lib.DefinedColor_dodgerBlue)
   slateGray            = Color(impl = lib.DefinedColor_slateGray)
   slateGrey            = Color(impl = lib.DefinedColor_slateGrey)
   lightSlateGray       = Color(impl = lib.DefinedColor_lightSlateGray)
   lightSlateGrey       = Color(impl = lib.DefinedColor_lightSlateGrey)
   lightSteelBlue       = Color(impl = lib.DefinedColor_lightSteelBlue)
   cornflowerBlue       = Color(impl = lib.DefinedColor_cornflowerBlue)
   royalBlue            = Color(impl = lib.DefinedColor_royalBlue)
   midnightBlue         = Color(impl = lib.DefinedColor_midnightBlue)
   lavender             = Color(impl = lib.DefinedColor_lavender)
   navy                 = Color(impl = lib.DefinedColor_navy)
   darkBlue             = Color(impl = lib.DefinedColor_darkBlue)
   mediumBlue           = Color(impl = lib.DefinedColor_mediumBlue)
   blue                 = Color(impl = lib.DefinedColor_blue)
   ghostWhite           = Color(impl = lib.DefinedColor_ghostWhite)
   slateBlue            = Color(impl = lib.DefinedColor_slateBlue)
   darkSlateBlue        = Color(impl = lib.DefinedColor_darkSlateBlue)
   mediumSlateBlue      = Color(impl = lib.DefinedColor_mediumSlateBlue)
   mediumPurple         = Color(impl = lib.DefinedColor_mediumPurple)
   blueViolet           = Color(impl = lib.DefinedColor_blueViolet)
   indigo               = Color(impl = lib.DefinedColor_indigo)
   darkOrchid           = Color(impl = lib.DefinedColor_darkOrchid)
   darkViolet           = Color(impl = lib.DefinedColor_darkViolet)
   mediumOrchid         = Color(impl = lib.DefinedColor_mediumOrchid)
   thistle              = Color(impl = lib.DefinedColor_thistle)
   plum                 = Color(impl = lib.DefinedColor_plum)
   violet               = Color(impl = lib.DefinedColor_violet)
   purple               = Color(impl = lib.DefinedColor_purple)
   darkMagenta          = Color(impl = lib.DefinedColor_darkMagenta)
   magenta              = Color(impl = lib.DefinedColor_magenta)
   fuschia              = Color(impl = lib.DefinedColor_fuschia)
   orchid               = Color(impl = lib.DefinedColor_orchid)
   mediumVioletRed      = Color(impl = lib.DefinedColor_mediumVioletRed)
   deepPink             = Color(impl = lib.DefinedColor_deepPink)
   hotPink              = Color(impl = lib.DefinedColor_hotPink)
   lavenderBlush        = Color(impl = lib.DefinedColor_lavenderBlush)
   paleVioletRed        = Color(impl = lib.DefinedColor_paleVioletRed)
   crimson              = Color(impl = lib.DefinedColor_crimson)
   pink                 = Color(impl = lib.DefinedColor_pink)
   lightPink            = Color(impl = lib.DefinedColor_lightPink)

class Display(Instance):
   class_members = [
                      'fillMode',
                      'depthTest',
                      'depthWrite',
                      'fogDensity',
                      'fogColor',
                      'blend',
                      'ambient',
                      'alphaWrite',
                      'antiAlias',
                      'vSync',
                      'pickingPlanes',
                      'maxFullSort',
                      'fullProjCheck',
                      'flags',
                      'pixelFormat',
                      'alphaBlend',
                      'useSharedMemory',
                      'systemWindow',
                      'displaySystem',
                      'glCapabilities',
                      'glVersion',
                      'width',
                      'height',
                      'driverData',
                   ]

   def init_args(self, args, kwArgs): init_args(Display, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def fillMode(self): return None
   @fillMode.setter
   def fillMode(self, value):
      lib.Display_set_fillMode(self.impl, value)

   @property
   def depthTest(self): return None
   @depthTest.setter
   def depthTest(self, value):
      lib.Display_set_depthTest(self.impl, value)

   @property
   def depthWrite(self): return None
   @depthWrite.setter
   def depthWrite(self, value):
      lib.Display_set_depthWrite(self.impl, value)

   @property
   def fogDensity(self): return None
   @fogDensity.setter
   def fogDensity(self, value):
      lib.Display_set_fogDensity(self.impl, value)

   @property
   def fogColor(self): return None
   @fogColor.setter
   def fogColor(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.Display_set_fogColor(self.impl, value.impl)

   @property
   def blend(self): return None
   @blend.setter
   def blend(self, value):
      lib.Display_set_blend(self.impl, value)

   @property
   def ambient(self): return None
   @ambient.setter
   def ambient(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.Display_set_ambient(self.impl, value.impl)

   @property
   def alphaWrite(self): return None
   @alphaWrite.setter
   def alphaWrite(self, value):
      lib.Display_set_alphaWrite(self.impl, value)

   @property
   def antiAlias(self): return None
   @antiAlias.setter
   def antiAlias(self, value):
      lib.Display_set_antiAlias(self.impl, value)

   @property
   def vSync(self): return None
   @vSync.setter
   def vSync(self, value):
      lib.Display_set_vSync(self.impl, value)

   @property
   def pickingPlanes(self): return None
   @pickingPlanes.setter
   def pickingPlanes(self, value):
      lib.Display_set_pickingPlanes(self.impl, value)

   @property
   def maxFullSort(self): return lib.Display_get_maxFullSort(self.impl)
   @maxFullSort.setter
   def maxFullSort(self, value):
      lib.Display_set_maxFullSort(self.impl, value)

   @property
   def fullProjCheck(self): return lib.Display_get_fullProjCheck(self.impl)
   @fullProjCheck.setter
   def fullProjCheck(self, value):
      lib.Display_set_fullProjCheck(self.impl, value)

   @property
   def flags(self): return DisplayFlags(impl = lib.Display_get_flags(self.impl))

   @property
   def pixelFormat(self): return lib.Display_get_pixelFormat(self.impl)

   @property
   def alphaBlend(self): return lib.Display_get_alphaBlend(self.impl)
   @alphaBlend.setter
   def alphaBlend(self, value):
      lib.Display_set_alphaBlend(self.impl, value)

   @property
   def useSharedMemory(self): return lib.Display_get_useSharedMemory(self.impl)
   @useSharedMemory.setter
   def useSharedMemory(self, value):
      lib.Display_set_useSharedMemory(self.impl, value)

   @property
   def systemWindow(self): return lib.Display_get_systemWindow(self.impl)

   @property
   def displaySystem(self): return pyOrNewObject(DisplaySystem, lib.Display_get_displaySystem(self.impl))

   @property
   def glCapabilities(self): return GLCapabilities(impl = lib.Display_get_glCapabilities(self.impl))
   @glCapabilities.setter
   def glCapabilities(self, value):
      if not isinstance(value, GLCapabilities): value = GLCapabilities(value)
      lib.Display_set_glCapabilities(self.impl, value.impl)

   @property
   def glVersion(self): return lib.Display_get_glVersion(self.impl)

   @property
   def width(self): return IPTR(lib, ffi, self, Display).width
   @width.setter
   def width(self, value): IPTR(lib, ffi, self, Display).width = value

   @property
   def height(self): return IPTR(lib, ffi, self, Display).height
   @height.setter
   def height(self, value): IPTR(lib, ffi, self, Display).height = value

   @property
   def driverData(self): return IPTR(lib, ffi, self, Display).driverData
   @driverData.setter
   def driverData(self, value): IPTR(lib, ffi, self, Display).driverData = value

   def applyMaterial(self, material = None, mesh = None):
      if material is not None and not isinstance(material, Material): material = Material(material)
      material = ffi.NULL if material is None else material.impl
      if mesh is not None and not isinstance(mesh, Mesh): mesh = Mesh(mesh)
      mesh = ffi.NULL if mesh is None else mesh.impl
      lib.Display_applyMaterial(self.impl, ffi.cast("struct eC_Material *", material), ffi.cast("struct eC_Mesh *", mesh))

   def collectHits(self):
      lib.Display_collectHits(self.impl)

   def create(self, displaySystem, window):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      if hasattr(window, 'impl'): window = window.impl
      if window is None: window = ffi.NULL
      return lib.Display_create(self.impl, displaySystem, window)

   def drawMesh(self, object = None):
      if object is not None and not isinstance(object, Object): object = Object(object)
      object = ffi.NULL if object is None else object.impl
      return lib.Display_drawMesh(self.impl, ffi.cast("struct eC_Object *", object))

   def drawMeshEx(self, object = None):
      if object is not None and not isinstance(object, Object): object = Object(object)
      object = ffi.NULL if object is None else object.impl
      id = ffi.new("uint64 *")
      r = lib.Display_drawMeshEx(self.impl, ffi.cast("struct eC_Object *", object), id)
      return r, id[0]

   def drawObject(self, object = None):
      if object is not None and not isinstance(object, Object): object = Object(object)
      object = ffi.NULL if object is None else object.impl
      return lib.Display_drawObject(self.impl, ffi.cast("struct eC_Object *", object))

   def drawObjectEx(self, object = None):
      if object is not None and not isinstance(object, Object): object = Object(object)
      object = ffi.NULL if object is None else object.impl
      id = ffi.new("uint64 *")
      r = lib.Display_drawObjectEx(self.impl, ffi.cast("struct eC_Object *", object), id)
      return r, id[0]

   def drawPrimitives(self, primitive = None, mesh = None):
      if primitive is not None and not isinstance(primitive, PrimitiveSingle): primitive = PrimitiveSingle(primitive)
      primitive = ffi.NULL if primitive is None else primitive.impl
      if mesh is not None and not isinstance(mesh, Mesh): mesh = Mesh(mesh)
      mesh = ffi.NULL if mesh is None else mesh.impl
      lib.Display_drawPrimitives(self.impl, ffi.cast("eC_PrimitiveSingle *", primitive), ffi.cast("struct eC_Mesh *", mesh))

   def drawTranslucency(self):
      lib.Display_drawTranslucency(self.impl)

   def endUpdate(self):
      lib.Display_endUpdate(self.impl)

   def fontExtent(self, font, text, len):
      if font is not None and not isinstance(font, Font): font = Font(font)
      font = ffi.NULL if font is None else font.impl
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      width = ffi.new("int *")
      height = ffi.new("int *")
      lib.Display_fontExtent(self.impl, ffi.cast("struct eC_Font *", font), text, len, width, height)
      return width[0], height[0]

   def fontExtent2(self, font, text, len, prevGlyph):
      if font is not None and not isinstance(font, Font): font = Font(font)
      font = ffi.NULL if font is None else font.impl
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      width = ffi.new("int *")
      height = ffi.new("int *")
      rPrevGlyph = ffi.new("int *")
      overHang = ffi.new("int *")
      lib.Display_fontExtent2(self.impl, ffi.cast("struct eC_Font *", font), text, len, width, height, prevGlyph, rPrevGlyph, overHang)
      return width[0], height[0], rPrevGlyph[0], overHang[0]

   def getHits(self, list = None):
      if list is not None and not isinstance(list, OldList): list = OldList(list)
      list = ffi.NULL if list is None else list.impl
      return lib.Display_getHits(self.impl, ffi.cast("eC_OldList *", list))

   def getIntersect(self, intersect = None):
      if intersect is not None and not isinstance(intersect, Vector3D): intersect = Vector3D(intersect)
      intersect = ffi.NULL if intersect is None else intersect.impl
      return lib.Display_getIntersect(self.impl, ffi.cast("eC_Vector3D *", intersect))

   def getSurface(self, x, y, clip = None):
      if clip is not None and not isinstance(clip, Box): clip = Box(clip)
      clip = ffi.NULL if clip is None else clip.impl
      return pyOrNewObject(Surface, lib.Display_getSurface(self.impl, x, y, ffi.cast("eC_Box *", clip)))

   def grab(self, bitmap, x, y, w, h):
      if bitmap is not None and not isinstance(bitmap, Bitmap): bitmap = Bitmap(bitmap)
      bitmap = ffi.NULL if bitmap is None else bitmap.impl
      return lib.Display_grab(self.impl, bitmap, x, y, w, h)

   def intersectPolygons(self):
      lib.Display_intersectPolygons(self.impl)

   def isObjectVisible(self, object = None):
      if object is not None and not isinstance(object, Object): object = Object(object)
      object = ffi.NULL if object is None else object.impl
      return lib.Display_isObjectVisible(self.impl, ffi.cast("struct eC_Object *", object))

   def lock(self, render):
      return lib.Display_lock(self.impl, render)

   def nextPage(self):
      lib.Display_nextPage(self.impl)

   def popMatrix(self):
      lib.Display_popMatrix(self.impl)

   def position(self, x, y):
      lib.Display_position(self.impl, x, y)

   def pushMatrix(self):
      lib.Display_pushMatrix(self.impl)

   def resize(self, width, height):
      return lib.Display_resize(self.impl, width, height)

   def restorePalette(self):
      lib.Display_restorePalette(self.impl)

   def scroll(self, scroll, x, y, dirty = None):
      if scroll is not None and not isinstance(scroll, Box): scroll = Box(scroll)
      scroll = ffi.NULL if scroll is None else scroll.impl
      if dirty is not None and not isinstance(dirty, Extent): dirty = Extent(dirty)
      dirty = ffi.NULL if dirty is None else dirty.impl
      lib.Display_scroll(self.impl, ffi.cast("eC_Box *", scroll), x, y, ffi.cast("eC_Extent *", dirty))

   def selectMesh(self, mesh = None):
      if mesh is not None and not isinstance(mesh, Mesh): mesh = Mesh(mesh)
      mesh = ffi.NULL if mesh is None else mesh.impl
      lib.Display_selectMesh(self.impl, ffi.cast("struct eC_Mesh *", mesh))

   def setCamera(self, surface = None, camera = None):
      if surface is not None and not isinstance(surface, Surface): surface = Surface(surface)
      surface = ffi.NULL if surface is None else surface.impl
      if camera is not None and not isinstance(camera, Camera): camera = Camera(camera)
      camera = ffi.NULL if camera is None else camera.impl
      lib.Display_setCamera(self.impl, surface, camera)

   def setCameraVR(self, camera, eye, w, h, output = None, prjMat = None):
      if camera is not None and not isinstance(camera, Camera): camera = Camera(camera)
      camera = ffi.NULL if camera is None else camera.impl
      if output is not None and not isinstance(output, GLFB): output = GLFB(output)
      output = ffi.NULL if output is None else output.impl
      if prjMat is not None and not isinstance(prjMat, Matrix): prjMat = Matrix(prjMat)
      prjMat = ffi.NULL if prjMat is None else prjMat.impl
      lib.Display_setCameraVR(self.impl, camera, eye, w, h, ffi.cast("eC_GLFB *", output), ffi.cast("eC_Matrix *", prjMat))

   def setLight(self, id, light = None):
      if light is not None and not isinstance(light, Light): light = Light(light)
      light = ffi.NULL if light is None else light.impl
      lib.Display_setLight(self.impl, id, ffi.cast("eC_Light *", light))

   def setLights(self, object = None):
      if object is not None and not isinstance(object, Object): object = Object(object)
      object = ffi.NULL if object is None else object.impl
      lib.Display_setLights(self.impl, ffi.cast("struct eC_Object *", object))

   def setPalette(self, colorMatch):
      palette = ffi.new("eC_ColorAlpha *")
      lib.Display_setPalette(self.impl, palette, colorMatch)
      return ColorAlpha(impl = palette[0])

   def setTransform(self, matrix, viewSpace):
      if matrix is not None and not isinstance(matrix, Matrix): matrix = Matrix(matrix)
      matrix = ffi.NULL if matrix is None else matrix.impl
      lib.Display_setTransform(self.impl, ffi.cast("eC_Matrix *", matrix), viewSpace)

   def startSelection(self, pickX, pickY, pickW, pickH):
      lib.Display_startSelection(self.impl, pickX, pickY, pickW, pickH)

   def startUpdate(self):
      lib.Display_startUpdate(self.impl)

   def stopSelection(self):
      lib.Display_stopSelection(self.impl)

   def unlock(self):
      lib.Display_unlock(self.impl)

   def update(self, updateBox = None):
      if updateBox is not None and not isinstance(updateBox, Box): updateBox = Box(updateBox)
      updateBox = ffi.NULL if updateBox is None else updateBox.impl
      lib.Display_update(self.impl, ffi.cast("eC_Box *", updateBox))

@ffi.callback("eC_bool(eC_DisplayDriver, eC_DisplaySystem, eC_Bitmap, int, int, int, eC_PixelFormat, eC_bool)")
def cb_DisplayDriver_allocateBitmap(__e, ap1, ap2, ap3, ap4, ap5, ap6, ap7):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_allocateBitmap(displaydriver, pyOrNewObject(DisplaySystem, ap1), pyOrNewObject(Bitmap, ap2), ap3, ap4, ap5, PixelFormat(impl = ap6), ap7)

@ffi.callback("void * *(eC_DisplayDriver, eC_DisplaySystem, int, eC_bool)")
def cb_DisplayDriver_allocateIndices(__e, ap1, nIndices, indices32bit):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_allocateIndices(displaydriver, pyOrNewObject(DisplaySystem, ap1), nIndices, indices32bit)

@ffi.callback("eC_bool(eC_DisplayDriver, eC_DisplaySystem, eC_Mesh *, eC_MeshFeatures, int)")
def cb_DisplayDriver_allocateMesh(__e, ap1, ap2, ap3, nVertices):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_allocateMesh(displaydriver, pyOrNewObject(DisplaySystem, ap1), Mesh(impl = ap2), MeshFeatures(impl = ap3), nVertices)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Material *, eC_Mesh *)")
def cb_DisplayDriver_applyMaterial(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_applyMaterial(displaydriver, pyOrNewObject(Display, ap1), Material(impl = ap2), Mesh(impl = ap3))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, int, int, int, int)")
def cb_DisplayDriver_area(__e, ap1, ap2, x1, y1, x2, y2):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_area(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), x1, y1, x2, y2)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_Bitmap, int, int, int, int, int, int)")
def cb_DisplayDriver_blit(__e, ap1, ap2, ap3, dx, dy, sx, sy, w, h):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_blit(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), pyOrNewObject(Bitmap, ap3), dx, dy, sx, sy, w, h)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_Bitmap, int, int, int, int, int, int)")
def cb_DisplayDriver_blitDI(__e, ap1, ap2, ap3, dx, dy, sx, sy, w, h):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_blitDI(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), pyOrNewObject(Bitmap, ap3), dx, dy, sx, sy, w, h)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_ClearType)")
def cb_DisplayDriver_clear(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_clear(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), ClearType(impl = ap3))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_Box *)")
def cb_DisplayDriver_clip(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_clip(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), Box(impl = ap3))

@ffi.callback("eC_bool(eC_DisplayDriver, eC_DisplaySystem, eC_Bitmap, eC_PixelFormat, eC_ColorAlpha *)")
def cb_DisplayDriver_convertBitmap(__e, ap1, ap2, ap3, ap4):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_convertBitmap(displaydriver, pyOrNewObject(DisplaySystem, ap1), pyOrNewObject(Bitmap, ap2), PixelFormat(impl = ap3), ap4)

@ffi.callback("eC_bool(eC_DisplayDriver, eC_Display)")
def cb_DisplayDriver_createDisplay(__e, ap1):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_createDisplay(displaydriver, pyOrNewObject(Display, ap1))

@ffi.callback("eC_bool(eC_DisplayDriver, eC_DisplaySystem)")
def cb_DisplayDriver_createDisplaySystem(__e, ap1):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_createDisplaySystem(displaydriver, pyOrNewObject(DisplaySystem, ap1))

@ffi.callback("void(eC_DisplayDriver, eC_Display)")
def cb_DisplayDriver_destroyDisplay(__e, ap1):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_destroyDisplay(displaydriver, pyOrNewObject(Display, ap1))

@ffi.callback("void(eC_DisplayDriver, eC_DisplaySystem)")
def cb_DisplayDriver_destroyDisplaySystem(__e, ap1):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_destroyDisplaySystem(displaydriver, pyOrNewObject(DisplaySystem, ap1))

@ffi.callback("void(eC_DisplayDriver, eC_Display, int, int)")
def cb_DisplayDriver_displayPosition(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_displayPosition(displaydriver, pyOrNewObject(Display, ap1), ap2, ap3)

@ffi.callback("eC_bool(eC_DisplayDriver, eC_Display, int, int)")
def cb_DisplayDriver_displaySize(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_displaySize(displaydriver, pyOrNewObject(Display, ap1), ap2, ap3)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, int, int, int, int)")
def cb_DisplayDriver_drawLine(__e, ap1, ap2, x1, y1, x2, y2):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_drawLine(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), x1, y1, x2, y2)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_PrimitiveSingle *, eC_Mesh *)")
def cb_DisplayDriver_drawPrimitives(__e, ap1, ap2, mesh):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_drawPrimitives(displaydriver, pyOrNewObject(Display, ap1), PrimitiveSingle(impl = ap2), Mesh(impl = mesh))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, char)")
def cb_DisplayDriver_drawingChar(__e, ap1, ap2, ch):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_drawingChar(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), ch)

@ffi.callback("void(eC_DisplayDriver, eC_Display)")
def cb_DisplayDriver_endUpdate(__e, ap1):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_endUpdate(displaydriver, pyOrNewObject(Display, ap1))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_Bitmap, int, int, int, int, int, int, int, int)")
def cb_DisplayDriver_filter(__e, ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_filter(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), pyOrNewObject(Bitmap, ap3), dx, dy, sx, sy, w, h, sw, sh)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_Bitmap, int, int, int, int, int, int, int, int)")
def cb_DisplayDriver_filterDI(__e, ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_filterDI(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), pyOrNewObject(Bitmap, ap3), dx, dy, sx, sy, w, h, sw, sh)

@ffi.callback("void(eC_DisplayDriver, eC_DisplaySystem, eC_Font *, constString, int, int *, int *, int, int *, int *)")
def cb_DisplayDriver_fontExtent(__e, ap1, ap2, text, len, tw, th, prevGlyph, rPrevGlyph, overHang):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_fontExtent(displaydriver, pyOrNewObject(DisplaySystem, ap1), Font(impl = ap2), text, len, tw, th, prevGlyph, rPrevGlyph, overHang)

@ffi.callback("void(eC_DisplayDriver, eC_DisplaySystem, eC_Bitmap)")
def cb_DisplayDriver_freeBitmap(__e, ap1, ap2):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_freeBitmap(displaydriver, pyOrNewObject(DisplaySystem, ap1), pyOrNewObject(Bitmap, ap2))

@ffi.callback("void(eC_DisplayDriver, eC_DisplaySystem, eC_PrimitiveSingle *)")
def cb_DisplayDriver_freeIndices(__e, ap1, group):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_freeIndices(displaydriver, pyOrNewObject(DisplaySystem, ap1), PrimitiveSingle(impl = group))

@ffi.callback("void(eC_DisplayDriver, eC_DisplaySystem, eC_Mesh *)")
def cb_DisplayDriver_freeMesh(__e, ap1, ap2):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_freeMesh(displaydriver, pyOrNewObject(DisplaySystem, ap1), Mesh(impl = ap2))

@ffi.callback("eC_bool(eC_DisplayDriver, eC_DisplaySystem, eC_Surface, eC_Bitmap, int, int, eC_Box *)")
def cb_DisplayDriver_getBitmapSurface(__e, displaySystem, surface, bitmap, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_getBitmapSurface(displaydriver, pyOrNewObject(DisplaySystem, displaySystem), pyOrNewObject(Surface, surface), pyOrNewObject(Bitmap, bitmap), ap1, ap2, Box(impl = ap3))

@ffi.callback("eC_ColorAlpha(eC_DisplayDriver, eC_Display, eC_Surface, int, int)")
def cb_DisplayDriver_getPixel(__e, ap1, ap2, x, y):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_getPixel(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), x, y)

@ffi.callback("eC_bool(eC_DisplayDriver, eC_Display, eC_Surface, int, int, eC_Box *)")
def cb_DisplayDriver_getSurface(__e, ap1, surface, ap2, ap3, ap4):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_getSurface(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, surface), ap2, ap3, Box(impl = ap4))

@ffi.callback("eC_bool(eC_DisplayDriver, eC_Display, eC_Bitmap, int, int, uint, uint)")
def cb_DisplayDriver_grabScreen(__e, ap1, ap2, ap3, ap4, ap5, ap6):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_grabScreen(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Bitmap, ap2), ap3, ap4, ap5, ap6)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, uint)")
def cb_DisplayDriver_lineStipple(__e, ap1, ap2, pattern):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_lineStipple(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), pattern)

@ffi.callback("eC_Font *(eC_DisplayDriver, eC_DisplaySystem, const char *, float, eC_FontFlags, float, float)")
def cb_DisplayDriver_loadFont(__e, displaySystem, faceName, size, flags, outlineSize, outlineFade):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_loadFont(displaydriver, pyOrNewObject(DisplaySystem, displaySystem), faceName.encode('u8'), size, FontFlags(impl = flags), outlineSize, outlineFade)

@ffi.callback("eC_bool(eC_DisplayDriver, eC_Display)")
def cb_DisplayDriver_lock(__e, ap1):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_lock(displaydriver, pyOrNewObject(Display, ap1))

@ffi.callback("uint16 * *(eC_DisplayDriver, eC_DisplaySystem, eC_PrimitiveSingle *)")
def cb_DisplayDriver_lockIndices(__e, ap1, group):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_lockIndices(displaydriver, pyOrNewObject(DisplaySystem, ap1), PrimitiveSingle(impl = group))

@ffi.callback("eC_bool(eC_DisplayDriver, eC_DisplaySystem, eC_Mesh *, eC_MeshFeatures)")
def cb_DisplayDriver_lockMesh(__e, ap1, ap2, flags):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_lockMesh(displaydriver, pyOrNewObject(DisplaySystem, ap1), Mesh(impl = ap2), MeshFeatures(impl = flags))

@ffi.callback("eC_bool(eC_DisplayDriver, eC_DisplaySystem)")
def cb_DisplayDriver_lockSystem(__e, displaySystem):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_lockSystem(displaydriver, pyOrNewObject(DisplaySystem, displaySystem))

@ffi.callback("eC_bool(eC_DisplayDriver, eC_DisplaySystem, eC_Bitmap, eC_bool, int)")
def cb_DisplayDriver_makeDDBitmap(__e, ap1, ap2, mipMaps, cubeMapFace):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   return displaydriver.fn_DisplayDriver_makeDDBitmap(displaydriver, pyOrNewObject(DisplaySystem, ap1), pyOrNewObject(Bitmap, ap2), mipMaps, cubeMapFace)

@ffi.callback("void(eC_DisplayDriver, eC_Display)")
def cb_DisplayDriver_nextPage(__e, ap1):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_nextPage(displaydriver, pyOrNewObject(Display, ap1))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_bool)")
def cb_DisplayDriver_popMatrix(__e, ap1, ap2):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_popMatrix(displaydriver, pyOrNewObject(Display, ap1), ap2)

@ffi.callback("void(eC_DisplayDriver, eC_Display)")
def cb_DisplayDriver_pushMatrix(__e, ap1):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_pushMatrix(displaydriver, pyOrNewObject(Display, ap1))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, int, int)")
def cb_DisplayDriver_putPixel(__e, ap1, ap2, x, y):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_putPixel(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), x, y)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, int, int, int, int)")
def cb_DisplayDriver_rectangle(__e, ap1, ap2, x1, y1, x2, y2):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_rectangle(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), x1, y1, x2, y2)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface)")
def cb_DisplayDriver_releaseSurface(__e, this, ap1):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_releaseSurface(displaydriver, pyOrNewObject(Display, this), pyOrNewObject(Surface, ap1))

@ffi.callback("void(eC_DisplayDriver, eC_Display)")
def cb_DisplayDriver_restorePalette(__e, ap1):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_restorePalette(displaydriver, pyOrNewObject(Display, ap1))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Box *, int, int, eC_Extent *)")
def cb_DisplayDriver_scroll(__e, ap1, ap2, ap3, ap4, ap5):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_scroll(displaydriver, pyOrNewObject(Display, ap1), Box(impl = ap2), ap3, ap4, Extent(impl = ap5))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Mesh *)")
def cb_DisplayDriver_selectMesh(__e, ap1, ap2):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_selectMesh(displaydriver, pyOrNewObject(Display, ap1), Mesh(impl = ap2))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_ColorAlpha)")
def cb_DisplayDriver_setBackground(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_setBackground(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), ColorAlpha(impl = ap3))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_ColorAlpha)")
def cb_DisplayDriver_setBlitTint(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_setBlitTint(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), ColorAlpha(impl = ap3))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_Camera)")
def cb_DisplayDriver_setCamera(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_setCamera(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), pyOrNewObject(Camera, ap3))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Camera, int, int, int, void *, const eC_Matrix *)")
def cb_DisplayDriver_setCameraVR(__e, ap1, ap2, eye, w, h, fb, prjMat):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_setCameraVR(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Camera, ap2), eye, w, h, fb, Matrix(impl = prjMat))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_ColorAlpha)")
def cb_DisplayDriver_setForeground(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_setForeground(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), ColorAlpha(impl = ap3))

@ffi.callback("void(eC_DisplayDriver, eC_Display, int, eC_Light *)")
def cb_DisplayDriver_setLight(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_setLight(displaydriver, pyOrNewObject(Display, ap1), ap2, Light(impl = ap3))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_ColorAlpha *, eC_bool)")
def cb_DisplayDriver_setPalette(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_setPalette(displaydriver, pyOrNewObject(Display, ap1), ap2, ap3)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_RenderState, uint)")
def cb_DisplayDriver_setRenderState(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_setRenderState(displaydriver, pyOrNewObject(Display, ap1), RenderState(impl = ap2), ap3)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Matrix *, eC_bool, eC_bool)")
def cb_DisplayDriver_setTransform(__e, ap1, ap2, ap3, ap4):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_setTransform(displaydriver, pyOrNewObject(Display, ap1), Matrix(impl = ap2), ap3, ap4)

@ffi.callback("void(eC_DisplayDriver, eC_Display)")
def cb_DisplayDriver_startUpdate(__e, ap1):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_startUpdate(displaydriver, pyOrNewObject(Display, ap1))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_Bitmap, int, int, int, int, int, int, int, int)")
def cb_DisplayDriver_stretch(__e, ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_stretch(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), pyOrNewObject(Bitmap, ap3), dx, dy, sx, sy, w, h, sw, sh)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_Bitmap, int, int, int, int, int, int, int, int)")
def cb_DisplayDriver_stretchDI(__e, ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_stretchDI(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), pyOrNewObject(Bitmap, ap3), dx, dy, sx, sy, w, h, sw, sh)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_Bitmap, float, float, float, float, float, float, float, float)")
def cb_DisplayDriver_stretchf(__e, ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_stretchf(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), pyOrNewObject(Bitmap, ap3), dx, dy, sx, sy, w, h, sw, sh)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, constString, int, int *, int *, int, int *, int *)")
def cb_DisplayDriver_textExtent(__e, ap1, ap2, text, len, tw, th, prevGlyph, rPrevGlyph, overHang):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_textExtent(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), text, len, tw, th, prevGlyph, rPrevGlyph, overHang)

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_Font *)")
def cb_DisplayDriver_textFont(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_textFont(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), Font(impl = ap3))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, eC_bool)")
def cb_DisplayDriver_textOpacity(__e, ap1, ap2, ap3):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_textOpacity(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), ap3)

@ffi.callback("void(eC_DisplayDriver, eC_DisplaySystem, eC_Font *)")
def cb_DisplayDriver_unloadFont(__e, ap1, ap2):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_unloadFont(displaydriver, pyOrNewObject(DisplaySystem, ap1), Font(impl = ap2))

@ffi.callback("void(eC_DisplayDriver, eC_Display)")
def cb_DisplayDriver_unlock(__e, ap1):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_unlock(displaydriver, pyOrNewObject(Display, ap1))

@ffi.callback("void(eC_DisplayDriver, eC_DisplaySystem, eC_PrimitiveSingle *, eC_bool, int, void *)")
def cb_DisplayDriver_unlockIndices(__e, ap1, group, indices32bit, nIndices, maeb):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_unlockIndices(displaydriver, pyOrNewObject(DisplaySystem, ap1), PrimitiveSingle(impl = group), indices32bit, nIndices, maeb)

@ffi.callback("void(eC_DisplayDriver, eC_DisplaySystem, eC_Mesh *, eC_MeshFeatures)")
def cb_DisplayDriver_unlockMesh(__e, ap1, ap2, flags):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_unlockMesh(displaydriver, pyOrNewObject(DisplaySystem, ap1), Mesh(impl = ap2), MeshFeatures(impl = flags))

@ffi.callback("void(eC_DisplayDriver, eC_DisplaySystem)")
def cb_DisplayDriver_unlockSystem(__e, displaySystem):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_unlockSystem(displaydriver, pyOrNewObject(DisplaySystem, displaySystem))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Box *)")
def cb_DisplayDriver_update(__e, ap1, ap2):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_update(displaydriver, pyOrNewObject(Display, ap1), Box(impl = ap2))

@ffi.callback("void(eC_DisplayDriver, eC_Display, eC_Surface, int, int, constString, int, int, int *)")
def cb_DisplayDriver_writeText(__e, ap1, ap2, x, y, text, len, prevGlyph, rPrevGlyph):
   displaydriver = pyOrNewObject(DisplayDriver, __e)
   displaydriver.fn_DisplayDriver_writeText(displaydriver, pyOrNewObject(Display, ap1), pyOrNewObject(Surface, ap2), x, y, text, len, prevGlyph, rPrevGlyph)

class DisplayDriver(Instance):
   class_members = [
                      'allocateBitmap',
                      'allocateIndices',
                      'allocateMesh',
                      'applyMaterial',
                      'area',
                      'blit',
                      'blitDI',
                      'clear',
                      'clip',
                      'convertBitmap',
                      'createDisplay',
                      'createDisplaySystem',
                      'destroyDisplay',
                      'destroyDisplaySystem',
                      'displayPosition',
                      'displaySize',
                      'drawLine',
                      'drawPrimitives',
                      'drawingChar',
                      'endUpdate',
                      'filter',
                      'filterDI',
                      'fontExtent',
                      'freeBitmap',
                      'freeIndices',
                      'freeMesh',
                      'getBitmapSurface',
                      'getPixel',
                      'getSurface',
                      'grabScreen',
                      'lineStipple',
                      'loadFont',
                      'lock',
                      'lockIndices',
                      'lockMesh',
                      'lockSystem',
                      'makeDDBitmap',
                      'nextPage',
                      'popMatrix',
                      'pushMatrix',
                      'putPixel',
                      'rectangle',
                      'releaseSurface',
                      'restorePalette',
                      'scroll',
                      'selectMesh',
                      'setBackground',
                      'setBlitTint',
                      'setCamera',
                      'setCameraVR',
                      'setForeground',
                      'setLight',
                      'setPalette',
                      'setRenderState',
                      'setTransform',
                      'startUpdate',
                      'stretch',
                      'stretchDI',
                      'stretchf',
                      'textExtent',
                      'textFont',
                      'textOpacity',
                      'unloadFont',
                      'unlock',
                      'unlockIndices',
                      'unlockMesh',
                      'unlockSystem',
                      'update',
                      'writeText',
                   ]

   def init_args(self, args, kwArgs): init_args(DisplayDriver, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def fn_unset_DisplayDriver_allocateBitmap(self, ap1, ap2, ap3, ap4, ap5, ap6, ap7):
      return lib.DisplayDriver_allocateBitmap(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ap3, ap4, ap5, ap6, ap7)

   @property
   def allocateBitmap(self):
      if hasattr(self, 'fn_DisplayDriver_allocateBitmap'): return self.fn_DisplayDriver_allocateBitmap
      else: return self.fn_unset_DisplayDriver_allocateBitmap
   @allocateBitmap.setter
   def allocateBitmap(self, value):
      self.fn_DisplayDriver_allocateBitmap = value
      lib.Instance_setMethod(self.impl, "AllocateBitmap".encode('u8'), cb_DisplayDriver_allocateBitmap)

   def fn_unset_DisplayDriver_allocateIndices(self, ap1, nIndices, indices32bit):
      return lib.DisplayDriver_allocateIndices(self.impl, ffi.NULL if ap1 is None else ap1.impl, nIndices, indices32bit)

   @property
   def allocateIndices(self):
      if hasattr(self, 'fn_DisplayDriver_allocateIndices'): return self.fn_DisplayDriver_allocateIndices
      else: return self.fn_unset_DisplayDriver_allocateIndices
   @allocateIndices.setter
   def allocateIndices(self, value):
      self.fn_DisplayDriver_allocateIndices = value
      lib.Instance_setMethod(self.impl, "AllocateIndices".encode('u8'), cb_DisplayDriver_allocateIndices)

   def fn_unset_DisplayDriver_allocateMesh(self, ap1, ap2, ap3, nVertices):
      return lib.DisplayDriver_allocateMesh(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ap3, nVertices)

   @property
   def allocateMesh(self):
      if hasattr(self, 'fn_DisplayDriver_allocateMesh'): return self.fn_DisplayDriver_allocateMesh
      else: return self.fn_unset_DisplayDriver_allocateMesh
   @allocateMesh.setter
   def allocateMesh(self, value):
      self.fn_DisplayDriver_allocateMesh = value
      lib.Instance_setMethod(self.impl, "AllocateMesh".encode('u8'), cb_DisplayDriver_allocateMesh)

   def fn_unset_DisplayDriver_applyMaterial(self, ap1, ap2, ap3):
      return lib.DisplayDriver_applyMaterial(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if ap3 is None else ap3.impl)

   @property
   def applyMaterial(self):
      if hasattr(self, 'fn_DisplayDriver_applyMaterial'): return self.fn_DisplayDriver_applyMaterial
      else: return self.fn_unset_DisplayDriver_applyMaterial
   @applyMaterial.setter
   def applyMaterial(self, value):
      self.fn_DisplayDriver_applyMaterial = value
      lib.Instance_setMethod(self.impl, "ApplyMaterial".encode('u8'), cb_DisplayDriver_applyMaterial)

   def fn_unset_DisplayDriver_area(self, ap1, ap2, x1, y1, x2, y2):
      return lib.DisplayDriver_area(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, x1, y1, x2, y2)

   @property
   def area(self):
      if hasattr(self, 'fn_DisplayDriver_area'): return self.fn_DisplayDriver_area
      else: return self.fn_unset_DisplayDriver_area
   @area.setter
   def area(self, value):
      self.fn_DisplayDriver_area = value
      lib.Instance_setMethod(self.impl, "Area".encode('u8'), cb_DisplayDriver_area)

   def fn_unset_DisplayDriver_blit(self, ap1, ap2, ap3, dx, dy, sx, sy, w, h):
      return lib.DisplayDriver_blit(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if ap3 is None else ap3.impl, dx, dy, sx, sy, w, h)

   @property
   def blit(self):
      if hasattr(self, 'fn_DisplayDriver_blit'): return self.fn_DisplayDriver_blit
      else: return self.fn_unset_DisplayDriver_blit
   @blit.setter
   def blit(self, value):
      self.fn_DisplayDriver_blit = value
      lib.Instance_setMethod(self.impl, "Blit".encode('u8'), cb_DisplayDriver_blit)

   def fn_unset_DisplayDriver_blitDI(self, ap1, ap2, ap3, dx, dy, sx, sy, w, h):
      return lib.DisplayDriver_blitDI(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if ap3 is None else ap3.impl, dx, dy, sx, sy, w, h)

   @property
   def blitDI(self):
      if hasattr(self, 'fn_DisplayDriver_blitDI'): return self.fn_DisplayDriver_blitDI
      else: return self.fn_unset_DisplayDriver_blitDI
   @blitDI.setter
   def blitDI(self, value):
      self.fn_DisplayDriver_blitDI = value
      lib.Instance_setMethod(self.impl, "BlitDI".encode('u8'), cb_DisplayDriver_blitDI)

   def fn_unset_DisplayDriver_clear(self, ap1, ap2, ap3):
      return lib.DisplayDriver_clear(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ap3)

   @property
   def clear(self):
      if hasattr(self, 'fn_DisplayDriver_clear'): return self.fn_DisplayDriver_clear
      else: return self.fn_unset_DisplayDriver_clear
   @clear.setter
   def clear(self, value):
      self.fn_DisplayDriver_clear = value
      lib.Instance_setMethod(self.impl, "Clear".encode('u8'), cb_DisplayDriver_clear)

   def fn_unset_DisplayDriver_clip(self, ap1, ap2, ap3):
      return lib.DisplayDriver_clip(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if ap3 is None else ap3.impl)

   @property
   def clip(self):
      if hasattr(self, 'fn_DisplayDriver_clip'): return self.fn_DisplayDriver_clip
      else: return self.fn_unset_DisplayDriver_clip
   @clip.setter
   def clip(self, value):
      self.fn_DisplayDriver_clip = value
      lib.Instance_setMethod(self.impl, "Clip".encode('u8'), cb_DisplayDriver_clip)

   def fn_unset_DisplayDriver_convertBitmap(self, ap1, ap2, ap3, ap4):
      if ap4 is None: ap4 = ffi.NULL
      return lib.DisplayDriver_convertBitmap(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ap3, ap4)

   @property
   def convertBitmap(self):
      if hasattr(self, 'fn_DisplayDriver_convertBitmap'): return self.fn_DisplayDriver_convertBitmap
      else: return self.fn_unset_DisplayDriver_convertBitmap
   @convertBitmap.setter
   def convertBitmap(self, value):
      self.fn_DisplayDriver_convertBitmap = value
      lib.Instance_setMethod(self.impl, "ConvertBitmap".encode('u8'), cb_DisplayDriver_convertBitmap)

   def fn_unset_DisplayDriver_createDisplay(self, ap1):
      return lib.DisplayDriver_createDisplay(self.impl, ffi.NULL if ap1 is None else ap1.impl)

   @property
   def createDisplay(self):
      if hasattr(self, 'fn_DisplayDriver_createDisplay'): return self.fn_DisplayDriver_createDisplay
      else: return self.fn_unset_DisplayDriver_createDisplay
   @createDisplay.setter
   def createDisplay(self, value):
      self.fn_DisplayDriver_createDisplay = value
      lib.Instance_setMethod(self.impl, "CreateDisplay".encode('u8'), cb_DisplayDriver_createDisplay)

   def fn_unset_DisplayDriver_createDisplaySystem(self, ap1):
      return lib.DisplayDriver_createDisplaySystem(self.impl, ffi.NULL if ap1 is None else ap1.impl)

   @property
   def createDisplaySystem(self):
      if hasattr(self, 'fn_DisplayDriver_createDisplaySystem'): return self.fn_DisplayDriver_createDisplaySystem
      else: return self.fn_unset_DisplayDriver_createDisplaySystem
   @createDisplaySystem.setter
   def createDisplaySystem(self, value):
      self.fn_DisplayDriver_createDisplaySystem = value
      lib.Instance_setMethod(self.impl, "CreateDisplaySystem".encode('u8'), cb_DisplayDriver_createDisplaySystem)

   def fn_unset_DisplayDriver_destroyDisplay(self, ap1):
      return lib.DisplayDriver_destroyDisplay(self.impl, ffi.NULL if ap1 is None else ap1.impl)

   @property
   def destroyDisplay(self):
      if hasattr(self, 'fn_DisplayDriver_destroyDisplay'): return self.fn_DisplayDriver_destroyDisplay
      else: return self.fn_unset_DisplayDriver_destroyDisplay
   @destroyDisplay.setter
   def destroyDisplay(self, value):
      self.fn_DisplayDriver_destroyDisplay = value
      lib.Instance_setMethod(self.impl, "DestroyDisplay".encode('u8'), cb_DisplayDriver_destroyDisplay)

   def fn_unset_DisplayDriver_destroyDisplaySystem(self, ap1):
      return lib.DisplayDriver_destroyDisplaySystem(self.impl, ffi.NULL if ap1 is None else ap1.impl)

   @property
   def destroyDisplaySystem(self):
      if hasattr(self, 'fn_DisplayDriver_destroyDisplaySystem'): return self.fn_DisplayDriver_destroyDisplaySystem
      else: return self.fn_unset_DisplayDriver_destroyDisplaySystem
   @destroyDisplaySystem.setter
   def destroyDisplaySystem(self, value):
      self.fn_DisplayDriver_destroyDisplaySystem = value
      lib.Instance_setMethod(self.impl, "DestroyDisplaySystem".encode('u8'), cb_DisplayDriver_destroyDisplaySystem)

   def fn_unset_DisplayDriver_displayPosition(self, ap1, ap2, ap3):
      return lib.DisplayDriver_displayPosition(self.impl, ffi.NULL if ap1 is None else ap1.impl, ap2, ap3)

   @property
   def displayPosition(self):
      if hasattr(self, 'fn_DisplayDriver_displayPosition'): return self.fn_DisplayDriver_displayPosition
      else: return self.fn_unset_DisplayDriver_displayPosition
   @displayPosition.setter
   def displayPosition(self, value):
      self.fn_DisplayDriver_displayPosition = value
      lib.Instance_setMethod(self.impl, "DisplayPosition".encode('u8'), cb_DisplayDriver_displayPosition)

   def fn_unset_DisplayDriver_displaySize(self, ap1, ap2, ap3):
      return lib.DisplayDriver_displaySize(self.impl, ffi.NULL if ap1 is None else ap1.impl, ap2, ap3)

   @property
   def displaySize(self):
      if hasattr(self, 'fn_DisplayDriver_displaySize'): return self.fn_DisplayDriver_displaySize
      else: return self.fn_unset_DisplayDriver_displaySize
   @displaySize.setter
   def displaySize(self, value):
      self.fn_DisplayDriver_displaySize = value
      lib.Instance_setMethod(self.impl, "DisplaySize".encode('u8'), cb_DisplayDriver_displaySize)

   def fn_unset_DisplayDriver_drawLine(self, ap1, ap2, x1, y1, x2, y2):
      return lib.DisplayDriver_drawLine(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, x1, y1, x2, y2)

   @property
   def drawLine(self):
      if hasattr(self, 'fn_DisplayDriver_drawLine'): return self.fn_DisplayDriver_drawLine
      else: return self.fn_unset_DisplayDriver_drawLine
   @drawLine.setter
   def drawLine(self, value):
      self.fn_DisplayDriver_drawLine = value
      lib.Instance_setMethod(self.impl, "DrawLine".encode('u8'), cb_DisplayDriver_drawLine)

   def fn_unset_DisplayDriver_drawPrimitives(self, ap1, ap2, mesh):
      return lib.DisplayDriver_drawPrimitives(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if mesh is None else mesh.impl)

   @property
   def drawPrimitives(self):
      if hasattr(self, 'fn_DisplayDriver_drawPrimitives'): return self.fn_DisplayDriver_drawPrimitives
      else: return self.fn_unset_DisplayDriver_drawPrimitives
   @drawPrimitives.setter
   def drawPrimitives(self, value):
      self.fn_DisplayDriver_drawPrimitives = value
      lib.Instance_setMethod(self.impl, "DrawPrimitives".encode('u8'), cb_DisplayDriver_drawPrimitives)

   def fn_unset_DisplayDriver_drawingChar(self, ap1, ap2, ch):
      return lib.DisplayDriver_drawingChar(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ch)

   @property
   def drawingChar(self):
      if hasattr(self, 'fn_DisplayDriver_drawingChar'): return self.fn_DisplayDriver_drawingChar
      else: return self.fn_unset_DisplayDriver_drawingChar
   @drawingChar.setter
   def drawingChar(self, value):
      self.fn_DisplayDriver_drawingChar = value
      lib.Instance_setMethod(self.impl, "DrawingChar".encode('u8'), cb_DisplayDriver_drawingChar)

   def fn_unset_DisplayDriver_endUpdate(self, ap1):
      return lib.DisplayDriver_endUpdate(self.impl, ffi.NULL if ap1 is None else ap1.impl)

   @property
   def endUpdate(self):
      if hasattr(self, 'fn_DisplayDriver_endUpdate'): return self.fn_DisplayDriver_endUpdate
      else: return self.fn_unset_DisplayDriver_endUpdate
   @endUpdate.setter
   def endUpdate(self, value):
      self.fn_DisplayDriver_endUpdate = value
      lib.Instance_setMethod(self.impl, "EndUpdate".encode('u8'), cb_DisplayDriver_endUpdate)

   def fn_unset_DisplayDriver_filter(self, ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh):
      return lib.DisplayDriver_filter(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if ap3 is None else ap3.impl, dx, dy, sx, sy, w, h, sw, sh)

   @property
   def filter(self):
      if hasattr(self, 'fn_DisplayDriver_filter'): return self.fn_DisplayDriver_filter
      else: return self.fn_unset_DisplayDriver_filter
   @filter.setter
   def filter(self, value):
      self.fn_DisplayDriver_filter = value
      lib.Instance_setMethod(self.impl, "Filter".encode('u8'), cb_DisplayDriver_filter)

   def fn_unset_DisplayDriver_filterDI(self, ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh):
      return lib.DisplayDriver_filterDI(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if ap3 is None else ap3.impl, dx, dy, sx, sy, w, h, sw, sh)

   @property
   def filterDI(self):
      if hasattr(self, 'fn_DisplayDriver_filterDI'): return self.fn_DisplayDriver_filterDI
      else: return self.fn_unset_DisplayDriver_filterDI
   @filterDI.setter
   def filterDI(self, value):
      self.fn_DisplayDriver_filterDI = value
      lib.Instance_setMethod(self.impl, "FilterDI".encode('u8'), cb_DisplayDriver_filterDI)

   def fn_unset_DisplayDriver_fontExtent(self, ap1, ap2, text, len, tw, th, prevGlyph, rPrevGlyph, overHang):
      if tw is None: tw = ffi.NULL
      if th is None: th = ffi.NULL
      if rPrevGlyph is None: rPrevGlyph = ffi.NULL
      if overHang is None: overHang = ffi.NULL
      return lib.DisplayDriver_fontExtent(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if text is None else text.impl, len, tw, th, prevGlyph, rPrevGlyph, overHang)

   @property
   def fontExtent(self):
      if hasattr(self, 'fn_DisplayDriver_fontExtent'): return self.fn_DisplayDriver_fontExtent
      else: return self.fn_unset_DisplayDriver_fontExtent
   @fontExtent.setter
   def fontExtent(self, value):
      self.fn_DisplayDriver_fontExtent = value
      lib.Instance_setMethod(self.impl, "FontExtent".encode('u8'), cb_DisplayDriver_fontExtent)

   def fn_unset_DisplayDriver_freeBitmap(self, ap1, ap2):
      return lib.DisplayDriver_freeBitmap(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl)

   @property
   def freeBitmap(self):
      if hasattr(self, 'fn_DisplayDriver_freeBitmap'): return self.fn_DisplayDriver_freeBitmap
      else: return self.fn_unset_DisplayDriver_freeBitmap
   @freeBitmap.setter
   def freeBitmap(self, value):
      self.fn_DisplayDriver_freeBitmap = value
      lib.Instance_setMethod(self.impl, "FreeBitmap".encode('u8'), cb_DisplayDriver_freeBitmap)

   def fn_unset_DisplayDriver_freeIndices(self, ap1, group):
      return lib.DisplayDriver_freeIndices(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if group is None else group.impl)

   @property
   def freeIndices(self):
      if hasattr(self, 'fn_DisplayDriver_freeIndices'): return self.fn_DisplayDriver_freeIndices
      else: return self.fn_unset_DisplayDriver_freeIndices
   @freeIndices.setter
   def freeIndices(self, value):
      self.fn_DisplayDriver_freeIndices = value
      lib.Instance_setMethod(self.impl, "FreeIndices".encode('u8'), cb_DisplayDriver_freeIndices)

   def fn_unset_DisplayDriver_freeMesh(self, ap1, ap2):
      return lib.DisplayDriver_freeMesh(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl)

   @property
   def freeMesh(self):
      if hasattr(self, 'fn_DisplayDriver_freeMesh'): return self.fn_DisplayDriver_freeMesh
      else: return self.fn_unset_DisplayDriver_freeMesh
   @freeMesh.setter
   def freeMesh(self, value):
      self.fn_DisplayDriver_freeMesh = value
      lib.Instance_setMethod(self.impl, "FreeMesh".encode('u8'), cb_DisplayDriver_freeMesh)

   def fn_unset_DisplayDriver_getBitmapSurface(self, displaySystem, surface, bitmap, ap1, ap2, ap3):
      return lib.DisplayDriver_getBitmapSurface(self.impl, ffi.NULL if displaySystem is None else displaySystem.impl, ffi.NULL if surface is None else surface.impl, ffi.NULL if bitmap is None else bitmap.impl, ap1, ap2, ffi.NULL if ap3 is None else ap3.impl)

   @property
   def getBitmapSurface(self):
      if hasattr(self, 'fn_DisplayDriver_getBitmapSurface'): return self.fn_DisplayDriver_getBitmapSurface
      else: return self.fn_unset_DisplayDriver_getBitmapSurface
   @getBitmapSurface.setter
   def getBitmapSurface(self, value):
      self.fn_DisplayDriver_getBitmapSurface = value
      lib.Instance_setMethod(self.impl, "GetBitmapSurface".encode('u8'), cb_DisplayDriver_getBitmapSurface)

   def fn_unset_DisplayDriver_getPixel(self, ap1, ap2, x, y):
      return lib.DisplayDriver_getPixel(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, x, y)

   @property
   def getPixel(self):
      if hasattr(self, 'fn_DisplayDriver_getPixel'): return self.fn_DisplayDriver_getPixel
      else: return self.fn_unset_DisplayDriver_getPixel
   @getPixel.setter
   def getPixel(self, value):
      self.fn_DisplayDriver_getPixel = value
      lib.Instance_setMethod(self.impl, "GetPixel".encode('u8'), cb_DisplayDriver_getPixel)

   def fn_unset_DisplayDriver_getSurface(self, ap1, surface, ap2, ap3, ap4):
      return lib.DisplayDriver_getSurface(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if surface is None else surface.impl, ap2, ap3, ffi.NULL if ap4 is None else ap4.impl)

   @property
   def getSurface(self):
      if hasattr(self, 'fn_DisplayDriver_getSurface'): return self.fn_DisplayDriver_getSurface
      else: return self.fn_unset_DisplayDriver_getSurface
   @getSurface.setter
   def getSurface(self, value):
      self.fn_DisplayDriver_getSurface = value
      lib.Instance_setMethod(self.impl, "GetSurface".encode('u8'), cb_DisplayDriver_getSurface)

   def fn_unset_DisplayDriver_grabScreen(self, ap1, ap2, ap3, ap4, ap5, ap6):
      return lib.DisplayDriver_grabScreen(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ap3, ap4, ap5, ap6)

   @property
   def grabScreen(self):
      if hasattr(self, 'fn_DisplayDriver_grabScreen'): return self.fn_DisplayDriver_grabScreen
      else: return self.fn_unset_DisplayDriver_grabScreen
   @grabScreen.setter
   def grabScreen(self, value):
      self.fn_DisplayDriver_grabScreen = value
      lib.Instance_setMethod(self.impl, "GrabScreen".encode('u8'), cb_DisplayDriver_grabScreen)

   def fn_unset_DisplayDriver_lineStipple(self, ap1, ap2, pattern):
      return lib.DisplayDriver_lineStipple(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, pattern)

   @property
   def lineStipple(self):
      if hasattr(self, 'fn_DisplayDriver_lineStipple'): return self.fn_DisplayDriver_lineStipple
      else: return self.fn_unset_DisplayDriver_lineStipple
   @lineStipple.setter
   def lineStipple(self, value):
      self.fn_DisplayDriver_lineStipple = value
      lib.Instance_setMethod(self.impl, "LineStipple".encode('u8'), cb_DisplayDriver_lineStipple)

   def fn_unset_DisplayDriver_loadFont(self, displaySystem, faceName, size, flags, outlineSize, outlineFade):
      return lib.DisplayDriver_loadFont(self.impl, ffi.NULL if displaySystem is None else displaySystem.impl, faceName, size, flags, outlineSize, outlineFade)

   @property
   def loadFont(self):
      if hasattr(self, 'fn_DisplayDriver_loadFont'): return self.fn_DisplayDriver_loadFont
      else: return self.fn_unset_DisplayDriver_loadFont
   @loadFont.setter
   def loadFont(self, value):
      self.fn_DisplayDriver_loadFont = value
      lib.Instance_setMethod(self.impl, "LoadFont".encode('u8'), cb_DisplayDriver_loadFont)

   def fn_unset_DisplayDriver_lock(self, ap1):
      return lib.DisplayDriver_lock(self.impl, ffi.NULL if ap1 is None else ap1.impl)

   @property
   def lock(self):
      if hasattr(self, 'fn_DisplayDriver_lock'): return self.fn_DisplayDriver_lock
      else: return self.fn_unset_DisplayDriver_lock
   @lock.setter
   def lock(self, value):
      self.fn_DisplayDriver_lock = value
      lib.Instance_setMethod(self.impl, "Lock".encode('u8'), cb_DisplayDriver_lock)

   def fn_unset_DisplayDriver_lockIndices(self, ap1, group):
      return lib.DisplayDriver_lockIndices(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if group is None else group.impl)

   @property
   def lockIndices(self):
      if hasattr(self, 'fn_DisplayDriver_lockIndices'): return self.fn_DisplayDriver_lockIndices
      else: return self.fn_unset_DisplayDriver_lockIndices
   @lockIndices.setter
   def lockIndices(self, value):
      self.fn_DisplayDriver_lockIndices = value
      lib.Instance_setMethod(self.impl, "LockIndices".encode('u8'), cb_DisplayDriver_lockIndices)

   def fn_unset_DisplayDriver_lockMesh(self, ap1, ap2, flags):
      return lib.DisplayDriver_lockMesh(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, flags)

   @property
   def lockMesh(self):
      if hasattr(self, 'fn_DisplayDriver_lockMesh'): return self.fn_DisplayDriver_lockMesh
      else: return self.fn_unset_DisplayDriver_lockMesh
   @lockMesh.setter
   def lockMesh(self, value):
      self.fn_DisplayDriver_lockMesh = value
      lib.Instance_setMethod(self.impl, "LockMesh".encode('u8'), cb_DisplayDriver_lockMesh)

   def fn_unset_DisplayDriver_lockSystem(self, displaySystem):
      return lib.DisplayDriver_lockSystem(self.impl, ffi.NULL if displaySystem is None else displaySystem.impl)

   @property
   def lockSystem(self):
      if hasattr(self, 'fn_DisplayDriver_lockSystem'): return self.fn_DisplayDriver_lockSystem
      else: return self.fn_unset_DisplayDriver_lockSystem
   @lockSystem.setter
   def lockSystem(self, value):
      self.fn_DisplayDriver_lockSystem = value
      lib.Instance_setMethod(self.impl, "LockSystem".encode('u8'), cb_DisplayDriver_lockSystem)

   def fn_unset_DisplayDriver_makeDDBitmap(self, ap1, ap2, mipMaps, cubeMapFace):
      return lib.DisplayDriver_makeDDBitmap(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, mipMaps, cubeMapFace)

   @property
   def makeDDBitmap(self):
      if hasattr(self, 'fn_DisplayDriver_makeDDBitmap'): return self.fn_DisplayDriver_makeDDBitmap
      else: return self.fn_unset_DisplayDriver_makeDDBitmap
   @makeDDBitmap.setter
   def makeDDBitmap(self, value):
      self.fn_DisplayDriver_makeDDBitmap = value
      lib.Instance_setMethod(self.impl, "MakeDDBitmap".encode('u8'), cb_DisplayDriver_makeDDBitmap)

   def fn_unset_DisplayDriver_nextPage(self, ap1):
      return lib.DisplayDriver_nextPage(self.impl, ffi.NULL if ap1 is None else ap1.impl)

   @property
   def nextPage(self):
      if hasattr(self, 'fn_DisplayDriver_nextPage'): return self.fn_DisplayDriver_nextPage
      else: return self.fn_unset_DisplayDriver_nextPage
   @nextPage.setter
   def nextPage(self, value):
      self.fn_DisplayDriver_nextPage = value
      lib.Instance_setMethod(self.impl, "NextPage".encode('u8'), cb_DisplayDriver_nextPage)

   def fn_unset_DisplayDriver_popMatrix(self, ap1, ap2):
      return lib.DisplayDriver_popMatrix(self.impl, ffi.NULL if ap1 is None else ap1.impl, ap2)

   @property
   def popMatrix(self):
      if hasattr(self, 'fn_DisplayDriver_popMatrix'): return self.fn_DisplayDriver_popMatrix
      else: return self.fn_unset_DisplayDriver_popMatrix
   @popMatrix.setter
   def popMatrix(self, value):
      self.fn_DisplayDriver_popMatrix = value
      lib.Instance_setMethod(self.impl, "PopMatrix".encode('u8'), cb_DisplayDriver_popMatrix)

   def fn_unset_DisplayDriver_pushMatrix(self, ap1):
      return lib.DisplayDriver_pushMatrix(self.impl, ffi.NULL if ap1 is None else ap1.impl)

   @property
   def pushMatrix(self):
      if hasattr(self, 'fn_DisplayDriver_pushMatrix'): return self.fn_DisplayDriver_pushMatrix
      else: return self.fn_unset_DisplayDriver_pushMatrix
   @pushMatrix.setter
   def pushMatrix(self, value):
      self.fn_DisplayDriver_pushMatrix = value
      lib.Instance_setMethod(self.impl, "PushMatrix".encode('u8'), cb_DisplayDriver_pushMatrix)

   def fn_unset_DisplayDriver_putPixel(self, ap1, ap2, x, y):
      return lib.DisplayDriver_putPixel(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, x, y)

   @property
   def putPixel(self):
      if hasattr(self, 'fn_DisplayDriver_putPixel'): return self.fn_DisplayDriver_putPixel
      else: return self.fn_unset_DisplayDriver_putPixel
   @putPixel.setter
   def putPixel(self, value):
      self.fn_DisplayDriver_putPixel = value
      lib.Instance_setMethod(self.impl, "PutPixel".encode('u8'), cb_DisplayDriver_putPixel)

   def fn_unset_DisplayDriver_rectangle(self, ap1, ap2, x1, y1, x2, y2):
      return lib.DisplayDriver_rectangle(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, x1, y1, x2, y2)

   @property
   def rectangle(self):
      if hasattr(self, 'fn_DisplayDriver_rectangle'): return self.fn_DisplayDriver_rectangle
      else: return self.fn_unset_DisplayDriver_rectangle
   @rectangle.setter
   def rectangle(self, value):
      self.fn_DisplayDriver_rectangle = value
      lib.Instance_setMethod(self.impl, "Rectangle".encode('u8'), cb_DisplayDriver_rectangle)

   def fn_unset_DisplayDriver_releaseSurface(self, this, ap1):
      return lib.DisplayDriver_releaseSurface(self.impl, ffi.NULL if this is None else this.impl, ffi.NULL if ap1 is None else ap1.impl)

   @property
   def releaseSurface(self):
      if hasattr(self, 'fn_DisplayDriver_releaseSurface'): return self.fn_DisplayDriver_releaseSurface
      else: return self.fn_unset_DisplayDriver_releaseSurface
   @releaseSurface.setter
   def releaseSurface(self, value):
      self.fn_DisplayDriver_releaseSurface = value
      lib.Instance_setMethod(self.impl, "ReleaseSurface".encode('u8'), cb_DisplayDriver_releaseSurface)

   def fn_unset_DisplayDriver_restorePalette(self, ap1):
      return lib.DisplayDriver_restorePalette(self.impl, ffi.NULL if ap1 is None else ap1.impl)

   @property
   def restorePalette(self):
      if hasattr(self, 'fn_DisplayDriver_restorePalette'): return self.fn_DisplayDriver_restorePalette
      else: return self.fn_unset_DisplayDriver_restorePalette
   @restorePalette.setter
   def restorePalette(self, value):
      self.fn_DisplayDriver_restorePalette = value
      lib.Instance_setMethod(self.impl, "RestorePalette".encode('u8'), cb_DisplayDriver_restorePalette)

   def fn_unset_DisplayDriver_scroll(self, ap1, ap2, ap3, ap4, ap5):
      return lib.DisplayDriver_scroll(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ap3, ap4, ffi.NULL if ap5 is None else ap5.impl)

   @property
   def scroll(self):
      if hasattr(self, 'fn_DisplayDriver_scroll'): return self.fn_DisplayDriver_scroll
      else: return self.fn_unset_DisplayDriver_scroll
   @scroll.setter
   def scroll(self, value):
      self.fn_DisplayDriver_scroll = value
      lib.Instance_setMethod(self.impl, "Scroll".encode('u8'), cb_DisplayDriver_scroll)

   def fn_unset_DisplayDriver_selectMesh(self, ap1, ap2):
      return lib.DisplayDriver_selectMesh(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl)

   @property
   def selectMesh(self):
      if hasattr(self, 'fn_DisplayDriver_selectMesh'): return self.fn_DisplayDriver_selectMesh
      else: return self.fn_unset_DisplayDriver_selectMesh
   @selectMesh.setter
   def selectMesh(self, value):
      self.fn_DisplayDriver_selectMesh = value
      lib.Instance_setMethod(self.impl, "SelectMesh".encode('u8'), cb_DisplayDriver_selectMesh)

   def fn_unset_DisplayDriver_setBackground(self, ap1, ap2, ap3):
      return lib.DisplayDriver_setBackground(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ap3)

   @property
   def setBackground(self):
      if hasattr(self, 'fn_DisplayDriver_setBackground'): return self.fn_DisplayDriver_setBackground
      else: return self.fn_unset_DisplayDriver_setBackground
   @setBackground.setter
   def setBackground(self, value):
      self.fn_DisplayDriver_setBackground = value
      lib.Instance_setMethod(self.impl, "SetBackground".encode('u8'), cb_DisplayDriver_setBackground)

   def fn_unset_DisplayDriver_setBlitTint(self, ap1, ap2, ap3):
      return lib.DisplayDriver_setBlitTint(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ap3)

   @property
   def setBlitTint(self):
      if hasattr(self, 'fn_DisplayDriver_setBlitTint'): return self.fn_DisplayDriver_setBlitTint
      else: return self.fn_unset_DisplayDriver_setBlitTint
   @setBlitTint.setter
   def setBlitTint(self, value):
      self.fn_DisplayDriver_setBlitTint = value
      lib.Instance_setMethod(self.impl, "SetBlitTint".encode('u8'), cb_DisplayDriver_setBlitTint)

   def fn_unset_DisplayDriver_setCamera(self, ap1, ap2, ap3):
      return lib.DisplayDriver_setCamera(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if ap3 is None else ap3.impl)

   @property
   def setCamera(self):
      if hasattr(self, 'fn_DisplayDriver_setCamera'): return self.fn_DisplayDriver_setCamera
      else: return self.fn_unset_DisplayDriver_setCamera
   @setCamera.setter
   def setCamera(self, value):
      self.fn_DisplayDriver_setCamera = value
      lib.Instance_setMethod(self.impl, "SetCamera".encode('u8'), cb_DisplayDriver_setCamera)

   def fn_unset_DisplayDriver_setCameraVR(self, ap1, ap2, eye, w, h, fb, prjMat):
      return lib.DisplayDriver_setCameraVR(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, eye, w, h, fb, ffi.NULL if prjMat is None else prjMat.impl)

   @property
   def setCameraVR(self):
      if hasattr(self, 'fn_DisplayDriver_setCameraVR'): return self.fn_DisplayDriver_setCameraVR
      else: return self.fn_unset_DisplayDriver_setCameraVR
   @setCameraVR.setter
   def setCameraVR(self, value):
      self.fn_DisplayDriver_setCameraVR = value
      lib.Instance_setMethod(self.impl, "SetCameraVR".encode('u8'), cb_DisplayDriver_setCameraVR)

   def fn_unset_DisplayDriver_setForeground(self, ap1, ap2, ap3):
      return lib.DisplayDriver_setForeground(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ap3)

   @property
   def setForeground(self):
      if hasattr(self, 'fn_DisplayDriver_setForeground'): return self.fn_DisplayDriver_setForeground
      else: return self.fn_unset_DisplayDriver_setForeground
   @setForeground.setter
   def setForeground(self, value):
      self.fn_DisplayDriver_setForeground = value
      lib.Instance_setMethod(self.impl, "SetForeground".encode('u8'), cb_DisplayDriver_setForeground)

   def fn_unset_DisplayDriver_setLight(self, ap1, ap2, ap3):
      return lib.DisplayDriver_setLight(self.impl, ffi.NULL if ap1 is None else ap1.impl, ap2, ffi.NULL if ap3 is None else ap3.impl)

   @property
   def setLight(self):
      if hasattr(self, 'fn_DisplayDriver_setLight'): return self.fn_DisplayDriver_setLight
      else: return self.fn_unset_DisplayDriver_setLight
   @setLight.setter
   def setLight(self, value):
      self.fn_DisplayDriver_setLight = value
      lib.Instance_setMethod(self.impl, "SetLight".encode('u8'), cb_DisplayDriver_setLight)

   def fn_unset_DisplayDriver_setPalette(self, ap1, ap2, ap3):
      if ap2 is None: ap2 = ffi.NULL
      return lib.DisplayDriver_setPalette(self.impl, ffi.NULL if ap1 is None else ap1.impl, ap2, ap3)

   @property
   def setPalette(self):
      if hasattr(self, 'fn_DisplayDriver_setPalette'): return self.fn_DisplayDriver_setPalette
      else: return self.fn_unset_DisplayDriver_setPalette
   @setPalette.setter
   def setPalette(self, value):
      self.fn_DisplayDriver_setPalette = value
      lib.Instance_setMethod(self.impl, "SetPalette".encode('u8'), cb_DisplayDriver_setPalette)

   def fn_unset_DisplayDriver_setRenderState(self, ap1, ap2, ap3):
      return lib.DisplayDriver_setRenderState(self.impl, ffi.NULL if ap1 is None else ap1.impl, ap2, ap3)

   @property
   def setRenderState(self):
      if hasattr(self, 'fn_DisplayDriver_setRenderState'): return self.fn_DisplayDriver_setRenderState
      else: return self.fn_unset_DisplayDriver_setRenderState
   @setRenderState.setter
   def setRenderState(self, value):
      self.fn_DisplayDriver_setRenderState = value
      lib.Instance_setMethod(self.impl, "SetRenderState".encode('u8'), cb_DisplayDriver_setRenderState)

   def fn_unset_DisplayDriver_setTransform(self, ap1, ap2, ap3, ap4):
      return lib.DisplayDriver_setTransform(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ap3, ap4)

   @property
   def setTransform(self):
      if hasattr(self, 'fn_DisplayDriver_setTransform'): return self.fn_DisplayDriver_setTransform
      else: return self.fn_unset_DisplayDriver_setTransform
   @setTransform.setter
   def setTransform(self, value):
      self.fn_DisplayDriver_setTransform = value
      lib.Instance_setMethod(self.impl, "SetTransform".encode('u8'), cb_DisplayDriver_setTransform)

   def fn_unset_DisplayDriver_startUpdate(self, ap1):
      return lib.DisplayDriver_startUpdate(self.impl, ffi.NULL if ap1 is None else ap1.impl)

   @property
   def startUpdate(self):
      if hasattr(self, 'fn_DisplayDriver_startUpdate'): return self.fn_DisplayDriver_startUpdate
      else: return self.fn_unset_DisplayDriver_startUpdate
   @startUpdate.setter
   def startUpdate(self, value):
      self.fn_DisplayDriver_startUpdate = value
      lib.Instance_setMethod(self.impl, "StartUpdate".encode('u8'), cb_DisplayDriver_startUpdate)

   def fn_unset_DisplayDriver_stretch(self, ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh):
      return lib.DisplayDriver_stretch(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if ap3 is None else ap3.impl, dx, dy, sx, sy, w, h, sw, sh)

   @property
   def stretch(self):
      if hasattr(self, 'fn_DisplayDriver_stretch'): return self.fn_DisplayDriver_stretch
      else: return self.fn_unset_DisplayDriver_stretch
   @stretch.setter
   def stretch(self, value):
      self.fn_DisplayDriver_stretch = value
      lib.Instance_setMethod(self.impl, "Stretch".encode('u8'), cb_DisplayDriver_stretch)

   def fn_unset_DisplayDriver_stretchDI(self, ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh):
      return lib.DisplayDriver_stretchDI(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if ap3 is None else ap3.impl, dx, dy, sx, sy, w, h, sw, sh)

   @property
   def stretchDI(self):
      if hasattr(self, 'fn_DisplayDriver_stretchDI'): return self.fn_DisplayDriver_stretchDI
      else: return self.fn_unset_DisplayDriver_stretchDI
   @stretchDI.setter
   def stretchDI(self, value):
      self.fn_DisplayDriver_stretchDI = value
      lib.Instance_setMethod(self.impl, "StretchDI".encode('u8'), cb_DisplayDriver_stretchDI)

   def fn_unset_DisplayDriver_stretchf(self, ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh):
      return lib.DisplayDriver_stretchf(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if ap3 is None else ap3.impl, dx, dy, sx, sy, w, h, sw, sh)

   @property
   def stretchf(self):
      if hasattr(self, 'fn_DisplayDriver_stretchf'): return self.fn_DisplayDriver_stretchf
      else: return self.fn_unset_DisplayDriver_stretchf
   @stretchf.setter
   def stretchf(self, value):
      self.fn_DisplayDriver_stretchf = value
      lib.Instance_setMethod(self.impl, "Stretchf".encode('u8'), cb_DisplayDriver_stretchf)

   def fn_unset_DisplayDriver_textExtent(self, ap1, ap2, text, len, tw, th, prevGlyph, rPrevGlyph, overHang):
      if tw is None: tw = ffi.NULL
      if th is None: th = ffi.NULL
      if rPrevGlyph is None: rPrevGlyph = ffi.NULL
      if overHang is None: overHang = ffi.NULL
      return lib.DisplayDriver_textExtent(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if text is None else text.impl, len, tw, th, prevGlyph, rPrevGlyph, overHang)

   @property
   def textExtent(self):
      if hasattr(self, 'fn_DisplayDriver_textExtent'): return self.fn_DisplayDriver_textExtent
      else: return self.fn_unset_DisplayDriver_textExtent
   @textExtent.setter
   def textExtent(self, value):
      self.fn_DisplayDriver_textExtent = value
      lib.Instance_setMethod(self.impl, "TextExtent".encode('u8'), cb_DisplayDriver_textExtent)

   def fn_unset_DisplayDriver_textFont(self, ap1, ap2, ap3):
      return lib.DisplayDriver_textFont(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if ap3 is None else ap3.impl)

   @property
   def textFont(self):
      if hasattr(self, 'fn_DisplayDriver_textFont'): return self.fn_DisplayDriver_textFont
      else: return self.fn_unset_DisplayDriver_textFont
   @textFont.setter
   def textFont(self, value):
      self.fn_DisplayDriver_textFont = value
      lib.Instance_setMethod(self.impl, "TextFont".encode('u8'), cb_DisplayDriver_textFont)

   def fn_unset_DisplayDriver_textOpacity(self, ap1, ap2, ap3):
      return lib.DisplayDriver_textOpacity(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, ap3)

   @property
   def textOpacity(self):
      if hasattr(self, 'fn_DisplayDriver_textOpacity'): return self.fn_DisplayDriver_textOpacity
      else: return self.fn_unset_DisplayDriver_textOpacity
   @textOpacity.setter
   def textOpacity(self, value):
      self.fn_DisplayDriver_textOpacity = value
      lib.Instance_setMethod(self.impl, "TextOpacity".encode('u8'), cb_DisplayDriver_textOpacity)

   def fn_unset_DisplayDriver_unloadFont(self, ap1, ap2):
      return lib.DisplayDriver_unloadFont(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl)

   @property
   def unloadFont(self):
      if hasattr(self, 'fn_DisplayDriver_unloadFont'): return self.fn_DisplayDriver_unloadFont
      else: return self.fn_unset_DisplayDriver_unloadFont
   @unloadFont.setter
   def unloadFont(self, value):
      self.fn_DisplayDriver_unloadFont = value
      lib.Instance_setMethod(self.impl, "UnloadFont".encode('u8'), cb_DisplayDriver_unloadFont)

   def fn_unset_DisplayDriver_unlock(self, ap1):
      return lib.DisplayDriver_unlock(self.impl, ffi.NULL if ap1 is None else ap1.impl)

   @property
   def unlock(self):
      if hasattr(self, 'fn_DisplayDriver_unlock'): return self.fn_DisplayDriver_unlock
      else: return self.fn_unset_DisplayDriver_unlock
   @unlock.setter
   def unlock(self, value):
      self.fn_DisplayDriver_unlock = value
      lib.Instance_setMethod(self.impl, "Unlock".encode('u8'), cb_DisplayDriver_unlock)

   def fn_unset_DisplayDriver_unlockIndices(self, ap1, group, indices32bit, nIndices, maeb):
      return lib.DisplayDriver_unlockIndices(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if group is None else group.impl, indices32bit, nIndices, maeb)

   @property
   def unlockIndices(self):
      if hasattr(self, 'fn_DisplayDriver_unlockIndices'): return self.fn_DisplayDriver_unlockIndices
      else: return self.fn_unset_DisplayDriver_unlockIndices
   @unlockIndices.setter
   def unlockIndices(self, value):
      self.fn_DisplayDriver_unlockIndices = value
      lib.Instance_setMethod(self.impl, "UnlockIndices".encode('u8'), cb_DisplayDriver_unlockIndices)

   def fn_unset_DisplayDriver_unlockMesh(self, ap1, ap2, flags):
      return lib.DisplayDriver_unlockMesh(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, flags)

   @property
   def unlockMesh(self):
      if hasattr(self, 'fn_DisplayDriver_unlockMesh'): return self.fn_DisplayDriver_unlockMesh
      else: return self.fn_unset_DisplayDriver_unlockMesh
   @unlockMesh.setter
   def unlockMesh(self, value):
      self.fn_DisplayDriver_unlockMesh = value
      lib.Instance_setMethod(self.impl, "UnlockMesh".encode('u8'), cb_DisplayDriver_unlockMesh)

   def fn_unset_DisplayDriver_unlockSystem(self, displaySystem):
      return lib.DisplayDriver_unlockSystem(self.impl, ffi.NULL if displaySystem is None else displaySystem.impl)

   @property
   def unlockSystem(self):
      if hasattr(self, 'fn_DisplayDriver_unlockSystem'): return self.fn_DisplayDriver_unlockSystem
      else: return self.fn_unset_DisplayDriver_unlockSystem
   @unlockSystem.setter
   def unlockSystem(self, value):
      self.fn_DisplayDriver_unlockSystem = value
      lib.Instance_setMethod(self.impl, "UnlockSystem".encode('u8'), cb_DisplayDriver_unlockSystem)

   def fn_unset_DisplayDriver_update(self, ap1, ap2):
      return lib.DisplayDriver_update(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl)

   @property
   def update(self):
      if hasattr(self, 'fn_DisplayDriver_update'): return self.fn_DisplayDriver_update
      else: return self.fn_unset_DisplayDriver_update
   @update.setter
   def update(self, value):
      self.fn_DisplayDriver_update = value
      lib.Instance_setMethod(self.impl, "Update".encode('u8'), cb_DisplayDriver_update)

   def fn_unset_DisplayDriver_writeText(self, ap1, ap2, x, y, text, len, prevGlyph, rPrevGlyph):
      if rPrevGlyph is None: rPrevGlyph = ffi.NULL
      return lib.DisplayDriver_writeText(self.impl, ffi.NULL if ap1 is None else ap1.impl, ffi.NULL if ap2 is None else ap2.impl, x, y, ffi.NULL if text is None else text.impl, len, prevGlyph, rPrevGlyph)

   @property
   def writeText(self):
      if hasattr(self, 'fn_DisplayDriver_writeText'): return self.fn_DisplayDriver_writeText
      else: return self.fn_unset_DisplayDriver_writeText
   @writeText.setter
   def writeText(self, value):
      self.fn_DisplayDriver_writeText = value
      lib.Instance_setMethod(self.impl, "WriteText".encode('u8'), cb_DisplayDriver_writeText)

class DisplayFlags(pyBaseClass):
   def __init__(self, fullScreen = False, flipping = False, alpha = False, memBackBuffer = False, text = False, scrolling = False, printer = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(fullScreen, DisplayFlags):
         self.impl = fullScreen.impl
      else:
         self.impl = (
            (fullScreen    << lib.DISPLAYFLAGS_fullScreen_SHIFT)    |
            (flipping      << lib.DISPLAYFLAGS_flipping_SHIFT)      |
            (alpha         << lib.DISPLAYFLAGS_alpha_SHIFT)         |
            (memBackBuffer << lib.DISPLAYFLAGS_memBackBuffer_SHIFT) |
            (text          << lib.DISPLAYFLAGS_text_SHIFT)          |
            (scrolling     << lib.DISPLAYFLAGS_scrolling_SHIFT)     |
            (printer       << lib.DISPLAYFLAGS_printer_SHIFT)       )

   @property
   def fullScreen(self): return ((((self.impl)) & lib.DISPLAYFLAGS_fullScreen_MASK) >> lib.DISPLAYFLAGS_fullScreen_SHIFT)
   @fullScreen.setter
   def fullScreen(self, value): self.impl = ((self.impl) & ~(lib.DISPLAYFLAGS_fullScreen_MASK)) | (((value)) << lib.DISPLAYFLAGS_fullScreen_SHIFT)

   @property
   def flipping(self): return ((((self.impl)) & lib.DISPLAYFLAGS_flipping_MASK) >> lib.DISPLAYFLAGS_flipping_SHIFT)
   @flipping.setter
   def flipping(self, value): self.impl = ((self.impl) & ~(lib.DISPLAYFLAGS_flipping_MASK)) | (((value)) << lib.DISPLAYFLAGS_flipping_SHIFT)

   @property
   def alpha(self): return ((((self.impl)) & lib.DISPLAYFLAGS_alpha_MASK) >> lib.DISPLAYFLAGS_alpha_SHIFT)
   @alpha.setter
   def alpha(self, value): self.impl = ((self.impl) & ~(lib.DISPLAYFLAGS_alpha_MASK)) | (((value)) << lib.DISPLAYFLAGS_alpha_SHIFT)

   @property
   def memBackBuffer(self): return ((((self.impl)) & lib.DISPLAYFLAGS_memBackBuffer_MASK) >> lib.DISPLAYFLAGS_memBackBuffer_SHIFT)
   @memBackBuffer.setter
   def memBackBuffer(self, value): self.impl = ((self.impl) & ~(lib.DISPLAYFLAGS_memBackBuffer_MASK)) | (((value)) << lib.DISPLAYFLAGS_memBackBuffer_SHIFT)

   @property
   def text(self): return ((((self.impl)) & lib.DISPLAYFLAGS_text_MASK) >> lib.DISPLAYFLAGS_text_SHIFT)
   @text.setter
   def text(self, value): self.impl = ((self.impl) & ~(lib.DISPLAYFLAGS_text_MASK)) | (((value)) << lib.DISPLAYFLAGS_text_SHIFT)

   @property
   def scrolling(self): return ((((self.impl)) & lib.DISPLAYFLAGS_scrolling_MASK) >> lib.DISPLAYFLAGS_scrolling_SHIFT)
   @scrolling.setter
   def scrolling(self, value): self.impl = ((self.impl) & ~(lib.DISPLAYFLAGS_scrolling_MASK)) | (((value)) << lib.DISPLAYFLAGS_scrolling_SHIFT)

   @property
   def printer(self): return ((((self.impl)) & lib.DISPLAYFLAGS_printer_MASK) >> lib.DISPLAYFLAGS_printer_SHIFT)
   @printer.setter
   def printer(self, value): self.impl = ((self.impl) & ~(lib.DISPLAYFLAGS_printer_MASK)) | (((value)) << lib.DISPLAYFLAGS_printer_SHIFT)

class DisplaySystem(Instance):
   class_members = [
                      'pixelFormat',
                      'flags',
                   ]

   def init_args(self, args, kwArgs): init_args(DisplaySystem, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def pixelFormat(self): return PixelFormat(impl = IPTR(lib, ffi, self, DisplaySystem).pixelFormat)
   @pixelFormat.setter
   def pixelFormat(self, value): IPTR(lib, ffi, self, DisplaySystem).pixelFormat = value.impl

   @property
   def flags(self): return DisplayFlags(impl = IPTR(lib, ffi, self, DisplaySystem).flags)
   @flags.setter
   def flags(self, value):
      if not isinstance(value, DisplayFlags): value = DisplayFlags(value)
      IPTR(lib, ffi, self, DisplaySystem).flags = value.impl

   def addMaterial(self, material = None):
      if material is not None and not isinstance(material, Material): material = Material(material)
      material = ffi.NULL if material is None else material.impl
      return lib.DisplaySystem_addMaterial(self.impl, ffi.cast("struct eC_Material *", material))

   def addMesh(self, mesh = None):
      if mesh is not None and not isinstance(mesh, Mesh): mesh = Mesh(mesh)
      mesh = ffi.NULL if mesh is None else mesh.impl
      return lib.DisplaySystem_addMesh(self.impl, ffi.cast("struct eC_Mesh *", mesh))

   def addNamedMaterial(self, name):
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      return lib.DisplaySystem_addNamedMaterial(self.impl, name)

   def addTexture(self, name, bitmap = None):
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      if bitmap is not None and not isinstance(bitmap, Bitmap): bitmap = Bitmap(bitmap)
      bitmap = ffi.NULL if bitmap is None else bitmap.impl
      return lib.DisplaySystem_addTexture(self.impl, name, bitmap)

   def clearMaterials(self):
      lib.DisplaySystem_clearMaterials(self.impl)

   def clearMeshes(self):
      lib.DisplaySystem_clearMeshes(self.impl)

   def clearTextures(self):
      lib.DisplaySystem_clearTextures(self.impl)

   def create(self, driverName, window, fullScreen):
      if isinstance(driverName, str): driverName = ffi.new("char[]", driverName.encode('u8'))
      elif driverName is None: driverName = ffi.NULL
      if hasattr(window, 'impl'): window = window.impl
      if window is None: window = ffi.NULL
      return lib.DisplaySystem_create(self.impl, driverName, window, fullScreen)

   def fontExtent(self, font, text, len):
      if font is not None and not isinstance(font, Font): font = Font(font)
      font = ffi.NULL if font is None else font.impl
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      width = ffi.new("int *")
      height = ffi.new("int *")
      lib.DisplaySystem_fontExtent(self.impl, ffi.cast("struct eC_Font *", font), text, len, width, height)
      return width[0], height[0]

   def fontExtent2(self, font, text, len, prevGlyph):
      if font is not None and not isinstance(font, Font): font = Font(font)
      font = ffi.NULL if font is None else font.impl
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      width = ffi.new("int *")
      height = ffi.new("int *")
      rPrevGlyph = ffi.new("int *")
      overHang = ffi.new("int *")
      lib.DisplaySystem_fontExtent2(self.impl, ffi.cast("struct eC_Font *", font), text, len, width, height, prevGlyph, rPrevGlyph, overHang)
      return width[0], height[0], rPrevGlyph[0], overHang[0]

   def getMaterial(self, name):
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      return lib.DisplaySystem_getMaterial(self.impl, name)

   def getTexture(self, name):
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      return pyOrNewObject(Bitmap, lib.DisplaySystem_getTexture(self.impl, name))

   def loadFont(self, faceName, size, flags):
      if isinstance(faceName, str): faceName = ffi.new("char[]", faceName.encode('u8'))
      elif faceName is None: faceName = ffi.NULL
      if flags is not None and not isinstance(flags, FontFlags): flags = FontFlags(flags)
      if flags is None: flags = ffi.NULL
      return lib.DisplaySystem_loadFont(self.impl, faceName, size, flags)

   def loadOutlineFont(self, faceName, size, flags, outlineSize, outlineFade):
      if isinstance(faceName, str): faceName = ffi.new("char[]", faceName.encode('u8'))
      elif faceName is None: faceName = ffi.NULL
      if flags is not None and not isinstance(flags, FontFlags): flags = FontFlags(flags)
      if flags is None: flags = ffi.NULL
      return lib.DisplaySystem_loadOutlineFont(self.impl, faceName, size, flags, outlineSize, outlineFade)

   def loadResource(self, resource = None):
      if resource is not None and not isinstance(resource, Resource): resource = Resource(resource)
      resource = ffi.NULL if resource is None else resource.impl
      return lib.DisplaySystem_loadResource(self.impl, resource)

   def loadResourceFM(self, resource = None, fm = None):
      if resource is not None and not isinstance(resource, Resource): resource = Resource(resource)
      resource = ffi.NULL if resource is None else resource.impl
      if fm is not None and not isinstance(fm, FontManager): fm = FontManager(fm)
      fm = ffi.NULL if fm is None else fm.impl
      return lib.DisplaySystem_loadResourceFM(self.impl, resource, fm)

   def lock(self):
      return lib.DisplaySystem_lock(self.impl)

   def removeMaterial(self, material = None):
      if material is not None and not isinstance(material, Material): material = Material(material)
      material = ffi.NULL if material is None else material.impl
      return lib.DisplaySystem_removeMaterial(self.impl, ffi.cast("struct eC_Material *", material))

   def removeMesh(self, mesh = None):
      if mesh is not None and not isinstance(mesh, Mesh): mesh = Mesh(mesh)
      mesh = ffi.NULL if mesh is None else mesh.impl
      return lib.DisplaySystem_removeMesh(self.impl, ffi.cast("struct eC_Mesh *", mesh))

   def removeTexture(self, name):
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      return lib.DisplaySystem_removeTexture(self.impl, name)

   def unloadFont(self, font = None):
      if font is not None and not isinstance(font, Font): font = Font(font)
      font = ffi.NULL if font is None else font.impl
      lib.DisplaySystem_unloadFont(self.impl, ffi.cast("struct eC_Font *", font))

   def unloadResource(self, resource = None, res = None):
      if resource is not None and not isinstance(resource, Resource): resource = Resource(resource)
      resource = ffi.NULL if resource is None else resource.impl
      if res is not None and not isinstance(res, DisplaySystemResPtr): res = DisplaySystemResPtr(res)
      res = ffi.NULL if res is None else res.impl
      lib.DisplaySystem_unloadResource(self.impl, resource, ffi.cast("struct eC_DisplaySystemResPtr *", res))

   def unlock(self):
      lib.DisplaySystem_unlock(self.impl)

   def _LoadResource(self, resource, fm):
      if resource is not None and not isinstance(resource, Resource): resource = Resource(resource)
      resource = ffi.NULL if resource is None else resource.impl
      if hasattr(fm, 'impl'): fm = fm.impl
      if fm is None: fm = ffi.NULL
      return lib.DisplaySystem__LoadResource(self.impl, resource, fm)

class DisplaySystemResPtr:
   def __init__(self, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_DisplaySystemResPtr *", lib.Instance_new(lib.class_DisplaySystemResPtr))

class DrawList(Instance):
   class_members = []

   def init_args(self, args, kwArgs): init_args(DrawList, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def addObject(self, object = None):
      if object is not None and not isinstance(object, Object): object = Object(object)
      object = ffi.NULL if object is None else object.impl
      lib.DrawList_addObject(self.impl, ffi.cast("struct eC_Object *", object))

   def init(self, sm, vm, cp, vp, wp, guessCount):
      if sm is not None and not isinstance(sm, Matrix): sm = Matrix(sm)
      sm = ffi.NULL if sm is None else sm.impl
      if vm is not None and not isinstance(vm, Matrix): vm = Matrix(vm)
      vm = ffi.NULL if vm is None else vm.impl
      if cp is not None and not isinstance(cp, Vector3D): cp = Vector3D(cp)
      cp = ffi.NULL if cp is None else cp.impl
      lib.DrawList_init(self.impl, ffi.cast("eC_Matrix *", sm), ffi.cast("eC_Matrix *", vm), ffi.cast("eC_Vector3D *", cp), vp, wp, guessCount)

   def prepare(self):
      lib.DrawList_prepare(self.impl)

   def render(self, display = None):
      if display is not None and not isinstance(display, Display): display = Display(display)
      display = ffi.NULL if display is None else display.impl
      lib.DrawList_render(self.impl, display)

@ffi.callback("void(eC_DrawManager)")
def cb_DrawManager_flush(__e):
   drawmanager = pyOrNewObject(DrawManager, __e)
   drawmanager.fn_DrawManager_flush(drawmanager)

class DrawManager(Instance):
   class_members = [
                      'renderingFlipped',
                      'flush',
                   ]

   def init_args(self, args, kwArgs): init_args(DrawManager, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def renderingFlipped(self): return None
   @renderingFlipped.setter
   def renderingFlipped(self, value):
      lib.DrawManager_set_renderingFlipped(self.impl, value)

   def clear(self):
      lib.DrawManager_clear(self.impl)

   def drawBarrier(self):
      lib.DrawManager_drawBarrier(self.impl)

   def drawImage(self, index, offsetx, offsety, angsin, angcos, color):
      if color is not None and not isinstance(color, ColorAlpha): color = ColorAlpha(color)
      if color is None: color = ffi.NULL
      lib.DrawManager_drawImage(self.impl, index, offsetx, offsety, angsin, angcos, color)

   def end(self):
      lib.DrawManager_end(self.impl)

   def finish(self):
      lib.DrawManager_finish(self.impl)

   def fn_unset_DrawManager_flush(self):
      return lib.DrawManager_flush(self.impl)

   @property
   def flush(self):
      if hasattr(self, 'fn_DrawManager_flush'): return self.fn_DrawManager_flush
      else: return self.fn_unset_DrawManager_flush
   @flush.setter
   def flush(self, value):
      self.fn_DrawManager_flush = value
      lib.Instance_setMethod(self.impl, "flush".encode('u8'), cb_DrawManager_flush)

   def init(self):
      return lib.DrawManager_init(self.impl)

   def ready(self, viewportWidth, viewportHeight):
      lib.DrawManager_ready(self.impl, viewportWidth, viewportHeight)

class DrawSlot(Struct):
   def __init__(self, object = None, baseMap = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_DrawSlot *", impl)
      else:
         if isinstance(object, tuple):
            __tuple = object
            object = None
            if len(__tuple) > 0: object  = __tuple[0]
            if len(__tuple) > 1: baseMap = __tuple[1]
         if object is not None:
            if not isinstance(object, Object): object = Object(object)
            object = object.impl
         else:
            object = ffi.NULL
         if baseMap is not None:
            if not isinstance(baseMap, Bitmap): baseMap = Bitmap(baseMap)
            baseMap = baseMap.impl
         else:
            baseMap = ffi.NULL
         self.impl = ffi.new("eC_DrawSlot *", { 'object' : object, 'baseMap' : baseMap })

   @property
   def object(self): return self.impl.object
   @object.setter
   def object(self, value):
      if not isinstance(value, Object): value = Object(value)
      self.impl.object = value.impl

   @property
   def baseMap(self): return pyOrNewObject(Bitmap, self.impl.baseMap)
   @baseMap.setter
   def baseMap(self, value):
      if not isinstance(value, Bitmap): value = Bitmap(value)
      self.impl.baseMap = value.impl

class FMFont:
   def __init__(self, link = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_FMFont *", lib.Instance_new(lib.class_FMFont))
         if link is not None: self.link = link

   @property
   def link(self): return LinkElement(impl = self.impl.link)
   @link.setter
   def link(self, value): self.impl.link = value.impl[0]

   def setOutline(self, size, fade):
      lib.FMFont_setOutline(ffi.cast("struct eC_FMFont *", self.impl), size, fade)

class FMPathDraw(Struct):
   def __init__(self, prevGlyphIndex = 0, middleAlign = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_FMPathDraw *", impl)
      else:
         if isinstance(prevGlyphIndex, tuple):
            __tuple = prevGlyphIndex
            prevGlyphIndex = 0
            if len(__tuple) > 0: prevGlyphIndex = __tuple[0]
            if len(__tuple) > 1: middleAlign    = __tuple[1]
         self.impl = ffi.new("eC_FMPathDraw *", { 'prevGlyphIndex' : prevGlyphIndex, 'middleAlign' : middleAlign })

   @property
   def prevGlyphIndex(self): return self.impl.prevGlyphIndex
   @prevGlyphIndex.setter
   def prevGlyphIndex(self, value): self.impl.prevGlyphIndex = value

   @property
   def middleAlign(self): return self.impl.middleAlign
   @middleAlign.setter
   def middleAlign(self, value): self.impl.middleAlign = value

class FMTextAlignment(pyBaseClass):
   def __init__(self, horzAlignment = 0, vertAlignment = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(horzAlignment, FMTextAlignment):
         self.impl = horzAlignment.impl
      else:
         if isinstance(horzAlignment, tuple):
            __tuple = horzAlignment
            horzAlignment = 0
            if len(__tuple) > 0: horzAlignment = __tuple[0]
            if len(__tuple) > 1: vertAlignment = __tuple[1]
         self.impl = (
            (horzAlignment << lib.FMTEXTALIGNMENT_horzAlignment_SHIFT) |
            (vertAlignment << lib.FMTEXTALIGNMENT_vertAlignment_SHIFT) )

   @property
   def horzAlignment(self): return ((((self.impl)) & lib.FMTEXTALIGNMENT_horzAlignment_MASK) >> lib.FMTEXTALIGNMENT_horzAlignment_SHIFT)
   @horzAlignment.setter
   def horzAlignment(self, value): self.impl = ((self.impl) & ~(lib.FMTEXTALIGNMENT_horzAlignment_MASK)) | (((value)) << lib.FMTEXTALIGNMENT_horzAlignment_SHIFT)

   @property
   def vertAlignment(self): return ((((self.impl)) & lib.FMTEXTALIGNMENT_vertAlignment_MASK) >> lib.FMTEXTALIGNMENT_vertAlignment_SHIFT)
   @vertAlignment.setter
   def vertAlignment(self, value): self.impl = ((self.impl) & ~(lib.FMTEXTALIGNMENT_vertAlignment_MASK)) | (((value)) << lib.FMTEXTALIGNMENT_vertAlignment_SHIFT)

class FMVerticalAlignment:
   baseline = lib.FMVerticalAlignment_baseline
   top      = lib.FMVerticalAlignment_top
   middle   = lib.FMVerticalAlignment_middle
   bottom   = lib.FMVerticalAlignment_bottom

class FaceInfo:
   def __init__(self, fileName = None, fakeItalic = None, fontID = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_FaceInfo *", lib.Instance_new(lib.class_FaceInfo))
         if isinstance(fileName, tuple):
            __tuple = fileName
            fileName = None
            if len(__tuple) > 0: fileName   = __tuple[0]
            if len(__tuple) > 1: fakeItalic = __tuple[1]
            if len(__tuple) > 2: fontID     = __tuple[2]
         if fileName is not None:   self.fileName   = fileName
         if fakeItalic is not None: self.fakeItalic = fakeItalic
         if fontID is not None:     self.fontID     = fontID

   @property
   def fileName(self): return String(self.impl.fileName)
   @fileName.setter
   def fileName(self, value):
      if isinstance(value, str): value = ffi.new("char[]", value.encode('u8'))
      elif value is None: value = ffi.NULL
      self.impl.fileName = value

   @property
   def fakeItalic(self): return self.impl.fakeItalic
   @fakeItalic.setter
   def fakeItalic(self, value): self.impl.fakeItalic = value

   @property
   def fontID(self): return self.impl.fontID
   @fontID.setter
   def fontID(self, value): self.impl.fontID = value

class FillModeValue:
   solid     = lib.FillModeValue_solid
   wireframe = lib.FillModeValue_wireframe

class Font:
   def __init__(self, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_Font *", lib.Instance_new(lib.class_Font))

   @property
   def ascent(self): return lib.Font_get_ascent(ffi.cast("struct eC_Font *", self.impl))

   @property
   def descent(self): return lib.Font_get_descent(ffi.cast("struct eC_Font *", self.impl))

class FontFlags(pyBaseClass):
   def __init__(self, bold = False, italic = False, underline = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(bold, FontFlags):
         self.impl = bold.impl
      else:
         if isinstance(bold, tuple):
            __tuple = bold
            bold = False
            if len(__tuple) > 0: bold = __tuple[0]
            if len(__tuple) > 1: italic = __tuple[1]
            if len(__tuple) > 2: underline = __tuple[2]
         self.impl = (
            (bold      << lib.FONTFLAGS_bold_SHIFT)      |
            (italic    << lib.FONTFLAGS_italic_SHIFT)    |
            (underline << lib.FONTFLAGS_underline_SHIFT) )

   @property
   def bold(self): return ((((self.impl)) & lib.FONTFLAGS_bold_MASK) >> lib.FONTFLAGS_bold_SHIFT)
   @bold.setter
   def bold(self, value): self.impl = ((self.impl) & ~(lib.FONTFLAGS_bold_MASK)) | (((value)) << lib.FONTFLAGS_bold_SHIFT)

   @property
   def italic(self): return ((((self.impl)) & lib.FONTFLAGS_italic_MASK) >> lib.FONTFLAGS_italic_SHIFT)
   @italic.setter
   def italic(self, value): self.impl = ((self.impl) & ~(lib.FONTFLAGS_italic_MASK)) | (((value)) << lib.FONTFLAGS_italic_SHIFT)

   @property
   def underline(self): return ((((self.impl)) & lib.FONTFLAGS_underline_MASK) >> lib.FONTFLAGS_underline_SHIFT)
   @underline.setter
   def underline(self, value): self.impl = ((self.impl) & ~(lib.FONTFLAGS_underline_MASK)) | (((value)) << lib.FONTFLAGS_underline_SHIFT)

class FontInfo(Struct):
   def __init__(self, fixedPitch = False, defaultOrAnsiCharSet = False, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_FontInfo *", impl)
      else:
         if isinstance(fixedPitch, tuple):
            __tuple = fixedPitch
            fixedPitch = False
            if len(__tuple) > 0: fixedPitch           = __tuple[0]
            if len(__tuple) > 1: defaultOrAnsiCharSet = __tuple[1]
         self.impl = ffi.new("eC_FontInfo *", { 'fixedPitch' : fixedPitch, 'defaultOrAnsiCharSet' : defaultOrAnsiCharSet })

   @property
   def fixedPitch(self): return self.impl.fixedPitch
   @fixedPitch.setter
   def fixedPitch(self, value): self.impl.fixedPitch = value

   @property
   def defaultOrAnsiCharSet(self): return self.impl.defaultOrAnsiCharSet
   @defaultOrAnsiCharSet.setter
   def defaultOrAnsiCharSet(self, value): self.impl.defaultOrAnsiCharSet = value

@ffi.callback("void(eC_FontManager)")
def cb_FontManager_onAtlasFull(__e):
   fontmanager = pyOrNewObject(FontManager, __e)
   fontmanager.fn_FontManager_onAtlasFull(fontmanager)

class FontManager(Instance):
   class_members = [
                      'renderer',
                      'onAtlasFull',
                   ]

   def init_args(self, args, kwArgs): init_args(FontManager, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def renderer(self): return pyOrNewObject(FontManagerRenderer, lib.FontManager_get_renderer(self.impl))
   @renderer.setter
   def renderer(self, value):
      if not isinstance(value, FontManagerRenderer): value = FontManagerRenderer(value)
      lib.FontManager_set_renderer(self.impl, value.impl)

   def addFont(self, path, glyphPaddingWidth):
      if isinstance(path, str): path = ffi.new("char[]", path.encode('u8'))
      elif path is None: path = ffi.NULL
      return lib.FontManager_addFont(self.impl, path, glyphPaddingWidth)

   def addFontData(self, data, dataSize, glyphPaddingWidth):
      return lib.FontManager_addFontData(self.impl, data, dataSize, glyphPaddingWidth)

   def clearState(self):
      lib.FontManager_clearState(self.impl)

   def create(self, width, height, channelCount, channelIndex, renderer = None):
      if renderer is not None and not isinstance(renderer, FontManagerRenderer): renderer = FontManagerRenderer(renderer)
      renderer = ffi.NULL if renderer is None else renderer.impl
      return lib.FontManager_create(self.impl, width, height, channelCount, channelIndex, renderer)

   def drawText(self, x, y, string, stringlength):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      return lib.FontManager_drawText(self.impl, x, y, string, stringlength)

   def drawTextTruncate(self, x, y, truncatewidth, string, stringlength, extstring, extwidth):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      if isinstance(extstring, str): extstring = ffi.new("char[]", extstring.encode('u8'))
      elif extstring is None: extstring = ffi.NULL
      return lib.FontManager_drawTextTruncate(self.impl, x, y, truncatewidth, string, stringlength, extstring, extwidth)

   def drawTextWithCursor(self, x, y, string, stringlength, cursoroffset):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      return lib.FontManager_drawTextWithCursor(self.impl, x, y, string, stringlength, cursoroffset)

   def expandAtlas(self, width, height):
      return lib.FontManager_expandAtlas(self.impl, width, height)

   def flush(self, rendererFlush):
      lib.FontManager_flush(self.impl, rendererFlush)

   def flushUpdate(self):
      lib.FontManager_flushUpdate(self.impl)

   def freeFont(self, font = None):
      if font is not None and not isinstance(font, FMFont): font = FMFont(font)
      font = ffi.NULL if font is None else font.impl
      lib.FontManager_freeFont(self.impl, ffi.cast("struct eC_FMFont *", font))

   def getAtlasSize(self):
      retwidth = ffi.new("int *")
      retheight = ffi.new("int *")
      lib.FontManager_getAtlasSize(self.impl, retwidth, retheight)
      return retwidth[0], retheight[0]

   def getFont(self, fontResource = None):
      if fontResource is not None and not isinstance(fontResource, FontResource): fontResource = FontResource(fontResource)
      fontResource = ffi.NULL if fontResource is None else fontResource.impl
      return lib.FontManager_getFont(self.impl, fontResource)

   def getFontExtent(self):
      retascent = ffi.new("int *")
      retdescent = ffi.new("int *")
      lib.FontManager_getFontExtent(self.impl, retascent, retdescent)
      return retascent[0], retdescent[0]

   def getFontLimits(self):
      retlimitminy = ffi.new("int *")
      retlimitmaxy = ffi.new("int *")
      lib.FontManager_getFontLimits(self.impl, retlimitminy, retlimitmaxy)
      return retlimitminy[0], retlimitmaxy[0]

   def getFontLineHeight(self):
      return lib.FontManager_getFontLineHeight(self.impl)

   def getTextBounds(self, x, y, string, stringlength):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      bounds = ffi.new("int *")
      r = lib.FontManager_getTextBounds(self.impl, x, y, string, stringlength, bounds)
      return r, bounds[0]

   def getTextNearestOffset(self, targetwidth, string, stringlength):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      return lib.FontManager_getTextNearestOffset(self.impl, targetwidth, string, stringlength)

   def getTextTruncateOffset(self, truncatewidth, string, stringlength, extwidth):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      retextflag = ffi.new("int *")
      retfullwidth = ffi.new("int *")
      r = lib.FontManager_getTextTruncateOffset(self.impl, truncatewidth, string, stringlength, extwidth, retextflag, retfullwidth)
      return r, retextflag[0], retfullwidth[0]

   def getTextWidth(self, string, stringlength):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      return lib.FontManager_getTextWidth(self.impl, string, stringlength)

   def getTextWidthTruncate(self, string, stringlength, truncatewidth):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      return lib.FontManager_getTextWidthTruncate(self.impl, string, stringlength, truncatewidth)

   def getTextureData(self):
      width = ffi.new("int *")
      height = ffi.new("int *")
      r = lib.FontManager_getTextureData(self.impl, width, height)
      return r, width[0], height[0]

   def initPathDraw(self, pathdraw = None):
      if pathdraw is not None and not isinstance(pathdraw, FMPathDraw): pathdraw = FMPathDraw(pathdraw)
      pathdraw = ffi.NULL if pathdraw is None else pathdraw.impl
      return lib.FontManager_initPathDraw(self.impl, ffi.cast("eC_FMPathDraw *", pathdraw))

   def fn_unset_FontManager_onAtlasFull(self):
      return lib.FontManager_onAtlasFull(self.impl)

   @property
   def onAtlasFull(self):
      if hasattr(self, 'fn_FontManager_onAtlasFull'): return self.fn_FontManager_onAtlasFull
      else: return self.fn_unset_FontManager_onAtlasFull
   @onAtlasFull.setter
   def onAtlasFull(self, value):
      self.fn_FontManager_onAtlasFull = value
      lib.Instance_setMethod(self.impl, "onAtlasFull".encode('u8'), cb_FontManager_onAtlasFull)

   def pathDrawCharacter(self, pathdraw, x, y, vectorx, vectory, unicode):
      if pathdraw is not None and not isinstance(pathdraw, FMPathDraw): pathdraw = FMPathDraw(pathdraw)
      pathdraw = ffi.NULL if pathdraw is None else pathdraw.impl
      return lib.FontManager_pathDrawCharacter(self.impl, ffi.cast("eC_FMPathDraw *", pathdraw), x, y, vectorx, vectory, unicode)

   def pathDrawPredictAdvance(self, pathdraw, unicode):
      if pathdraw is not None and not isinstance(pathdraw, FMPathDraw): pathdraw = FMPathDraw(pathdraw)
      pathdraw = ffi.NULL if pathdraw is None else pathdraw.impl
      if unicode is not None and not isinstance(unicode, unichar): unicode = unichar(unicode)
      if unicode is None: unicode = ffi.NULL
      return lib.FontManager_pathDrawPredictAdvance(self.impl, ffi.cast("eC_FMPathDraw *", pathdraw), unicode)

   def popState(self):
      lib.FontManager_popState(self.impl)

   def pushState(self):
      lib.FontManager_pushState(self.impl)

   def removeFont(self, font = None):
      if font is not None and not isinstance(font, FMFont): font = FMFont(font)
      font = ffi.NULL if font is None else font.impl
      lib.FontManager_removeFont(self.impl, ffi.cast("struct eC_FMFont *", font))

   def resetAtlas(self, width, height):
      return lib.FontManager_resetAtlas(self.impl, width, height)

   def setAlign(self, align):
      lib.FontManager_setAlign(self.impl, align)

   def setFont(self, font = None):
      if font is not None and not isinstance(font, FMFont): font = FMFont(font)
      font = ffi.NULL if font is None else font.impl
      lib.FontManager_setFont(self.impl, ffi.cast("struct eC_FMFont *", font))

   def setFontImageProcessing(self, font, processImage, opaquecontext):
      if font is not None and not isinstance(font, FMFont): font = FMFont(font)
      font = ffi.NULL if font is None else font.impl
      if hasattr(opaquecontext, 'impl'): opaquecontext = opaquecontext.impl
      if opaquecontext is None: opaquecontext = ffi.NULL
      lib.FontManager_setFontImageProcessing(self.impl, ffi.cast("struct eC_FMFont *", font), opaquecontext)

   def setSize(self, size):
      lib.FontManager_setSize(self.impl, size)

   def setState(self, font, size, align):
      if font is not None and not isinstance(font, FMFont): font = FMFont(font)
      font = ffi.NULL if font is None else font.impl
      lib.FontManager_setState(self.impl, ffi.cast("struct eC_FMFont *", font), size, align)

   def validateTexture(self):
      retdirtyrect = ffi.new("int *")
      r = lib.FontManager_validateTexture(self.impl, retdirtyrect)
      return r, retdirtyrect[0]

class FontRenderer(FontManagerRenderer):
   class_members = [
                      'drawManager',
                   ]

   def init_args(self, args, kwArgs): init_args(FontRenderer, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def drawManager(self): return None
   @drawManager.setter
   def drawManager(self, value):
      if not isinstance(value, DrawManager): value = DrawManager(value)
      lib.FontRenderer_set_drawManager(self.impl, value.impl)

   def setColor(self, color):
      if color is not None and not isinstance(color, ColorAlpha): color = ColorAlpha(color)
      if color is None: color = ffi.NULL
      lib.FontRenderer_setColor(self.impl, color)

   def setCursorColor(self, color):
      if color is not None and not isinstance(color, ColorAlpha): color = ColorAlpha(color)
      if color is None: color = ffi.NULL
      lib.FontRenderer_setCursorColor(self.impl, color)

   def setExtColor(self, color):
      if color is not None and not isinstance(color, ColorAlpha): color = ColorAlpha(color)
      if color is None: color = ffi.NULL
      lib.FontRenderer_setExtColor(self.impl, color)

class FontResource(Resource):
   class_members = [
                      'faceName',
                      'size',
                      'bold',
                      'italic',
                      'underline',
                      'font',
                      'window',
                      'outlineSize',
                      'outlineFade',
                      'fmFont',
                   ]

   def init_args(self, args, kwArgs): init_args(FontResource, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def faceName(self): value = lib.FontResource_get_faceName(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @faceName.setter
   def faceName(self, value):
      lib.FontResource_set_faceName(self.impl, value.encode('u8'))

   @property
   def size(self): return lib.FontResource_get_size(self.impl)
   @size.setter
   def size(self, value):
      lib.FontResource_set_size(self.impl, value)

   @property
   def bold(self): return lib.FontResource_get_bold(self.impl)
   @bold.setter
   def bold(self, value):
      lib.FontResource_set_bold(self.impl, value)

   @property
   def italic(self): return lib.FontResource_get_italic(self.impl)
   @italic.setter
   def italic(self, value):
      lib.FontResource_set_italic(self.impl, value)

   @property
   def underline(self): return lib.FontResource_get_underline(self.impl)
   @underline.setter
   def underline(self, value):
      lib.FontResource_set_underline(self.impl, value)

   @property
   def font(self): return Font(impl = lib.FontResource_get_font(self.impl))

   @property
   def window(self): return None
   @window.setter
   def window(self, value):
      if not isinstance(value, Window): value = Window(value)
      lib.FontResource_set_window(self.impl, value.impl)

   @property
   def outlineSize(self): return lib.FontResource_get_outlineSize(self.impl)
   @outlineSize.setter
   def outlineSize(self, value):
      lib.FontResource_set_outlineSize(self.impl, value)

   @property
   def outlineFade(self): return lib.FontResource_get_outlineFade(self.impl)
   @outlineFade.setter
   def outlineFade(self, value):
      lib.FontResource_set_outlineFade(self.impl, value)

   @property
   def fmFont(self): return FMFont(impl = lib.FontResource_get_fmFont(self.impl))

class GLCapabilities(pyBaseClass):
   def __init__(self, compatible = False, vertexBuffer = False, quads = False, intAndDouble = False, legacyFormats = False, nonPow2Textures = False, vertexPointer = False, legacy = False, shaders = False, fixedFunction = False, immediate = False, frameBuffer = False, pointSize = False, vao = False, select = False, debug = False, gpuCommands = False, mdei = False, samples = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(compatible, GLCapabilities):
         self.impl = compatible.impl
      else:
         self.impl = (
            (compatible      << lib.GLCAPABILITIES_compatible_SHIFT)      |
            (vertexBuffer    << lib.GLCAPABILITIES_vertexBuffer_SHIFT)    |
            (quads           << lib.GLCAPABILITIES_quads_SHIFT)           |
            (intAndDouble    << lib.GLCAPABILITIES_intAndDouble_SHIFT)    |
            (legacyFormats   << lib.GLCAPABILITIES_legacyFormats_SHIFT)   |
            (nonPow2Textures << lib.GLCAPABILITIES_nonPow2Textures_SHIFT) |
            (vertexPointer   << lib.GLCAPABILITIES_vertexPointer_SHIFT)   |
            (legacy          << lib.GLCAPABILITIES_legacy_SHIFT)          |
            (shaders         << lib.GLCAPABILITIES_shaders_SHIFT)         |
            (fixedFunction   << lib.GLCAPABILITIES_fixedFunction_SHIFT)   |
            (immediate       << lib.GLCAPABILITIES_immediate_SHIFT)       |
            (frameBuffer     << lib.GLCAPABILITIES_frameBuffer_SHIFT)     |
            (pointSize       << lib.GLCAPABILITIES_pointSize_SHIFT)       |
            (vao             << lib.GLCAPABILITIES_vao_SHIFT)             |
            (select          << lib.GLCAPABILITIES_select_SHIFT)          |
            (debug           << lib.GLCAPABILITIES_debug_SHIFT)           |
            (gpuCommands     << lib.GLCAPABILITIES_gpuCommands_SHIFT)     |
            (mdei            << lib.GLCAPABILITIES_mdei_SHIFT)            |
            (samples         << lib.GLCAPABILITIES_samples_SHIFT)         )

   @property
   def compatible(self): return ((((self.impl)) & lib.GLCAPABILITIES_compatible_MASK) >> lib.GLCAPABILITIES_compatible_SHIFT)
   @compatible.setter
   def compatible(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_compatible_MASK)) | (((value)) << lib.GLCAPABILITIES_compatible_SHIFT)

   @property
   def vertexBuffer(self): return ((((self.impl)) & lib.GLCAPABILITIES_vertexBuffer_MASK) >> lib.GLCAPABILITIES_vertexBuffer_SHIFT)
   @vertexBuffer.setter
   def vertexBuffer(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_vertexBuffer_MASK)) | (((value)) << lib.GLCAPABILITIES_vertexBuffer_SHIFT)

   @property
   def quads(self): return ((((self.impl)) & lib.GLCAPABILITIES_quads_MASK) >> lib.GLCAPABILITIES_quads_SHIFT)
   @quads.setter
   def quads(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_quads_MASK)) | (((value)) << lib.GLCAPABILITIES_quads_SHIFT)

   @property
   def intAndDouble(self): return ((((self.impl)) & lib.GLCAPABILITIES_intAndDouble_MASK) >> lib.GLCAPABILITIES_intAndDouble_SHIFT)
   @intAndDouble.setter
   def intAndDouble(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_intAndDouble_MASK)) | (((value)) << lib.GLCAPABILITIES_intAndDouble_SHIFT)

   @property
   def legacyFormats(self): return ((((self.impl)) & lib.GLCAPABILITIES_legacyFormats_MASK) >> lib.GLCAPABILITIES_legacyFormats_SHIFT)
   @legacyFormats.setter
   def legacyFormats(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_legacyFormats_MASK)) | (((value)) << lib.GLCAPABILITIES_legacyFormats_SHIFT)

   @property
   def nonPow2Textures(self): return ((((self.impl)) & lib.GLCAPABILITIES_nonPow2Textures_MASK) >> lib.GLCAPABILITIES_nonPow2Textures_SHIFT)
   @nonPow2Textures.setter
   def nonPow2Textures(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_nonPow2Textures_MASK)) | (((value)) << lib.GLCAPABILITIES_nonPow2Textures_SHIFT)

   @property
   def vertexPointer(self): return ((((self.impl)) & lib.GLCAPABILITIES_vertexPointer_MASK) >> lib.GLCAPABILITIES_vertexPointer_SHIFT)
   @vertexPointer.setter
   def vertexPointer(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_vertexPointer_MASK)) | (((value)) << lib.GLCAPABILITIES_vertexPointer_SHIFT)

   @property
   def legacy(self): return ((((self.impl)) & lib.GLCAPABILITIES_legacy_MASK) >> lib.GLCAPABILITIES_legacy_SHIFT)
   @legacy.setter
   def legacy(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_legacy_MASK)) | (((value)) << lib.GLCAPABILITIES_legacy_SHIFT)

   @property
   def shaders(self): return ((((self.impl)) & lib.GLCAPABILITIES_shaders_MASK) >> lib.GLCAPABILITIES_shaders_SHIFT)
   @shaders.setter
   def shaders(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_shaders_MASK)) | (((value)) << lib.GLCAPABILITIES_shaders_SHIFT)

   @property
   def fixedFunction(self): return ((((self.impl)) & lib.GLCAPABILITIES_fixedFunction_MASK) >> lib.GLCAPABILITIES_fixedFunction_SHIFT)
   @fixedFunction.setter
   def fixedFunction(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_fixedFunction_MASK)) | (((value)) << lib.GLCAPABILITIES_fixedFunction_SHIFT)

   @property
   def immediate(self): return ((((self.impl)) & lib.GLCAPABILITIES_immediate_MASK) >> lib.GLCAPABILITIES_immediate_SHIFT)
   @immediate.setter
   def immediate(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_immediate_MASK)) | (((value)) << lib.GLCAPABILITIES_immediate_SHIFT)

   @property
   def frameBuffer(self): return ((((self.impl)) & lib.GLCAPABILITIES_frameBuffer_MASK) >> lib.GLCAPABILITIES_frameBuffer_SHIFT)
   @frameBuffer.setter
   def frameBuffer(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_frameBuffer_MASK)) | (((value)) << lib.GLCAPABILITIES_frameBuffer_SHIFT)

   @property
   def pointSize(self): return ((((self.impl)) & lib.GLCAPABILITIES_pointSize_MASK) >> lib.GLCAPABILITIES_pointSize_SHIFT)
   @pointSize.setter
   def pointSize(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_pointSize_MASK)) | (((value)) << lib.GLCAPABILITIES_pointSize_SHIFT)

   @property
   def vao(self): return ((((self.impl)) & lib.GLCAPABILITIES_vao_MASK) >> lib.GLCAPABILITIES_vao_SHIFT)
   @vao.setter
   def vao(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_vao_MASK)) | (((value)) << lib.GLCAPABILITIES_vao_SHIFT)

   @property
   def select(self): return ((((self.impl)) & lib.GLCAPABILITIES_select_MASK) >> lib.GLCAPABILITIES_select_SHIFT)
   @select.setter
   def select(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_select_MASK)) | (((value)) << lib.GLCAPABILITIES_select_SHIFT)

   @property
   def debug(self): return ((((self.impl)) & lib.GLCAPABILITIES_debug_MASK) >> lib.GLCAPABILITIES_debug_SHIFT)
   @debug.setter
   def debug(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_debug_MASK)) | (((value)) << lib.GLCAPABILITIES_debug_SHIFT)

   @property
   def gpuCommands(self): return ((((self.impl)) & lib.GLCAPABILITIES_gpuCommands_MASK) >> lib.GLCAPABILITIES_gpuCommands_SHIFT)
   @gpuCommands.setter
   def gpuCommands(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_gpuCommands_MASK)) | (((value)) << lib.GLCAPABILITIES_gpuCommands_SHIFT)

   @property
   def mdei(self): return ((((self.impl)) & lib.GLCAPABILITIES_mdei_MASK) >> lib.GLCAPABILITIES_mdei_SHIFT)
   @mdei.setter
   def mdei(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_mdei_MASK)) | (((value)) << lib.GLCAPABILITIES_mdei_SHIFT)

   @property
   def samples(self): return ((((self.impl)) & lib.GLCAPABILITIES_samples_MASK) >> lib.GLCAPABILITIES_samples_SHIFT)
   @samples.setter
   def samples(self, value): self.impl = ((self.impl) & ~(lib.GLCAPABILITIES_samples_MASK)) | (((value)) << lib.GLCAPABILITIES_samples_SHIFT)

class GLSamplesCount:
   none = lib.GLSamplesCount_none
   ms2  = lib.GLSamplesCount_ms2
   ms4  = lib.GLSamplesCount_ms4
   ms8  = lib.GLSamplesCount_ms8
   ms16 = lib.GLSamplesCount_ms16

class GradientDirection:
   vertical   = lib.GradientDirection_vertical
   horizontal = lib.GradientDirection_horizontal

class HitRecord:
   def __init__(self, prev = None, next = None, pos = None, numTags = None, center = None, tags = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_HitRecord *", lib.Instance_new(lib.class_HitRecord))
         if isinstance(prev, tuple):
            __tuple = prev
            prev = None
            if len(__tuple) > 0: prev    = __tuple[0]
            if len(__tuple) > 1: next    = __tuple[1]
            if len(__tuple) > 2: pos     = __tuple[2]
            if len(__tuple) > 3: numTags = __tuple[3]
         if prev is not None:    self.prev    = prev
         if next is not None:    self.next    = next
         if pos is not None:     self.pos     = pos
         if numTags is not None: self.numTags = numTags
         if center is not None:  self.center  = center
         if tags is not None:    self.tags    = tags

   @property
   def prev(self): return self.impl.prev
   @prev.setter
   def prev(self, value):
      if not isinstance(value, HitRecord): value = HitRecord(value)
      self.impl.prev = value.impl

   @property
   def next(self): return self.impl.next
   @next.setter
   def next(self, value):
      if not isinstance(value, HitRecord): value = HitRecord(value)
      self.impl.next = value.impl

   @property
   def pos(self): return self.impl.pos
   @pos.setter
   def pos(self, value): self.impl.pos = value

   @property
   def numTags(self): return self.impl.numTags
   @numTags.setter
   def numTags(self, value): self.impl.numTags = value

   @property
   def center(self): return Vector3D(impl = self.impl.center)
   @center.setter
   def center(self, value):
      if not isinstance(value, Vector3D): value = Vector3D(value)
      self.impl.center = value.impl[0]

   @property
   def tags(self): return self.impl.tags
   @tags.setter
   def tags(self, value): self.impl.tags = value

   def compare(self, recordB, unused):
      if recordB is not None and not isinstance(recordB, HitRecord): recordB = HitRecord(recordB)
      recordB = ffi.NULL if recordB is None else recordB.impl
      if hasattr(unused, 'impl'): unused = unused.impl
      if unused is None: unused = ffi.NULL
      return lib.HitRecord_compare(ffi.cast("struct eC_HitRecord *", self.impl), ffi.cast("struct eC_HitRecord *", recordB), unused)

class Light(Struct):
   def __init__(self, flags = None, ambient = None, diffuse = None, specular = None, direction = None, orientation = None, lightObject = None, target = None, fallOff = 0, hotSpot = 0, Kc = 0.0, Kl = 0.0, Kq = 0.0, start = 0, end = 0, multiplier = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Light *", impl)
      else:
         if flags is not None:
            if not isinstance(flags, LightFlags): flags = LightFlags(flags)
            flags = flags.impl
         else:
            flags = LightFlags()
         if ambient is not None:
            if not isinstance(ambient, ColorRGB): ambient = ColorRGB(ambient)
            ambient = ambient.impl[0]
         else:
            ambient = ColorRGB()
            ambient = ambient.impl[0]
         if diffuse is not None:
            if not isinstance(diffuse, ColorRGB): diffuse = ColorRGB(diffuse)
            diffuse = diffuse.impl[0]
         else:
            diffuse = ColorRGB()
            diffuse = diffuse.impl[0]
         if specular is not None:
            if not isinstance(specular, ColorRGB): specular = ColorRGB(specular)
            specular = specular.impl[0]
         else:
            specular = ColorRGB()
            specular = specular.impl[0]
         if direction is not None:
            if not isinstance(direction, Vector3D): direction = Vector3D(direction)
            direction = direction.impl[0]
         else:
            direction = Vector3D()
            direction = direction.impl[0]
         if orientation is not None:
            if not isinstance(orientation, Quaternion): orientation = Quaternion(orientation)
            orientation = orientation.impl[0]
         else:
            orientation = Quaternion()
            orientation = orientation.impl[0]
         if lightObject is not None:
            if not isinstance(lightObject, Object): lightObject = Object(lightObject)
            lightObject = lightObject.impl
         else:
            lightObject = ffi.NULL
         if target is not None:
            if not isinstance(target, Object): target = Object(target)
            target = target.impl
         else:
            target = ffi.NULL
         if fallOff is not None:
            if not isinstance(fallOff, Angle): fallOff = Degrees(fallOff)
            fallOff = fallOff.impl
         else:
            fallOff = Degrees()
         if hotSpot is not None:
            if not isinstance(hotSpot, Angle): hotSpot = Degrees(hotSpot)
            hotSpot = hotSpot.impl
         else:
            hotSpot = Degrees()
         if start is not None:
            if not isinstance(start, Angle): start = Degrees(start)
            start = start.impl
         else:
            start = Degrees()
         if end is not None:
            if not isinstance(end, Angle): end = Degrees(end)
            end = end.impl
         else:
            end = Degrees()
         self.impl = ffi.new("eC_Light *", {
                                'flags' : flags,
                                'ambient' : ambient,
                                'diffuse' : diffuse,
                                'specular' : specular,
                                'direction' : direction,
                                'orientation' : orientation,
                                'lightObject' : lightObject,
                                'target' : target,
                                'fallOff' : fallOff,
                                'hotSpot' : hotSpot,
                                'Kc' : Kc,
                                'Kl' : Kl,
                                'Kq' : Kq,
                                'start' : start,
                                'end' : end,
                                'multiplier' : multiplier
                             })

   @property
   def flags(self): return LightFlags(impl = self.impl.flags)
   @flags.setter
   def flags(self, value):
      if not isinstance(value, LightFlags): value = LightFlags(value)
      self.impl.flags = value.impl

   @property
   def ambient(self): return ColorRGB(impl = self.impl.ambient)
   @ambient.setter
   def ambient(self, value):
      if not isinstance(value, ColorRGB): value = ColorRGB(value)
      self.impl.ambient = value.impl[0]

   @property
   def diffuse(self): return ColorRGB(impl = self.impl.diffuse)
   @diffuse.setter
   def diffuse(self, value):
      if not isinstance(value, ColorRGB): value = ColorRGB(value)
      self.impl.diffuse = value.impl[0]

   @property
   def specular(self): return ColorRGB(impl = self.impl.specular)
   @specular.setter
   def specular(self, value):
      if not isinstance(value, ColorRGB): value = ColorRGB(value)
      self.impl.specular = value.impl[0]

   @property
   def direction(self): return Vector3D(impl = self.impl.direction)
   @direction.setter
   def direction(self, value):
      if not isinstance(value, Vector3D): value = Vector3D(value)
      self.impl.direction = value.impl[0]

   @property
   def orientation(self): return Quaternion(impl = self.impl.orientation)
   @orientation.setter
   def orientation(self, value):
      if not isinstance(value, Quaternion): value = Quaternion(value)
      self.impl.orientation = value.impl[0]

   @property
   def lightObject(self): return self.impl.lightObject
   @lightObject.setter
   def lightObject(self, value):
      if not isinstance(value, Object): value = Object(value)
      self.impl.lightObject = value.impl

   @property
   def target(self): return self.impl.target
   @target.setter
   def target(self, value):
      if not isinstance(value, Object): value = Object(value)
      self.impl.target = value.impl

   @property
   def fallOff(self): return Degrees(impl = self.impl.fallOff)
   @fallOff.setter
   def fallOff(self, value):
      if not isinstance(value, Angle): value = Degrees(value)
      self.impl.fallOff = value.impl

   @property
   def hotSpot(self): return Degrees(impl = self.impl.hotSpot)
   @hotSpot.setter
   def hotSpot(self, value):
      if not isinstance(value, Angle): value = Degrees(value)
      self.impl.hotSpot = value.impl

   @property
   def Kc(self): return self.impl.Kc
   @Kc.setter
   def Kc(self, value): self.impl.Kc = value

   @property
   def Kl(self): return self.impl.Kl
   @Kl.setter
   def Kl(self, value): self.impl.Kl = value

   @property
   def Kq(self): return self.impl.Kq
   @Kq.setter
   def Kq(self, value): self.impl.Kq = value

   @property
   def start(self): return Degrees(impl = self.impl.start)
   @start.setter
   def start(self, value):
      if not isinstance(value, Angle): value = Degrees(value)
      self.impl.start = value.impl

   @property
   def end(self): return Degrees(impl = self.impl.end)
   @end.setter
   def end(self, value):
      if not isinstance(value, Angle): value = Degrees(value)
      self.impl.end = value.impl

   @property
   def multiplier(self): return self.impl.multiplier
   @multiplier.setter
   def multiplier(self, value): self.impl.multiplier = value

class LightFlags(pyBaseClass):
   def __init__(self, off = False, spot = False, omni = False, attenuation = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(off, LightFlags):
         self.impl = off.impl
      else:
         if isinstance(off, tuple):
            __tuple = off
            off = False
            if len(__tuple) > 0: off = __tuple[0]
            if len(__tuple) > 1: spot = __tuple[1]
            if len(__tuple) > 2: omni = __tuple[2]
            if len(__tuple) > 3: attenuation = __tuple[3]
         self.impl = (
            (off         << lib.LIGHTFLAGS_off_SHIFT)         |
            (spot        << lib.LIGHTFLAGS_spot_SHIFT)        |
            (omni        << lib.LIGHTFLAGS_omni_SHIFT)        |
            (attenuation << lib.LIGHTFLAGS_attenuation_SHIFT) )

   @property
   def off(self): return ((((self.impl)) & lib.LIGHTFLAGS_off_MASK) >> lib.LIGHTFLAGS_off_SHIFT)
   @off.setter
   def off(self, value): self.impl = ((self.impl) & ~(lib.LIGHTFLAGS_off_MASK)) | (((value)) << lib.LIGHTFLAGS_off_SHIFT)

   @property
   def spot(self): return ((((self.impl)) & lib.LIGHTFLAGS_spot_MASK) >> lib.LIGHTFLAGS_spot_SHIFT)
   @spot.setter
   def spot(self, value): self.impl = ((self.impl) & ~(lib.LIGHTFLAGS_spot_MASK)) | (((value)) << lib.LIGHTFLAGS_spot_SHIFT)

   @property
   def omni(self): return ((((self.impl)) & lib.LIGHTFLAGS_omni_MASK) >> lib.LIGHTFLAGS_omni_SHIFT)
   @omni.setter
   def omni(self, value): self.impl = ((self.impl) & ~(lib.LIGHTFLAGS_omni_MASK)) | (((value)) << lib.LIGHTFLAGS_omni_SHIFT)

   @property
   def attenuation(self): return ((((self.impl)) & lib.LIGHTFLAGS_attenuation_MASK) >> lib.LIGHTFLAGS_attenuation_SHIFT)
   @attenuation.setter
   def attenuation(self, value): self.impl = ((self.impl) & ~(lib.LIGHTFLAGS_attenuation_MASK)) | (((value)) << lib.LIGHTFLAGS_attenuation_SHIFT)

class PixelFormat:
   pixelFormat4         = lib.PixelFormat_pixelFormat4
   pixelFormat8         = lib.PixelFormat_pixelFormat8
   pixelFormat444       = lib.PixelFormat_pixelFormat444
   pixelFormat555       = lib.PixelFormat_pixelFormat555
   pixelFormat565       = lib.PixelFormat_pixelFormat565
   pixelFormat888       = lib.PixelFormat_pixelFormat888
   pixelFormatAlpha     = lib.PixelFormat_pixelFormatAlpha
   pixelFormatText      = lib.PixelFormat_pixelFormatText
   pixelFormatRGBA      = lib.PixelFormat_pixelFormatRGBA
   pixelFormatA16       = lib.PixelFormat_pixelFormatA16
   pixelFormatRGBAGL    = lib.PixelFormat_pixelFormatRGBAGL
   pixelFormatETC2RGBA8 = lib.PixelFormat_pixelFormatETC2RGBA8

class RenderState:
   fillMode   = lib.RenderState_fillMode
   depthTest  = lib.RenderState_depthTest
   depthWrite = lib.RenderState_depthWrite
   fogDensity = lib.RenderState_fogDensity
   fogColor   = lib.RenderState_fogColor
   blend      = lib.RenderState_blend
   ambient    = lib.RenderState_ambient
   alphaWrite = lib.RenderState_alphaWrite
   antiAlias  = lib.RenderState_antiAlias
   vSync      = lib.RenderState_vSync

class RenderStateFloat(Struct):
   def __init__(self, f = None, ui = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_RenderStateFloat *", impl)
      else:
         if isinstance(f, tuple):
            __tuple = f
            f = 0.0
            if len(__tuple) > 0: f  = __tuple[0]
         __members = { }
         if f is not None:  __members['f']  = f
         if ui is not None: __members['ui'] = ui
         self.impl = ffi.new("eC_RenderStateFloat *", __members)

   @property
   def f(self): return self.impl.f
   @f.setter
   def f(self, value): self.impl.f = value

   @property
   def ui(self): return self.impl.ui
   @ui.setter
   def ui(self, value): self.impl.ui = value

class Resolution:
   resText80x25 = lib.Resolution_resText80x25
   res320x200   = lib.Resolution_res320x200
   res320x240   = lib.Resolution_res320x240
   res320x400   = lib.Resolution_res320x400
   res360x480   = lib.Resolution_res360x480
   res400x256   = lib.Resolution_res400x256
   res400x300   = lib.Resolution_res400x300
   res512x256   = lib.Resolution_res512x256
   res512x384   = lib.Resolution_res512x384
   res640x200   = lib.Resolution_res640x200
   res640x350   = lib.Resolution_res640x350
   res640x400   = lib.Resolution_res640x400
   res640x480   = lib.Resolution_res640x480
   res720x348   = lib.Resolution_res720x348
   res800x600   = lib.Resolution_res800x600
   res856x480   = lib.Resolution_res856x480
   res960x720   = lib.Resolution_res960x720
   res1024x768  = lib.Resolution_res1024x768
   res1152x864  = lib.Resolution_res1152x864
   res1280x1024 = lib.Resolution_res1280x1024
   res1600x1200 = lib.Resolution_res1600x1200
   res768x480   = lib.Resolution_res768x480

class Surface(Instance):
   class_members = [
                      'width',
                      'height',
                      'offset',
                      'box',
                      'unclippedBox',
                      'driverData',
                      'alphaWrite',
                      'blend',
                      'bitmap',
                      'outlineColor',
                      'foreground',
                      'background',
                      'blitTint',
                      'blackTint',
                      'lineStipple',
                      'size',
                      'display',
                      'font',
                      'textOpacity',
                      'drawingChar',
                      'clipping',
                   ]

   def init_args(self, args, kwArgs): init_args(Surface, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def width(self): return IPTR(lib, ffi, self, Surface).width
   @width.setter
   def width(self, value): IPTR(lib, ffi, self, Surface).width = value

   @property
   def height(self): return IPTR(lib, ffi, self, Surface).height
   @height.setter
   def height(self, value): IPTR(lib, ffi, self, Surface).height = value

   @property
   def offset(self): return Point(impl = IPTR(lib, ffi, self, Surface).offset)
   @offset.setter
   def offset(self, value):
      if not isinstance(value, Point): value = Point(value)
      IPTR(lib, ffi, self, Surface).offset = value.impl

   @property
   def box(self): return Box(impl = IPTR(lib, ffi, self, Surface).box)
   @box.setter
   def box(self, value):
      if not isinstance(value, Box): value = Box(value)
      IPTR(lib, ffi, self, Surface).box = value.impl

   @property
   def unclippedBox(self): return Box(impl = IPTR(lib, ffi, self, Surface).unclippedBox)
   @unclippedBox.setter
   def unclippedBox(self, value):
      if not isinstance(value, Box): value = Box(value)
      IPTR(lib, ffi, self, Surface).unclippedBox = value.impl

   @property
   def driverData(self): return IPTR(lib, ffi, self, Surface).driverData
   @driverData.setter
   def driverData(self, value): IPTR(lib, ffi, self, Surface).driverData = value

   @property
   def alphaWrite(self): return lib.Surface_get_alphaWrite(self.impl)
   @alphaWrite.setter
   def alphaWrite(self, value):
      lib.Surface_set_alphaWrite(self.impl, value)

   @property
   def blend(self): return lib.Surface_get_blend(self.impl)
   @blend.setter
   def blend(self, value):
      lib.Surface_set_blend(self.impl, value)

   @property
   def bitmap(self): return pyOrNewObject(Bitmap, lib.Surface_get_bitmap(self.impl))

   @property
   def outlineColor(self): return ColorAlpha(impl = lib.Surface_get_outlineColor(self.impl))
   @outlineColor.setter
   def outlineColor(self, value):
      if not isinstance(value, ColorAlpha): value = ColorAlpha(value)
      lib.Surface_set_outlineColor(self.impl, value.impl)

   @property
   def foreground(self): return ColorAlpha(impl = lib.Surface_get_foreground(self.impl))
   @foreground.setter
   def foreground(self, value):
      if not isinstance(value, ColorAlpha): value = ColorAlpha(value)
      lib.Surface_set_foreground(self.impl, value.impl)

   @property
   def background(self): return ColorAlpha(impl = lib.Surface_get_background(self.impl))
   @background.setter
   def background(self, value):
      if not isinstance(value, ColorAlpha): value = ColorAlpha(value)
      lib.Surface_set_background(self.impl, value.impl)

   @property
   def blitTint(self): return ColorAlpha(impl = lib.Surface_get_blitTint(self.impl))
   @blitTint.setter
   def blitTint(self, value):
      if not isinstance(value, ColorAlpha): value = ColorAlpha(value)
      lib.Surface_set_blitTint(self.impl, value.impl)

   @property
   def blackTint(self): return Color(impl = lib.Surface_get_blackTint(self.impl))
   @blackTint.setter
   def blackTint(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.Surface_set_blackTint(self.impl, value.impl)

   @property
   def lineStipple(self): return None
   @lineStipple.setter
   def lineStipple(self, value):
      lib.Surface_set_lineStipple(self.impl, value)

   @property
   def size(self): value = Size(); lib.Surface_get_size(self.impl, ffi.cast("eC_Size *", value.impl)); return value

   @property
   def display(self): return pyOrNewObject(Display, lib.Surface_get_display(self.impl))

   @property
   def font(self): return Font(impl = lib.Surface_get_font(self.impl))
   @font.setter
   def font(self, value):
      if not isinstance(value, Font): value = Font(value)
      lib.Surface_set_font(self.impl, value.impl)

   @property
   def textOpacity(self): return lib.Surface_get_textOpacity(self.impl)
   @textOpacity.setter
   def textOpacity(self, value):
      lib.Surface_set_textOpacity(self.impl, value)

   @property
   def drawingChar(self): return None
   @drawingChar.setter
   def drawingChar(self, value):
      lib.Surface_set_drawingChar(self.impl, value)

   @property
   def clipping(self): return None
   @clipping.setter
   def clipping(self, value):
      if not isinstance(value, Box): value = Box(value)
      lib.Surface_set_clipping(self.impl, ffi.cast("eC_Box *", value.impl))

   def area(self, x1, y1, x2, y2):
      lib.Surface_area(self.impl, x1, y1, x2, y2)

   def bevel(self, inner, x, y, w, h):
      lib.Surface_bevel(self.impl, inner, x, y, w, h)

   def blit(self, src, dx, dy, sx, sy, w, h):
      if src is not None and not isinstance(src, Bitmap): src = Bitmap(src)
      src = ffi.NULL if src is None else src.impl
      lib.Surface_blit(self.impl, src, dx, dy, sx, sy, w, h)

   def centerTextf(self, x, y, format, *args):
      if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
      elif format is None: format = ffi.NULL
      lib.Surface_centerTextf(self.impl, x, y, format, *ellipsisArgs(args))

   def clear(self, type):
      lib.Surface_clear(self.impl, type)

   def clip(self, box = None):
      if box is not None and not isinstance(box, Box): box = Box(box)
      box = ffi.NULL if box is None else box.impl
      lib.Surface_clip(self.impl, ffi.cast("eC_Box *", box))

   def drawLine(self, x1, y1, x2, y2):
      lib.Surface_drawLine(self.impl, x1, y1, x2, y2)

   def drawingChar(self, value):
      lib.Surface_drawingChar(self.impl, value)

   def filter(self, src, dx, dy, sx, sy, w, h, sw, sh):
      if src is not None and not isinstance(src, Bitmap): src = Bitmap(src)
      src = ffi.NULL if src is None else src.impl
      lib.Surface_filter(self.impl, src, dx, dy, sx, sy, w, h, sw, sh)

   def filterHTile(self, src, dx, dy, w, h):
      if src is not None and not isinstance(src, Bitmap): src = Bitmap(src)
      src = ffi.NULL if src is None else src.impl
      lib.Surface_filterHTile(self.impl, src, dx, dy, w, h)

   def filterVTile(self, src, dx, dy, w, h):
      if src is not None and not isinstance(src, Bitmap): src = Bitmap(src)
      src = ffi.NULL if src is None else src.impl
      lib.Surface_filterVTile(self.impl, src, dx, dy, w, h)

   def getBackground(self):
      return Color(impl = lib.Surface_getBackground(self.impl))

   def getBox(self, value = None):
      if value is not None and not isinstance(value, Box): value = Box(value)
      value = ffi.NULL if value is None else value.impl
      lib.Surface_getBox(self.impl, ffi.cast("eC_Box *", value))

   def getDisplay(self):
      return pyOrNewObject(Display, lib.Surface_getDisplay(self.impl))

   def getFont(self):
      return lib.Surface_getFont(self.impl)

   def getForeground(self):
      return Color(impl = lib.Surface_getForeground(self.impl))

   def getPixel(self, x, y):
      return ColorAlpha(impl = lib.Surface_getPixel(self.impl, x, y))

   def getSize(self):
      w = ffi.new("int *")
      h = ffi.new("int *")
      lib.Surface_getSize(self.impl, w, h)
      return w[0], h[0]

   def getTextOpacity(self):
      return lib.Surface_getTextOpacity(self.impl)

   def gradient(self, keys, numKeys, smoothness, direction, x1, y1, x2, y2):
      lib.Surface_gradient(self.impl, keys, numKeys, smoothness, direction, x1, y1, x2, y2)

   def hLine(self, x1, x2, y):
      lib.Surface_hLine(self.impl, x1, x2, y)

   def hTile(self, src, dx, dy, w, h):
      if src is not None and not isinstance(src, Bitmap): src = Bitmap(src)
      src = ffi.NULL if src is None else src.impl
      lib.Surface_hTile(self.impl, src, dx, dy, w, h)

   def lineStipple(self, value):
      lib.Surface_lineStipple(self.impl, value)

   def putPixel(self, x, y):
      lib.Surface_putPixel(self.impl, x, y)

   def rectangle(self, x1, y1, x2, y2):
      lib.Surface_rectangle(self.impl, x1, y1, x2, y2)

   def setBackground(self, value):
      if value is not None and not isinstance(value, ColorAlpha): value = ColorAlpha(value)
      if value is None: value = ffi.NULL
      lib.Surface_setBackground(self.impl, value)

   def setForeground(self, value):
      if value is not None and not isinstance(value, ColorAlpha): value = ColorAlpha(value)
      if value is None: value = ffi.NULL
      lib.Surface_setForeground(self.impl, value)

   def stretch(self, src, dx, dy, sx, sy, w, h, sw, sh):
      if src is not None and not isinstance(src, Bitmap): src = Bitmap(src)
      src = ffi.NULL if src is None else src.impl
      lib.Surface_stretch(self.impl, src, dx, dy, sx, sy, w, h, sw, sh)

   def stretchf(self, src, dx, dy, sx, sy, w, h, sw, sh):
      if src is not None and not isinstance(src, Bitmap): src = Bitmap(src)
      src = ffi.NULL if src is None else src.impl
      lib.Surface_stretchf(self.impl, src, dx, dy, sx, sy, w, h, sw, sh)

   def textExtent(self, text, len):
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      width = ffi.new("int *")
      height = ffi.new("int *")
      lib.Surface_textExtent(self.impl, text, len, width, height)
      return width[0], height[0]

   def textExtent2(self, text, len, prevGlyph):
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      width = ffi.new("int *")
      height = ffi.new("int *")
      rPrevGlyph = ffi.new("int *")
      overHang = ffi.new("int *")
      lib.Surface_textExtent2(self.impl, text, len, width, height, prevGlyph, rPrevGlyph, overHang)
      return width[0], height[0], rPrevGlyph[0], overHang[0]

   def textFont(self, value = None):
      if value is not None and not isinstance(value, Font): value = Font(value)
      value = ffi.NULL if value is None else value.impl
      lib.Surface_textFont(self.impl, ffi.cast("struct eC_Font *", value))

   def textOpacity(self, value):
      lib.Surface_textOpacity(self.impl, value)

   def thinBevel(self, inner, x, y, w, h):
      lib.Surface_thinBevel(self.impl, inner, x, y, w, h)

   def tile(self, src, dx, dy, w, h):
      if src is not None and not isinstance(src, Bitmap): src = Bitmap(src)
      src = ffi.NULL if src is None else src.impl
      lib.Surface_tile(self.impl, src, dx, dy, w, h)

   def vLine(self, y1, y2, x):
      lib.Surface_vLine(self.impl, y1, y2, x)

   def vTile(self, src, dx, dy, w, h):
      if src is not None and not isinstance(src, Bitmap): src = Bitmap(src)
      src = ffi.NULL if src is None else src.impl
      lib.Surface_vTile(self.impl, src, dx, dy, w, h)

   def writeText(self, x, y, text, len):
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      lib.Surface_writeText(self.impl, x, y, text, len)

   def writeText2(self, x, y, text, len, prevGlyph):
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      rPrevGlyph = ffi.new("int *")
      lib.Surface_writeText2(self.impl, x, y, text, len, prevGlyph, rPrevGlyph)
      return rPrevGlyph[0]

   def writeTextDots(self, alignment, x, y, width, text, len):
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      lib.Surface_writeTextDots(self.impl, alignment, x, y, width, text, len)

   def writeTextDotsf(self, alignment, x, y, width, format, *args):
      if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
      elif format is None: format = ffi.NULL
      lib.Surface_writeTextDotsf(self.impl, alignment, x, y, width, format, *ellipsisArgs(args))

   def writeTextf(self, x, y, format, *args):
      if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
      elif format is None: format = ffi.NULL
      lib.Surface_writeTextf(self.impl, x, y, format, *ellipsisArgs(args))

class SystemColor(Color):
   formColor           = Color(impl = lib.SystemColor_formColor)
   activeBorder        = Color(impl = lib.SystemColor_activeBorder)
   control             = Color(impl = lib.SystemColor_control)
   controlLight        = Color(impl = lib.SystemColor_controlLight)
   inactiveBorder      = Color(impl = lib.SystemColor_inactiveBorder)
   inactiveCaptionText = Color(impl = lib.SystemColor_inactiveCaptionText)
   menu                = Color(impl = lib.SystemColor_menu)
   scrollBar           = Color(impl = lib.SystemColor_scrollBar)

def bestColorMatch(start, end, rgb):
   palette = ffi.new("eC_ColorAlpha *")
   if rgb is not None and not isinstance(rgb, Color): rgb = Color(rgb)
   if rgb is None: rgb = ffi.NULL
   r = lib.eC_bestColorMatch(palette, start, end, rgb)
   return r, ColorAlpha(impl = palette[0])

def getColorDepthShifts(format):
   return lib.eC_getColorDepthShifts(format)

def getDefaultMaterial():
   return lib.eC_getDefaultMaterial()

def getDefaultPalette():
   return lib.eC_getDefaultPalette()

def getDepthBits(colorDepth):
   return lib.eC_getDepthBits(colorDepth)

def getResolutionHeight(resolution):
   return lib.eC_getResolutionHeight(resolution)

def getResolutionWidth(resolution):
   return lib.eC_getResolutionWidth(resolution)

def listAvailableFonts():
   return pyOrNewObject(Map, lib.eC_listAvailableFonts(), "<String, FontInfo>")

def loadPalette(fileName, type):
   if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
   elif fileName is None: fileName = ffi.NULL
   if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
   elif type is None: type = ffi.NULL
   return lib.eC_loadPalette(fileName, type)

def paletteGradient(numColors, keys, numKeys, smoothness):
   palette = ffi.new("eC_ColorAlpha *")
   lib.eC_paletteGradient(palette, numColors, keys, numKeys, smoothness)
   return ColorAlpha(impl = palette[0])

def resolveCharFont(faceName, size, flags, lang, testChar):
   if isinstance(faceName, str): faceName = ffi.new("char[]", faceName.encode('u8'))
   elif faceName is None: faceName = ffi.NULL
   if flags is not None and not isinstance(flags, FontFlags): flags = FontFlags(flags)
   if flags is None: flags = ffi.NULL
   if isinstance(lang, str): lang = ffi.new("char[]", lang.encode('u8'))
   elif lang is None: lang = ffi.NULL
   if testChar is not None and not isinstance(testChar, unichar): testChar = unichar(testChar)
   if testChar is None: testChar = ffi.NULL
   return lib.eC_resolveCharFont(faceName, size, flags, lang, testChar)

def resolveFont(faceName, size, flags):
   if isinstance(faceName, str): faceName = ffi.new("char[]", faceName.encode('u8'))
   elif faceName is None: faceName = ffi.NULL
   if flags is not None and not isinstance(flags, FontFlags): flags = FontFlags(flags)
   if flags is None: flags = ffi.NULL
   return pyOrNewObject(Array, lib.eC_resolveFont(faceName, size, flags), "<FaceInfo>")

def setPrintingDocumentName(name = None):
   if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
   elif name is None: name = ffi.NULL
   lib.eC_setPrintingDocumentName(name)

class PNGOptions(Struct):
   def __init__(self, zlibCompressionLevel = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_PNGOptions *", impl)
      else:
         self.impl = ffi.new("eC_PNGOptions *", { 'zlibCompressionLevel' : zlibCompressionLevel })

   @property
   def zlibCompressionLevel(self): return self.impl.zlibCompressionLevel
   @zlibCompressionLevel.setter
   def zlibCompressionLevel(self, value): self.impl.zlibCompressionLevel = value

class CompiledShader:
   def __init__(self, program = None, vertex = None, fragment = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_CompiledShader *", lib.Instance_new(lib.class_CompiledShader))
         if isinstance(program, tuple):
            __tuple = program
            program = 0
            if len(__tuple) > 0: program  = __tuple[0]
            if len(__tuple) > 1: vertex   = __tuple[1]
            if len(__tuple) > 2: fragment = __tuple[2]
         if program is not None:  self.program  = program
         if vertex is not None:   self.vertex   = vertex
         if fragment is not None: self.fragment = fragment

   @property
   def program(self): return self.impl.program
   @program.setter
   def program(self, value): self.impl.program = value

   @property
   def vertex(self): return self.impl.vertex
   @vertex.setter
   def vertex(self, value): self.impl.vertex = value

   @property
   def fragment(self): return self.impl.fragment
   @fragment.setter
   def fragment(self, value): self.impl.fragment = value

   def free(self):
      lib.CompiledShader_free(ffi.cast("struct eC_CompiledShader *", self.impl))

@ffi.callback("uint(eC_FreeBlockMap, eC_GLBType, uint)")
def cb_FreeBlockMap_onExpand(__e, type, required):
   freeblockmap = pyOrNewObject(FreeBlockMap, __e)
   return freeblockmap.fn_FreeBlockMap_onExpand(freeblockmap, GLBType(impl = type), required)

class FreeBlockMap(Array):
   class_members = [
                      'onExpand',
                   ]

   def init_args(self, args, kwArgs): init_args(FreeBlockMap, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      kwArgs['templateParams'] = "<BlockEntry>"
      self.init_args(list(args), kwArgs)

   def allocate(self, type, size):
      return BlockEntry(impl = lib.FreeBlockMap_allocate(self.impl, type, size))

   def freeBlock(self, block):
      if block is not None and not isinstance(block, BlockEntry): block = BlockEntry(block)
      if block is None: block = ffi.NULL
      lib.FreeBlockMap_freeBlock(self.impl, block)

   def fn_unset_FreeBlockMap_onExpand(self, type, required):
      return lib.FreeBlockMap_onExpand(self.impl, type, required)

   @property
   def onExpand(self):
      if hasattr(self, 'fn_FreeBlockMap_onExpand'): return self.fn_FreeBlockMap_onExpand
      else: return self.fn_unset_FreeBlockMap_onExpand
   @onExpand.setter
   def onExpand(self, value):
      self.fn_FreeBlockMap_onExpand = value
      lib.Instance_setMethod(self.impl, "onExpand".encode('u8'), cb_FreeBlockMap_onExpand)

class GLB(Struct):
   def __init__(self, buffer = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_GLB *", impl)
      else:
         self.impl = ffi.new("eC_GLB *", { 'buffer' : buffer })

   @property
   def buffer(self): return self.impl.buffer
   @buffer.setter
   def buffer(self, value): self.impl.buffer = value

   def _allocate(self, type, size, data, usage):
      if hasattr(data, 'impl'): data = data.impl
      if data is None: data = ffi.NULL
      return lib.GLB__allocate(ffi.cast("eC_GLB *", self.impl), type, size, data, usage)

   def _upload(self, type, offset, size, data):
      if hasattr(data, 'impl'): data = data.impl
      if data is None: data = ffi.NULL
      lib.GLB__upload(ffi.cast("eC_GLB *", self.impl), type, offset, size, data)

   def allocate(self, size, data, usage):
      if hasattr(data, 'impl'): data = data.impl
      if data is None: data = ffi.NULL
      return lib.GLB_allocate(ffi.cast("eC_GLB *", self.impl), size, data, usage)

   def copy(self, src, srcStart, dstStart, size):
      if src is not None and not isinstance(src, GLB): src = GLB(src)
      src = ffi.NULL if src is None else src.impl
      lib.GLB_copy(ffi.cast("eC_GLB *", self.impl), ffi.cast("eC_GLB *", src), srcStart, dstStart, size)

   def deleteBuffers(count, buffers):
      lib.GLB_deleteBuffers(count, buffers)

   def free(self):
      lib.GLB_free(ffi.cast("eC_GLB *", self.impl))

   def resize(self, type, oldSize, newSize, usage, keepSameBufferID):
      return lib.GLB_resize(ffi.cast("eC_GLB *", self.impl), type, oldSize, newSize, usage, keepSameBufferID)

   def upload(self, offset, size, data):
      if hasattr(data, 'impl'): data = data.impl
      if data is None: data = ffi.NULL
      lib.GLB_upload(ffi.cast("eC_GLB *", self.impl), offset, size, data)

class GLAB(GLB):
   def __init__(self, buffer = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_GLAB *", impl)
      else:
         self.impl = ffi.new("eC_GLAB *", { 'buffer' : buffer })

   def use(self, contents, n, type, stride, mode, pointer):
      if hasattr(pointer, 'impl'): pointer = pointer.impl
      if pointer is None: pointer = ffi.NULL
      lib.GLAB_use(ffi.cast("eC_GLAB *", self.impl), contents, n, type, stride, mode, pointer)

   def useVertTrans(self, count, n, type, stride, mode, pointer):
      if hasattr(pointer, 'impl'): pointer = pointer.impl
      if pointer is None: pointer = ffi.NULL
      lib.GLAB_useVertTrans(ffi.cast("eC_GLAB *", self.impl), count, n, type, stride, mode, pointer)

class GLEAB(GLB):
   def __init__(self, buffer = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_GLEAB *", impl)
      else:
         self.impl = ffi.new("eC_GLEAB *", { 'buffer' : buffer })

   def allocate(self, size, data, usage):
      if hasattr(data, 'impl'): data = data.impl
      if data is None: data = ffi.NULL
      return lib.GLEAB_allocate(ffi.cast("eC_GLEAB *", self.impl), size, data, usage)

   def draw(self, primType, count, type, indices):
      if hasattr(indices, 'impl'): indices = indices.impl
      if indices is None: indices = ffi.NULL
      lib.GLEAB_draw(ffi.cast("eC_GLEAB *", self.impl), primType, count, type, indices)

   def draw2(self, primType, count, type, indices, baseVertex):
      if hasattr(indices, 'impl'): indices = indices.impl
      if indices is None: indices = ffi.NULL
      lib.GLEAB_draw2(ffi.cast("eC_GLEAB *", self.impl), primType, count, type, indices, baseVertex)

   def upload(self, offset, size, data):
      if hasattr(data, 'impl'): data = data.impl
      if data is None: data = ffi.NULL
      lib.GLEAB_upload(ffi.cast("eC_GLEAB *", self.impl), offset, size, data)

@ffi.callback("void(eC_Shader, int)")
def cb_Shader_bindAttribs(__e, program):
   shader = pyOrNewObject(Shader, __e)
   shader.fn_Shader_bindAttribs(shader, program)

@ffi.callback("eC_ZString(eC_Shader, uint64)")
def cb_Shader_getDefinitions(__e, state):
   shader = pyOrNewObject(Shader, __e)
   return shader.fn_Shader_getDefinitions(shader, state)

@ffi.callback("eC_CompiledShader *(eC_Shader, int, uint64)")
def cb_Shader_registerShader(__e, program, state):
   shader = pyOrNewObject(Shader, __e)
   return shader.fn_Shader_registerShader(shader, program, state)

@ffi.callback("void(eC_Shader, eC_Material *, eC_MeshFeatures)")
def cb_Shader_setMaterial(__e, material, flags):
   shader = pyOrNewObject(Shader, __e)
   shader.fn_Shader_setMaterial(shader, Material(impl = material), MeshFeatures(impl = flags))

@ffi.callback("void(eC_Shader, eC_GLAB *, uint, uint, uint, void *)")
def cb_Shader_setupDrawCommand(__e, ab, vertexStride, baseVertex, drawID, transform):
   shader = pyOrNewObject(Shader, __e)
   shader.fn_Shader_setupDrawCommand(shader, GLAB(impl = ab), vertexStride, baseVertex, drawID, transform)

@ffi.callback("void(eC_Shader, eC_MatrixMode, float *, eC_bool)")
def cb_Shader_updateMatrix(__e, mode, matrix, isIdentity):
   shader = pyOrNewObject(Shader, __e)
   shader.fn_Shader_updateMatrix(shader, MatrixMode(impl = mode), matrix, isIdentity)

@ffi.callback("void(eC_Shader, eC_CompiledShader *)")
def cb_Shader_uploadUniforms(__e, shader):
   shader = pyOrNewObject(Shader, __e)
   shader.fn_Shader_uploadUniforms(shader, CompiledShader(impl = shader))

class Shader(Instance):
   class_members = [
                      'vertexShaderFile',
                      'fragmentShaderFile',
                      'vertexShader',
                      'fragmentShader',
                      'activeCompiledShader',
                      'state',
                      'modifiedUniforms',
                      'bindAttribs',
                      'getDefinitions',
                      'registerShader',
                      'setMaterial',
                      'setupDrawCommand',
                      'updateMatrix',
                      'uploadUniforms',
                   ]

   def init_args(self, args, kwArgs): init_args(Shader, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def vertexShaderFile(self): return None
   @vertexShaderFile.setter
   def vertexShaderFile(self, value):
      if not isinstance(value, String): value = String(value)
      lib.Shader_set_vertexShaderFile(self.impl, value.impl.encode('u8'))

   @property
   def fragmentShaderFile(self): return None
   @fragmentShaderFile.setter
   def fragmentShaderFile(self, value):
      if not isinstance(value, String): value = String(value)
      lib.Shader_set_fragmentShaderFile(self.impl, value.impl.encode('u8'))

   @property
   def vertexShader(self): return None
   @vertexShader.setter
   def vertexShader(self, value):
      if not isinstance(value, String): value = String(value)
      lib.Shader_set_vertexShader(self.impl, value.impl.encode('u8'))

   @property
   def fragmentShader(self): return None
   @fragmentShader.setter
   def fragmentShader(self, value):
      if not isinstance(value, String): value = String(value)
      lib.Shader_set_fragmentShader(self.impl, value.impl.encode('u8'))

   @property
   def activeCompiledShader(self): return CompiledShader(impl = lib.Shader_get_activeCompiledShader(self.impl))

   @property
   def state(self): return IPTR(lib, ffi, self, Shader).state
   @state.setter
   def state(self, value): IPTR(lib, ffi, self, Shader).state = value

   @property
   def modifiedUniforms(self): return ShaderModifiedUniforms(impl = IPTR(lib, ffi, self, Shader).modifiedUniforms)
   @modifiedUniforms.setter
   def modifiedUniforms(self, value):
      if not isinstance(value, ShaderModifiedUniforms): value = ShaderModifiedUniforms(value)
      IPTR(lib, ffi, self, Shader).modifiedUniforms = value.impl

   def activate(self):
      return lib.Shader_activate(self.impl)

   def fn_unset_Shader_bindAttribs(self, program):
      return lib.Shader_bindAttribs(self.impl, program)

   @property
   def bindAttribs(self):
      if hasattr(self, 'fn_Shader_bindAttribs'): return self.fn_Shader_bindAttribs
      else: return self.fn_unset_Shader_bindAttribs
   @bindAttribs.setter
   def bindAttribs(self, value):
      self.fn_Shader_bindAttribs = value
      lib.Instance_setMethod(self.impl, "bindAttribs".encode('u8'), cb_Shader_bindAttribs)

   def free(self):
      lib.Shader_free(self.impl)

   def fn_unset_Shader_getDefinitions(self, state):
      return pyOrNewObject(ZString, lib.Shader_getDefinitions(self.impl, state))

   @property
   def getDefinitions(self):
      if hasattr(self, 'fn_Shader_getDefinitions'): return self.fn_Shader_getDefinitions
      else: return self.fn_unset_Shader_getDefinitions
   @getDefinitions.setter
   def getDefinitions(self, value):
      self.fn_Shader_getDefinitions = value
      lib.Instance_setMethod(self.impl, "getDefinitions".encode('u8'), cb_Shader_getDefinitions)

   def load(self, state):
      return lib.Shader_load(self.impl, state)

   def fn_unset_Shader_registerShader(self, program, state):
      return lib.Shader_registerShader(self.impl, program, state)

   @property
   def registerShader(self):
      if hasattr(self, 'fn_Shader_registerShader'): return self.fn_Shader_registerShader
      else: return self.fn_unset_Shader_registerShader
   @registerShader.setter
   def registerShader(self, value):
      self.fn_Shader_registerShader = value
      lib.Instance_setMethod(self.impl, "registerShader".encode('u8'), cb_Shader_registerShader)

   def select(self):
      lib.Shader_select(self.impl)

   def fn_unset_Shader_setMaterial(self, material, flags):
      return lib.Shader_setMaterial(self.impl, ffi.NULL if material is None else material.impl, flags)

   @property
   def setMaterial(self):
      if hasattr(self, 'fn_Shader_setMaterial'): return self.fn_Shader_setMaterial
      else: return self.fn_unset_Shader_setMaterial
   @setMaterial.setter
   def setMaterial(self, value):
      self.fn_Shader_setMaterial = value
      lib.Instance_setMethod(self.impl, "setMaterial".encode('u8'), cb_Shader_setMaterial)

   def fn_unset_Shader_setupDrawCommand(self, ab, vertexStride, baseVertex, drawID, transform):
      return lib.Shader_setupDrawCommand(self.impl, ffi.NULL if ab is None else ab.impl, vertexStride, baseVertex, drawID, transform)

   @property
   def setupDrawCommand(self):
      if hasattr(self, 'fn_Shader_setupDrawCommand'): return self.fn_Shader_setupDrawCommand
      else: return self.fn_unset_Shader_setupDrawCommand
   @setupDrawCommand.setter
   def setupDrawCommand(self, value):
      self.fn_Shader_setupDrawCommand = value
      lib.Instance_setMethod(self.impl, "setupDrawCommand".encode('u8'), cb_Shader_setupDrawCommand)

   def fn_unset_Shader_updateMatrix(self, mode, matrix, isIdentity):
      if matrix is None: matrix = ffi.NULL
      return lib.Shader_updateMatrix(self.impl, mode, matrix, isIdentity)

   @property
   def updateMatrix(self):
      if hasattr(self, 'fn_Shader_updateMatrix'): return self.fn_Shader_updateMatrix
      else: return self.fn_unset_Shader_updateMatrix
   @updateMatrix.setter
   def updateMatrix(self, value):
      self.fn_Shader_updateMatrix = value
      lib.Instance_setMethod(self.impl, "updateMatrix".encode('u8'), cb_Shader_updateMatrix)

   def fn_unset_Shader_uploadUniforms(self, shader):
      return lib.Shader_uploadUniforms(self.impl, ffi.NULL if shader is None else shader.impl)

   @property
   def uploadUniforms(self):
      if hasattr(self, 'fn_Shader_uploadUniforms'): return self.fn_Shader_uploadUniforms
      else: return self.fn_unset_Shader_uploadUniforms
   @uploadUniforms.setter
   def uploadUniforms(self, value):
      self.fn_Shader_uploadUniforms = value
      lib.Instance_setMethod(self.impl, "uploadUniforms".encode('u8'), cb_Shader_uploadUniforms)

noAB = GLAB ( 0 )

noEAB = GLEAB ( 0 )

class BlockEntry(pyBaseClass):
   def __init__(self, start = 0, end = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(start, BlockEntry):
         self.impl = start.impl
      else:
         if isinstance(start, tuple):
            __tuple = start
            start = 0
            if len(__tuple) > 0: start = __tuple[0]
            if len(__tuple) > 1: end = __tuple[1]
         self.impl = (
            (start << lib.BLOCKENTRY_start_SHIFT) |
            (end   << lib.BLOCKENTRY_end_SHIFT)   )

   @property
   def start(self): return ((((self.impl)) & lib.BLOCKENTRY_start_MASK) >> lib.BLOCKENTRY_start_SHIFT)
   @start.setter
   def start(self, value): self.impl = ((self.impl) & ~(lib.BLOCKENTRY_start_MASK)) | (((value)) << lib.BLOCKENTRY_start_SHIFT)

   @property
   def end(self): return ((((self.impl)) & lib.BLOCKENTRY_end_MASK) >> lib.BLOCKENTRY_end_SHIFT)
   @end.setter
   def end(self, value): self.impl = ((self.impl) & ~(lib.BLOCKENTRY_end_MASK)) | (((value)) << lib.BLOCKENTRY_end_SHIFT)

class CompiledDefaultShader(CompiledShader):
   def __init__(self,
                program = None,
                vertex = None,
                fragment = None,
                uPrjMatrix = None,
                uMVMatrix = None,
                uTextureMatrix = None,
                uNormalsMatrix = None,
                uNormalsInvScale2 = None,
                uFogDensity = None,
                uFogColor = None,
                uGlobalAmbient = None,
                uNearPlane = None,
                uLightsPos = None,
                uLightsDiffuse = None,
                uLightsAmbient = None,
                uLightsSpecular = None,
                uLightsAtt = None,
                uLightsSpotDir = None,
                uLightsSpotCutOffCos = None,
                uLightsSpotExp = None,
                uMatDiffuse = None,
                uMatAmbient = None,
                uMatSpecular = None,
                uMatEmissive = None,
                uMatPower = None,
                uMatOpacity = None,
                uDiffuseTex = None,
                uBumpTex = None,
                uSpecularTex = None,
                uEnvTex = None,
                uReflectTex = None,
                uRefractionETA = None,
                uMatReflectivity = None,
                uCubeMapMatrix = None,
                uAlphaFuncValue = None,
                uBlackTint = None,
                uBoneMatrices = None,
                uBoneOffsets = None,
                initialSetup = None,
                useNearPlane = None,
                impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_CompiledDefaultShader *", lib.Instance_new(lib.class_CompiledDefaultShader))
         if program is not None:              self.program              = program
         if vertex is not None:               self.vertex               = vertex
         if fragment is not None:             self.fragment             = fragment
         if uPrjMatrix is not None:           self.uPrjMatrix           = uPrjMatrix
         if uMVMatrix is not None:            self.uMVMatrix            = uMVMatrix
         if uTextureMatrix is not None:       self.uTextureMatrix       = uTextureMatrix
         if uNormalsMatrix is not None:       self.uNormalsMatrix       = uNormalsMatrix
         if uNormalsInvScale2 is not None:    self.uNormalsInvScale2    = uNormalsInvScale2
         if uFogDensity is not None:          self.uFogDensity          = uFogDensity
         if uFogColor is not None:            self.uFogColor            = uFogColor
         if uGlobalAmbient is not None:       self.uGlobalAmbient       = uGlobalAmbient
         if uNearPlane is not None:           self.uNearPlane           = uNearPlane
         if uLightsPos is not None:           self.uLightsPos           = uLightsPos
         if uLightsDiffuse is not None:       self.uLightsDiffuse       = uLightsDiffuse
         if uLightsAmbient is not None:       self.uLightsAmbient       = uLightsAmbient
         if uLightsSpecular is not None:      self.uLightsSpecular      = uLightsSpecular
         if uLightsAtt is not None:           self.uLightsAtt           = uLightsAtt
         if uLightsSpotDir is not None:       self.uLightsSpotDir       = uLightsSpotDir
         if uLightsSpotCutOffCos is not None: self.uLightsSpotCutOffCos = uLightsSpotCutOffCos
         if uLightsSpotExp is not None:       self.uLightsSpotExp       = uLightsSpotExp
         if uMatDiffuse is not None:          self.uMatDiffuse          = uMatDiffuse
         if uMatAmbient is not None:          self.uMatAmbient          = uMatAmbient
         if uMatSpecular is not None:         self.uMatSpecular         = uMatSpecular
         if uMatEmissive is not None:         self.uMatEmissive         = uMatEmissive
         if uMatPower is not None:            self.uMatPower            = uMatPower
         if uMatOpacity is not None:          self.uMatOpacity          = uMatOpacity
         if uDiffuseTex is not None:          self.uDiffuseTex          = uDiffuseTex
         if uBumpTex is not None:             self.uBumpTex             = uBumpTex
         if uSpecularTex is not None:         self.uSpecularTex         = uSpecularTex
         if uEnvTex is not None:              self.uEnvTex              = uEnvTex
         if uReflectTex is not None:          self.uReflectTex          = uReflectTex
         if uRefractionETA is not None:       self.uRefractionETA       = uRefractionETA
         if uMatReflectivity is not None:     self.uMatReflectivity     = uMatReflectivity
         if uCubeMapMatrix is not None:       self.uCubeMapMatrix       = uCubeMapMatrix
         if uAlphaFuncValue is not None:      self.uAlphaFuncValue      = uAlphaFuncValue
         if uBlackTint is not None:           self.uBlackTint           = uBlackTint
         if uBoneMatrices is not None:        self.uBoneMatrices        = uBoneMatrices
         if uBoneOffsets is not None:         self.uBoneOffsets         = uBoneOffsets
         if initialSetup is not None:         self.initialSetup         = initialSetup
         if useNearPlane is not None:         self.useNearPlane         = useNearPlane

   @property
   def uPrjMatrix(self): return self.impl.uPrjMatrix
   @uPrjMatrix.setter
   def uPrjMatrix(self, value): self.impl.uPrjMatrix = value

   @property
   def uMVMatrix(self): return self.impl.uMVMatrix
   @uMVMatrix.setter
   def uMVMatrix(self, value): self.impl.uMVMatrix = value

   @property
   def uTextureMatrix(self): return self.impl.uTextureMatrix
   @uTextureMatrix.setter
   def uTextureMatrix(self, value): self.impl.uTextureMatrix = value

   @property
   def uNormalsMatrix(self): return self.impl.uNormalsMatrix
   @uNormalsMatrix.setter
   def uNormalsMatrix(self, value): self.impl.uNormalsMatrix = value

   @property
   def uNormalsInvScale2(self): return self.impl.uNormalsInvScale2
   @uNormalsInvScale2.setter
   def uNormalsInvScale2(self, value): self.impl.uNormalsInvScale2 = value

   @property
   def uFogDensity(self): return self.impl.uFogDensity
   @uFogDensity.setter
   def uFogDensity(self, value): self.impl.uFogDensity = value

   @property
   def uFogColor(self): return self.impl.uFogColor
   @uFogColor.setter
   def uFogColor(self, value): self.impl.uFogColor = value

   @property
   def uGlobalAmbient(self): return self.impl.uGlobalAmbient
   @uGlobalAmbient.setter
   def uGlobalAmbient(self, value): self.impl.uGlobalAmbient = value

   @property
   def uNearPlane(self): return self.impl.uNearPlane
   @uNearPlane.setter
   def uNearPlane(self, value): self.impl.uNearPlane = value

   @property
   def uLightsPos(self): return self.impl.uLightsPos
   @uLightsPos.setter
   def uLightsPos(self, value): self.impl.uLightsPos = value

   @property
   def uLightsDiffuse(self): return self.impl.uLightsDiffuse
   @uLightsDiffuse.setter
   def uLightsDiffuse(self, value): self.impl.uLightsDiffuse = value

   @property
   def uLightsAmbient(self): return self.impl.uLightsAmbient
   @uLightsAmbient.setter
   def uLightsAmbient(self, value): self.impl.uLightsAmbient = value

   @property
   def uLightsSpecular(self): return self.impl.uLightsSpecular
   @uLightsSpecular.setter
   def uLightsSpecular(self, value): self.impl.uLightsSpecular = value

   @property
   def uLightsAtt(self): return self.impl.uLightsAtt
   @uLightsAtt.setter
   def uLightsAtt(self, value): self.impl.uLightsAtt = value

   @property
   def uLightsSpotDir(self): return self.impl.uLightsSpotDir
   @uLightsSpotDir.setter
   def uLightsSpotDir(self, value): self.impl.uLightsSpotDir = value

   @property
   def uLightsSpotCutOffCos(self): return self.impl.uLightsSpotCutOffCos
   @uLightsSpotCutOffCos.setter
   def uLightsSpotCutOffCos(self, value): self.impl.uLightsSpotCutOffCos = value

   @property
   def uLightsSpotExp(self): return self.impl.uLightsSpotExp
   @uLightsSpotExp.setter
   def uLightsSpotExp(self, value): self.impl.uLightsSpotExp = value

   @property
   def uMatDiffuse(self): return self.impl.uMatDiffuse
   @uMatDiffuse.setter
   def uMatDiffuse(self, value): self.impl.uMatDiffuse = value

   @property
   def uMatAmbient(self): return self.impl.uMatAmbient
   @uMatAmbient.setter
   def uMatAmbient(self, value): self.impl.uMatAmbient = value

   @property
   def uMatSpecular(self): return self.impl.uMatSpecular
   @uMatSpecular.setter
   def uMatSpecular(self, value): self.impl.uMatSpecular = value

   @property
   def uMatEmissive(self): return self.impl.uMatEmissive
   @uMatEmissive.setter
   def uMatEmissive(self, value): self.impl.uMatEmissive = value

   @property
   def uMatPower(self): return self.impl.uMatPower
   @uMatPower.setter
   def uMatPower(self, value): self.impl.uMatPower = value

   @property
   def uMatOpacity(self): return self.impl.uMatOpacity
   @uMatOpacity.setter
   def uMatOpacity(self, value): self.impl.uMatOpacity = value

   @property
   def uDiffuseTex(self): return self.impl.uDiffuseTex
   @uDiffuseTex.setter
   def uDiffuseTex(self, value): self.impl.uDiffuseTex = value

   @property
   def uBumpTex(self): return self.impl.uBumpTex
   @uBumpTex.setter
   def uBumpTex(self, value): self.impl.uBumpTex = value

   @property
   def uSpecularTex(self): return self.impl.uSpecularTex
   @uSpecularTex.setter
   def uSpecularTex(self, value): self.impl.uSpecularTex = value

   @property
   def uEnvTex(self): return self.impl.uEnvTex
   @uEnvTex.setter
   def uEnvTex(self, value): self.impl.uEnvTex = value

   @property
   def uReflectTex(self): return self.impl.uReflectTex
   @uReflectTex.setter
   def uReflectTex(self, value): self.impl.uReflectTex = value

   @property
   def uRefractionETA(self): return self.impl.uRefractionETA
   @uRefractionETA.setter
   def uRefractionETA(self, value): self.impl.uRefractionETA = value

   @property
   def uMatReflectivity(self): return self.impl.uMatReflectivity
   @uMatReflectivity.setter
   def uMatReflectivity(self, value): self.impl.uMatReflectivity = value

   @property
   def uCubeMapMatrix(self): return self.impl.uCubeMapMatrix
   @uCubeMapMatrix.setter
   def uCubeMapMatrix(self, value): self.impl.uCubeMapMatrix = value

   @property
   def uAlphaFuncValue(self): return self.impl.uAlphaFuncValue
   @uAlphaFuncValue.setter
   def uAlphaFuncValue(self, value): self.impl.uAlphaFuncValue = value

   @property
   def uBlackTint(self): return self.impl.uBlackTint
   @uBlackTint.setter
   def uBlackTint(self, value): self.impl.uBlackTint = value

   @property
   def uBoneMatrices(self): return self.impl.uBoneMatrices
   @uBoneMatrices.setter
   def uBoneMatrices(self, value): self.impl.uBoneMatrices = value

   @property
   def uBoneOffsets(self): return self.impl.uBoneOffsets
   @uBoneOffsets.setter
   def uBoneOffsets(self, value): self.impl.uBoneOffsets = value

   @property
   def initialSetup(self): return self.impl.initialSetup
   @initialSetup.setter
   def initialSetup(self, value): self.impl.initialSetup = value

   @property
   def useNearPlane(self): return self.impl.useNearPlane
   @useNearPlane.setter
   def useNearPlane(self, value): self.impl.useNearPlane = value

   def registerUniforms(self, program, state):
      if state is not None and not isinstance(state, DefaultShaderBits): state = DefaultShaderBits(state)
      if state is None: state = ffi.NULL
      lib.CompiledDefaultShader_registerUniforms(ffi.cast("struct eC_CompiledDefaultShader *", self.impl), program, state)

class DefaultShader(Shader):
   class_members = [
                      'backLightState',
                      'blackTint',
                   ]

   def init_args(self, args, kwArgs): init_args(DefaultShader, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def backLightState(self): return DefaultShaderBits(impl = IPTR(lib, ffi, self, DefaultShader).backLightState)
   @backLightState.setter
   def backLightState(self, value):
      if not isinstance(value, DefaultShaderBits): value = DefaultShaderBits(value)
      IPTR(lib, ffi, self, DefaultShader).backLightState = value.impl

   @property
   def blackTint(self): return None
   @blackTint.setter
   def blackTint(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.DefaultShader_set_blackTint(self.impl, value.impl)

   def debugging(self, on):
      lib.DefaultShader_debugging(self.impl, on)

   def fog(self, on):
      lib.DefaultShader_fog(self.impl, on)

   def lighting(self, on):
      lib.DefaultShader_lighting(self.impl, on)

   def setBoneMatrices(self, n, matrices):
      lib.DefaultShader_setBoneMatrices(self.impl, n, matrices)

   def setCamera(self, camera = None):
      if camera is not None and not isinstance(camera, Camera): camera = Camera(camera)
      camera = ffi.NULL if camera is None else camera.impl
      lib.DefaultShader_setCamera(self.impl, camera)

   def setColor(self, r, g, b, a):
      lib.DefaultShader_setColor(self.impl, r, g, b, a)

   def setFogColor(self, r, g, b):
      lib.DefaultShader_setFogColor(self.impl, r, g, b)

   def setFogDensity(self, density):
      lib.DefaultShader_setFogDensity(self.impl, density)

   def setGlobalAmbient(self, r, g, b, a):
      lib.DefaultShader_setGlobalAmbient(self.impl, r, g, b, a)

   def setLight(self, display, id, light = None):
      if display is not None and not isinstance(display, Display): display = Display(display)
      display = ffi.NULL if display is None else display.impl
      if light is not None and not isinstance(light, Light): light = Light(light)
      light = ffi.NULL if light is None else light.impl
      lib.DefaultShader_setLight(self.impl, display, id, ffi.cast("eC_Light *", light))

   def setPerVertexColor(self, perVertexColor):
      lib.DefaultShader_setPerVertexColor(self.impl, perVertexColor)

   def setSimpleMaterial(self, color, twoSided):
      if color is not None and not isinstance(color, ColorAlpha): color = ColorAlpha(color)
      if color is None: color = ffi.NULL
      lib.DefaultShader_setSimpleMaterial(self.impl, color, twoSided)

   def shader():
      return pyOrNewObject(DefaultShader, lib.DefaultShader_shader())

   def swizzle(self, swizzle):
      lib.DefaultShader_swizzle(self.impl, swizzle)

   def texturing(self, on):
      lib.DefaultShader_texturing(self.impl, on)

   def useExternalTexture(self, on):
      lib.DefaultShader_useExternalTexture(self.impl, on)

class DefaultShaderBits(pyBaseClass):
   def __init__(self, lighting = False, nonLocalViewer = False, twoSided = False, specular = False, separateSpecular = False, blinnSpecular = False, lightBits = 0, perVertexColor = False, swizzle = 0, textureMatrix = False, texturing = False, alphaTest = False, cubeMap = False, modelView = False, fog = False, normalsMapping = False, specularMapping = False, environmentMapping = False, reflection = False, reflectionMap = False, refraction = False, debugging = False, constantColor = False, normalsInvScale2 = False, externalTexture = False, blackTint = False, textureArray = False, multiDraw = False, transform3D = False, squishFactor = False, bones = False,
                impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(lighting, DefaultShaderBits):
         self.impl = lighting.impl
      else:
         self.impl = (
            (lighting           << lib.DEFAULTSHADERBITS_lighting_SHIFT)           |
            (nonLocalViewer     << lib.DEFAULTSHADERBITS_nonLocalViewer_SHIFT)     |
            (twoSided           << lib.DEFAULTSHADERBITS_twoSided_SHIFT)           |
            (specular           << lib.DEFAULTSHADERBITS_specular_SHIFT)           |
            (separateSpecular   << lib.DEFAULTSHADERBITS_separateSpecular_SHIFT)   |
            (blinnSpecular      << lib.DEFAULTSHADERBITS_blinnSpecular_SHIFT)      |
            (lightBits          << lib.DEFAULTSHADERBITS_lightBits_SHIFT)          |
            (perVertexColor     << lib.DEFAULTSHADERBITS_perVertexColor_SHIFT)     |
            (swizzle            << lib.DEFAULTSHADERBITS_swizzle_SHIFT)            |
            (textureMatrix      << lib.DEFAULTSHADERBITS_textureMatrix_SHIFT)      |
            (texturing          << lib.DEFAULTSHADERBITS_texturing_SHIFT)          |
            (alphaTest          << lib.DEFAULTSHADERBITS_alphaTest_SHIFT)          |
            (cubeMap            << lib.DEFAULTSHADERBITS_cubeMap_SHIFT)            |
            (modelView          << lib.DEFAULTSHADERBITS_modelView_SHIFT)          |
            (fog                << lib.DEFAULTSHADERBITS_fog_SHIFT)                |
            (normalsMapping     << lib.DEFAULTSHADERBITS_normalsMapping_SHIFT)     |
            (specularMapping    << lib.DEFAULTSHADERBITS_specularMapping_SHIFT)    |
            (environmentMapping << lib.DEFAULTSHADERBITS_environmentMapping_SHIFT) |
            (reflection         << lib.DEFAULTSHADERBITS_reflection_SHIFT)         |
            (reflectionMap      << lib.DEFAULTSHADERBITS_reflectionMap_SHIFT)      |
            (refraction         << lib.DEFAULTSHADERBITS_refraction_SHIFT)         |
            (debugging          << lib.DEFAULTSHADERBITS_debugging_SHIFT)          |
            (constantColor      << lib.DEFAULTSHADERBITS_constantColor_SHIFT)      |
            (normalsInvScale2   << lib.DEFAULTSHADERBITS_normalsInvScale2_SHIFT)   |
            (externalTexture    << lib.DEFAULTSHADERBITS_externalTexture_SHIFT)    |
            (blackTint          << lib.DEFAULTSHADERBITS_blackTint_SHIFT)          |
            (textureArray       << lib.DEFAULTSHADERBITS_textureArray_SHIFT)       |
            (multiDraw          << lib.DEFAULTSHADERBITS_multiDraw_SHIFT)          |
            (transform3D        << lib.DEFAULTSHADERBITS_transform3D_SHIFT)        |
            (squishFactor       << lib.DEFAULTSHADERBITS_squishFactor_SHIFT)       |
            (bones              << lib.DEFAULTSHADERBITS_bones_SHIFT)              )

   @property
   def lighting(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_lighting_MASK) >> lib.DEFAULTSHADERBITS_lighting_SHIFT)
   @lighting.setter
   def lighting(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_lighting_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_lighting_SHIFT)

   @property
   def nonLocalViewer(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_nonLocalViewer_MASK) >> lib.DEFAULTSHADERBITS_nonLocalViewer_SHIFT)
   @nonLocalViewer.setter
   def nonLocalViewer(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_nonLocalViewer_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_nonLocalViewer_SHIFT)

   @property
   def twoSided(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_twoSided_MASK) >> lib.DEFAULTSHADERBITS_twoSided_SHIFT)
   @twoSided.setter
   def twoSided(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_twoSided_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_twoSided_SHIFT)

   @property
   def specular(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_specular_MASK) >> lib.DEFAULTSHADERBITS_specular_SHIFT)
   @specular.setter
   def specular(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_specular_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_specular_SHIFT)

   @property
   def separateSpecular(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_separateSpecular_MASK) >> lib.DEFAULTSHADERBITS_separateSpecular_SHIFT)
   @separateSpecular.setter
   def separateSpecular(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_separateSpecular_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_separateSpecular_SHIFT)

   @property
   def blinnSpecular(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_blinnSpecular_MASK) >> lib.DEFAULTSHADERBITS_blinnSpecular_SHIFT)
   @blinnSpecular.setter
   def blinnSpecular(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_blinnSpecular_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_blinnSpecular_SHIFT)

   @property
   def lightBits(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_lightBits_MASK) >> lib.DEFAULTSHADERBITS_lightBits_SHIFT)
   @lightBits.setter
   def lightBits(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_lightBits_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_lightBits_SHIFT)

   @property
   def perVertexColor(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_perVertexColor_MASK) >> lib.DEFAULTSHADERBITS_perVertexColor_SHIFT)
   @perVertexColor.setter
   def perVertexColor(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_perVertexColor_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_perVertexColor_SHIFT)

   @property
   def swizzle(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_swizzle_MASK) >> lib.DEFAULTSHADERBITS_swizzle_SHIFT)
   @swizzle.setter
   def swizzle(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_swizzle_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_swizzle_SHIFT)

   @property
   def textureMatrix(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_textureMatrix_MASK) >> lib.DEFAULTSHADERBITS_textureMatrix_SHIFT)
   @textureMatrix.setter
   def textureMatrix(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_textureMatrix_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_textureMatrix_SHIFT)

   @property
   def texturing(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_texturing_MASK) >> lib.DEFAULTSHADERBITS_texturing_SHIFT)
   @texturing.setter
   def texturing(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_texturing_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_texturing_SHIFT)

   @property
   def alphaTest(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_alphaTest_MASK) >> lib.DEFAULTSHADERBITS_alphaTest_SHIFT)
   @alphaTest.setter
   def alphaTest(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_alphaTest_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_alphaTest_SHIFT)

   @property
   def cubeMap(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_cubeMap_MASK) >> lib.DEFAULTSHADERBITS_cubeMap_SHIFT)
   @cubeMap.setter
   def cubeMap(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_cubeMap_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_cubeMap_SHIFT)

   @property
   def modelView(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_modelView_MASK) >> lib.DEFAULTSHADERBITS_modelView_SHIFT)
   @modelView.setter
   def modelView(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_modelView_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_modelView_SHIFT)

   @property
   def fog(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_fog_MASK) >> lib.DEFAULTSHADERBITS_fog_SHIFT)
   @fog.setter
   def fog(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_fog_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_fog_SHIFT)

   @property
   def normalsMapping(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_normalsMapping_MASK) >> lib.DEFAULTSHADERBITS_normalsMapping_SHIFT)
   @normalsMapping.setter
   def normalsMapping(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_normalsMapping_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_normalsMapping_SHIFT)

   @property
   def specularMapping(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_specularMapping_MASK) >> lib.DEFAULTSHADERBITS_specularMapping_SHIFT)
   @specularMapping.setter
   def specularMapping(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_specularMapping_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_specularMapping_SHIFT)

   @property
   def environmentMapping(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_environmentMapping_MASK) >> lib.DEFAULTSHADERBITS_environmentMapping_SHIFT)
   @environmentMapping.setter
   def environmentMapping(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_environmentMapping_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_environmentMapping_SHIFT)

   @property
   def reflection(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_reflection_MASK) >> lib.DEFAULTSHADERBITS_reflection_SHIFT)
   @reflection.setter
   def reflection(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_reflection_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_reflection_SHIFT)

   @property
   def reflectionMap(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_reflectionMap_MASK) >> lib.DEFAULTSHADERBITS_reflectionMap_SHIFT)
   @reflectionMap.setter
   def reflectionMap(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_reflectionMap_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_reflectionMap_SHIFT)

   @property
   def refraction(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_refraction_MASK) >> lib.DEFAULTSHADERBITS_refraction_SHIFT)
   @refraction.setter
   def refraction(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_refraction_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_refraction_SHIFT)

   @property
   def debugging(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_debugging_MASK) >> lib.DEFAULTSHADERBITS_debugging_SHIFT)
   @debugging.setter
   def debugging(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_debugging_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_debugging_SHIFT)

   @property
   def constantColor(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_constantColor_MASK) >> lib.DEFAULTSHADERBITS_constantColor_SHIFT)
   @constantColor.setter
   def constantColor(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_constantColor_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_constantColor_SHIFT)

   @property
   def normalsInvScale2(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_normalsInvScale2_MASK) >> lib.DEFAULTSHADERBITS_normalsInvScale2_SHIFT)
   @normalsInvScale2.setter
   def normalsInvScale2(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_normalsInvScale2_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_normalsInvScale2_SHIFT)

   @property
   def externalTexture(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_externalTexture_MASK) >> lib.DEFAULTSHADERBITS_externalTexture_SHIFT)
   @externalTexture.setter
   def externalTexture(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_externalTexture_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_externalTexture_SHIFT)

   @property
   def blackTint(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_blackTint_MASK) >> lib.DEFAULTSHADERBITS_blackTint_SHIFT)
   @blackTint.setter
   def blackTint(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_blackTint_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_blackTint_SHIFT)

   @property
   def textureArray(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_textureArray_MASK) >> lib.DEFAULTSHADERBITS_textureArray_SHIFT)
   @textureArray.setter
   def textureArray(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_textureArray_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_textureArray_SHIFT)

   @property
   def multiDraw(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_multiDraw_MASK) >> lib.DEFAULTSHADERBITS_multiDraw_SHIFT)
   @multiDraw.setter
   def multiDraw(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_multiDraw_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_multiDraw_SHIFT)

   @property
   def transform3D(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_transform3D_MASK) >> lib.DEFAULTSHADERBITS_transform3D_SHIFT)
   @transform3D.setter
   def transform3D(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_transform3D_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_transform3D_SHIFT)

   @property
   def squishFactor(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_squishFactor_MASK) >> lib.DEFAULTSHADERBITS_squishFactor_SHIFT)
   @squishFactor.setter
   def squishFactor(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_squishFactor_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_squishFactor_SHIFT)

   @property
   def bones(self): return ((((self.impl)) & lib.DEFAULTSHADERBITS_bones_MASK) >> lib.DEFAULTSHADERBITS_bones_SHIFT)
   @bones.setter
   def bones(self, value): self.impl = ((self.impl) & ~(lib.DEFAULTSHADERBITS_bones_MASK)) | (((value)) << lib.DEFAULTSHADERBITS_bones_SHIFT)

class GLAttribMode:
   none       = lib.GLAttribMode_none
   normalized = lib.GLAttribMode_normalized
   integer    = lib.GLAttribMode_integer
   longDouble = lib.GLAttribMode_longDouble

class GLBType:
   elements   = lib.GLBType_elements
   attributes = lib.GLBType_attributes
   commands   = lib.GLBType_commands

class GLBufferContents:
   vertex       = lib.GLBufferContents_vertex
   normal       = lib.GLBufferContents_normal
   texCoord     = lib.GLBufferContents_texCoord
   color        = lib.GLBufferContents_color
   tangent1     = lib.GLBufferContents_tangent1
   tangent2     = lib.GLBufferContents_tangent2
   lightVector  = lib.GLBufferContents_lightVector
   boneIndices1 = lib.GLBufferContents_boneIndices1
   boneIndices2 = lib.GLBufferContents_boneIndices2
   boneIndices3 = lib.GLBufferContents_boneIndices3
   boneWeights1 = lib.GLBufferContents_boneWeights1
   boneWeights2 = lib.GLBufferContents_boneWeights2
   boneWeights3 = lib.GLBufferContents_boneWeights3

class GLBufferUsage:
   staticDraw  = lib.GLBufferUsage_staticDraw
   dynamicDraw = lib.GLBufferUsage_dynamicDraw
   streamDraw  = lib.GLBufferUsage_streamDraw

class GLCAB(GLB):
   def __init__(self, buffer = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_GLCAB *", impl)
      else:
         self.impl = ffi.new("eC_GLCAB *", { 'buffer' : buffer })

   def allocate(self, size, data, usage):
      if hasattr(data, 'impl'): data = data.impl
      if data is None: data = ffi.NULL
      return lib.GLCAB_allocate(ffi.cast("eC_GLCAB *", self.impl), size, data, usage)

   def upload(self, offset, size, data):
      if hasattr(data, 'impl'): data = data.impl
      if data is None: data = ffi.NULL
      lib.GLCAB_upload(ffi.cast("eC_GLCAB *", self.impl), offset, size, data)

class GLFB(Struct):
   def __init__(self, w = 0, h = 0, fbo = 0, color = 0, depth = 0, samples = 0, colorRBO = 0, depthRBO = 0, depthFormat = 0, colorFormat = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_GLFB *", impl)
      else:
         self.impl = ffi.new("eC_GLFB *", {
                                'w' : w,
                                'h' : h,
                                'fbo' : fbo,
                                'color' : color,
                                'depth' : depth,
                                'samples' : samples,
                                'colorRBO' : colorRBO,
                                'depthRBO' : depthRBO,
                                'depthFormat' : depthFormat,
                                'colorFormat' : colorFormat
                             })

   @property
   def w(self): return self.impl.w
   @w.setter
   def w(self, value): self.impl.w = value

   @property
   def h(self): return self.impl.h
   @h.setter
   def h(self, value): self.impl.h = value

   @property
   def fbo(self): return self.impl.fbo
   @fbo.setter
   def fbo(self, value): self.impl.fbo = value

   @property
   def color(self): return self.impl.color
   @color.setter
   def color(self, value): self.impl.color = value

   @property
   def depth(self): return self.impl.depth
   @depth.setter
   def depth(self, value): self.impl.depth = value

   @property
   def samples(self): return self.impl.samples
   @samples.setter
   def samples(self, value): self.impl.samples = value

   @property
   def colorRBO(self): return self.impl.colorRBO
   @colorRBO.setter
   def colorRBO(self, value): self.impl.colorRBO = value

   @property
   def depthRBO(self): return self.impl.depthRBO
   @depthRBO.setter
   def depthRBO(self, value): self.impl.depthRBO = value

   @property
   def depthFormat(self): return self.impl.depthFormat
   @depthFormat.setter
   def depthFormat(self, value): self.impl.depthFormat = value

   @property
   def colorFormat(self): return self.impl.colorFormat
   @colorFormat.setter
   def colorFormat(self, value): self.impl.colorFormat = value

   def copy(self, src, srcExtent, dstExtent, buffers, filter):
      if src is not None and not isinstance(src, GLFB): src = GLFB(src)
      src = ffi.NULL if src is None else src.impl
      if srcExtent is not None and not isinstance(srcExtent, Box): srcExtent = Box(srcExtent)
      srcExtent = ffi.NULL if srcExtent is None else srcExtent.impl
      if dstExtent is not None and not isinstance(dstExtent, Box): dstExtent = Box(dstExtent)
      dstExtent = ffi.NULL if dstExtent is None else dstExtent.impl
      lib.GLFB_copy(ffi.cast("eC_GLFB *", self.impl), ffi.cast("eC_GLFB *", src), ffi.cast("eC_Box *", srcExtent), ffi.cast("eC_Box *", dstExtent), buffers, filter)

   def copyToTexture(self):
      lib.GLFB_copyToTexture(ffi.cast("eC_GLFB *", self.impl))

   def free(self):
      lib.GLFB_free(ffi.cast("eC_GLFB *", self.impl))

   def read(self, bitmap, buffer, sRGB):
      if bitmap is not None and not isinstance(bitmap, Bitmap): bitmap = Bitmap(bitmap)
      bitmap = ffi.NULL if bitmap is None else bitmap.impl
      lib.GLFB_read(ffi.cast("eC_GLFB *", self.impl), bitmap, buffer, sRGB)

   def setup(self, textureFBO, allocTextures, samples, colorFormat, depthFormat, width, height):
      return lib.GLFB_setup(ffi.cast("eC_GLFB *", self.impl), textureFBO, allocTextures, samples, colorFormat, depthFormat, width, height)

class GLIMTKMode:
   unset         = lib.GLIMTKMode_unset
   points        = lib.GLIMTKMode_points
   lines         = lib.GLIMTKMode_lines
   lineLoop      = lib.GLIMTKMode_lineLoop
   lineStrip     = lib.GLIMTKMode_lineStrip
   triangles     = lib.GLIMTKMode_triangles
   triangleStrip = lib.GLIMTKMode_triangleStrip
   triangleFan   = lib.GLIMTKMode_triangleFan
   quads         = lib.GLIMTKMode_quads
   quadStrip     = lib.GLIMTKMode_quadStrip
   polygon       = lib.GLIMTKMode_polygon

class GLMB(FreeBlockMap):
   class_members = [
                      'ab',
                      'keepSameBufferID',
                   ]

   def init_args(self, args, kwArgs): init_args(GLMB, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def ab(self): return GLB(impl = IPTR(lib, ffi, self, GLMB).ab)
   @ab.setter
   def ab(self, value):
      if not isinstance(value, GLB): value = GLB(value)
      IPTR(lib, ffi, self, GLMB).ab = value.impl

   @property
   def keepSameBufferID(self): return IPTR(lib, ffi, self, GLMB).keepSameBufferID
   @keepSameBufferID.setter
   def keepSameBufferID(self, value): IPTR(lib, ffi, self, GLMB).keepSameBufferID = value

   def free(self):
      lib.GLMB_free(self.impl)

   def printStats(self):
      lib.GLMB_printStats(self.impl)

class GLMSWhatToGet:
   modelViewMatrix  = lib.GLMSWhatToGet_modelViewMatrix
   projectionMatrix = lib.GLMSWhatToGet_projectionMatrix
   textureMatrix    = lib.GLMSWhatToGet_textureMatrix

class GLStats(Instance):
   class_members = []

   def init_args(self, args, kwArgs): init_args(GLStats, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def allocBuffer(buf, size):
      lib.GLStats_allocBuffer(buf, size)

   def allocTexture(tex, w, h, mipMaps):
      lib.GLStats_allocTexture(tex, w, h, mipMaps)

   def freeBuffers(count):
      bufs = ffi.new("uint *")
      lib.GLStats_freeBuffers(count, bufs)
      return bufs[0]

   def freeTextures(count):
      texs = ffi.new("uint *")
      lib.GLStats_freeTextures(count, texs)
      return texs[0]

   def _print():
      lib.GLStats_print()

   def printBuf(output, size):
      if isinstance(output, str): output = ffi.new("char[]", output.encode('u8'))
      elif output is None: output = ffi.NULL
      lib.GLStats_printBuf(output, size)

class LFBDisplay:
   def __init__(self, bitmap = None, rgbLookup = None, lightTable = None, updateBoxes = None, x = None, y = None, selfManaged = None, displayCallback = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_LFBDisplay *", lib.Instance_new(lib.class_LFBDisplay))
         if bitmap is not None:          self.bitmap          = bitmap
         if rgbLookup is not None:       self.rgbLookup       = rgbLookup
         if lightTable is not None:      self.lightTable      = lightTable
         if updateBoxes is not None:     self.updateBoxes     = updateBoxes
         if x is not None:               self.x               = x
         if y is not None:               self.y               = y
         if selfManaged is not None:     self.selfManaged     = selfManaged
         if displayCallback is not None: self.displayCallback = displayCallback

   @property
   def bitmap(self): return pyOrNewObject(Bitmap, self.impl.bitmap)
   @bitmap.setter
   def bitmap(self, value):
      if not isinstance(value, Bitmap): value = Bitmap(value)
      self.impl.bitmap = value.impl

   @property
   def rgbLookup(self): return self.impl.rgbLookup
   @rgbLookup.setter
   def rgbLookup(self, value): self.impl.rgbLookup = value

   @property
   def lightTable(self): return self.impl.lightTable
   @lightTable.setter
   def lightTable(self, value): self.impl.lightTable = value

   @property
   def updateBoxes(self): return OldList(impl = self.impl.updateBoxes)
   @updateBoxes.setter
   def updateBoxes(self, value):
      if not isinstance(value, OldList): value = OldList(value)
      self.impl.updateBoxes = value.impl[0]

   @property
   def x(self): return self.impl.x
   @x.setter
   def x(self, value): self.impl.x = value

   @property
   def y(self): return self.impl.y
   @y.setter
   def y(self, value): self.impl.y = value

   @property
   def selfManaged(self): return self.impl.selfManaged
   @selfManaged.setter
   def selfManaged(self, value): self.impl.selfManaged = value

   @property
   def displayCallback(self): return self.impl.displayCallback
   @displayCallback.setter
   def displayCallback(self, value): self.impl.displayCallback = value

class LFBDisplayDriver(DisplayDriver):
   class_members = []

   def init_args(self, args, kwArgs): init_args(LFBDisplayDriver, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class LFBSurface:
   def __init__(self, font = None, opaqueText = None, xOffset = None, writingText = None, writingOutline = None, bitmap = None, foreground = None, background = None, foregroundRgb = None, stipple = None, drawingChar = None, paletteShades = None, clearing = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_LFBSurface *", lib.Instance_new(lib.class_LFBSurface))
         if font is not None:           self.font           = font
         if opaqueText is not None:     self.opaqueText     = opaqueText
         if xOffset is not None:        self.xOffset        = xOffset
         if writingText is not None:    self.writingText    = writingText
         if writingOutline is not None: self.writingOutline = writingOutline
         if bitmap is not None:         self.bitmap         = bitmap
         if foreground is not None:     self.foreground     = foreground
         if background is not None:     self.background     = background
         if foregroundRgb is not None:  self.foregroundRgb  = foregroundRgb
         if stipple is not None:        self.stipple        = stipple
         if drawingChar is not None:    self.drawingChar    = drawingChar
         if paletteShades is not None:  self.paletteShades  = paletteShades
         if clearing is not None:       self.clearing       = clearing

   @property
   def font(self): return self.impl.font
   @font.setter
   def font(self, value):
      if not isinstance(value, Font): value = Font(value)
      self.impl.font = value.impl

   @property
   def opaqueText(self): return self.impl.opaqueText
   @opaqueText.setter
   def opaqueText(self, value): self.impl.opaqueText = value

   @property
   def xOffset(self): return self.impl.xOffset
   @xOffset.setter
   def xOffset(self, value): self.impl.xOffset = value

   @property
   def writingText(self): return self.impl.writingText
   @writingText.setter
   def writingText(self, value): self.impl.writingText = value

   @property
   def writingOutline(self): return self.impl.writingOutline
   @writingOutline.setter
   def writingOutline(self, value): self.impl.writingOutline = value

   @property
   def bitmap(self): return pyOrNewObject(Bitmap, self.impl.bitmap)
   @bitmap.setter
   def bitmap(self, value):
      if not isinstance(value, Bitmap): value = Bitmap(value)
      self.impl.bitmap = value.impl

   @property
   def foreground(self): return self.impl.foreground
   @foreground.setter
   def foreground(self, value): self.impl.foreground = value

   @property
   def background(self): return self.impl.background
   @background.setter
   def background(self, value): self.impl.background = value

   @property
   def foregroundRgb(self): return ColorAlpha(impl = self.impl.foregroundRgb)
   @foregroundRgb.setter
   def foregroundRgb(self, value):
      if not isinstance(value, ColorAlpha): value = ColorAlpha(value)
      self.impl.foregroundRgb = value.impl

   @property
   def stipple(self): return self.impl.stipple
   @stipple.setter
   def stipple(self, value): self.impl.stipple = value

   @property
   def drawingChar(self): return self.impl.drawingChar
   @drawingChar.setter
   def drawingChar(self, value): self.impl.drawingChar = value

   @property
   def paletteShades(self): return self.impl.paletteShades
   @paletteShades.setter
   def paletteShades(self, value): self.impl.paletteShades = value

   @property
   def clearing(self): return self.impl.clearing
   @clearing.setter
   def clearing(self, value): self.impl.clearing = value

class LFBSystem:
   def __init__(self, format = None, palette = None, rgbLookup = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_LFBSystem *", lib.Instance_new(lib.class_LFBSystem))
         if isinstance(format, tuple):
            __tuple = format
            format = 0
            if len(__tuple) > 0: format    = __tuple[0]
            if len(__tuple) > 1: palette   = __tuple[1]
            if len(__tuple) > 2: rgbLookup = __tuple[2]
         if format is not None:    self.format    = format
         if palette is not None:   self.palette   = palette
         if rgbLookup is not None: self.rgbLookup = rgbLookup

   @property
   def format(self): return self.impl.format
   @format.setter
   def format(self, value): self.impl.format = value

   @property
   def palette(self): return self.impl.palette
   @palette.setter
   def palette(self, value): self.impl.palette = value

   @property
   def rgbLookup(self): return self.impl.rgbLookup
   @rgbLookup.setter
   def rgbLookup(self, value): self.impl.rgbLookup = value

class LightMode:
   off        = lib.LightMode_off
   dir        = lib.LightMode_dir
   pos        = lib.LightMode_pos
   posAtt     = lib.LightMode_posAtt
   posSpot    = lib.LightMode_posSpot
   posSpotAtt = lib.LightMode_posSpotAtt

class MatrixMode:
   modelView  = lib.MatrixMode_modelView
   projection = lib.MatrixMode_projection
   texture    = lib.MatrixMode_texture

class ShaderModifiedUniforms(pyBaseClass):
   def __init__(self, matMV = False, light = False, material = False, matPrj = False, matTex = False, pos = False, layer = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(matMV, ShaderModifiedUniforms):
         self.impl = matMV.impl
      else:
         self.impl = (
            (matMV    << lib.SHADERMODIFIEDUNIFORMS_matMV_SHIFT)    |
            (light    << lib.SHADERMODIFIEDUNIFORMS_light_SHIFT)    |
            (material << lib.SHADERMODIFIEDUNIFORMS_material_SHIFT) |
            (matPrj   << lib.SHADERMODIFIEDUNIFORMS_matPrj_SHIFT)   |
            (matTex   << lib.SHADERMODIFIEDUNIFORMS_matTex_SHIFT)   |
            (pos      << lib.SHADERMODIFIEDUNIFORMS_pos_SHIFT)      |
            (layer    << lib.SHADERMODIFIEDUNIFORMS_layer_SHIFT)    )

   @property
   def matMV(self): return ((((self.impl)) & lib.SHADERMODIFIEDUNIFORMS_matMV_MASK) >> lib.SHADERMODIFIEDUNIFORMS_matMV_SHIFT)
   @matMV.setter
   def matMV(self, value): self.impl = ((self.impl) & ~(lib.SHADERMODIFIEDUNIFORMS_matMV_MASK)) | (((value)) << lib.SHADERMODIFIEDUNIFORMS_matMV_SHIFT)

   @property
   def light(self): return ((((self.impl)) & lib.SHADERMODIFIEDUNIFORMS_light_MASK) >> lib.SHADERMODIFIEDUNIFORMS_light_SHIFT)
   @light.setter
   def light(self, value): self.impl = ((self.impl) & ~(lib.SHADERMODIFIEDUNIFORMS_light_MASK)) | (((value)) << lib.SHADERMODIFIEDUNIFORMS_light_SHIFT)

   @property
   def material(self): return ((((self.impl)) & lib.SHADERMODIFIEDUNIFORMS_material_MASK) >> lib.SHADERMODIFIEDUNIFORMS_material_SHIFT)
   @material.setter
   def material(self, value): self.impl = ((self.impl) & ~(lib.SHADERMODIFIEDUNIFORMS_material_MASK)) | (((value)) << lib.SHADERMODIFIEDUNIFORMS_material_SHIFT)

   @property
   def matPrj(self): return ((((self.impl)) & lib.SHADERMODIFIEDUNIFORMS_matPrj_MASK) >> lib.SHADERMODIFIEDUNIFORMS_matPrj_SHIFT)
   @matPrj.setter
   def matPrj(self, value): self.impl = ((self.impl) & ~(lib.SHADERMODIFIEDUNIFORMS_matPrj_MASK)) | (((value)) << lib.SHADERMODIFIEDUNIFORMS_matPrj_SHIFT)

   @property
   def matTex(self): return ((((self.impl)) & lib.SHADERMODIFIEDUNIFORMS_matTex_MASK) >> lib.SHADERMODIFIEDUNIFORMS_matTex_SHIFT)
   @matTex.setter
   def matTex(self, value): self.impl = ((self.impl) & ~(lib.SHADERMODIFIEDUNIFORMS_matTex_MASK)) | (((value)) << lib.SHADERMODIFIEDUNIFORMS_matTex_SHIFT)

   @property
   def pos(self): return ((((self.impl)) & lib.SHADERMODIFIEDUNIFORMS_pos_MASK) >> lib.SHADERMODIFIEDUNIFORMS_pos_SHIFT)
   @pos.setter
   def pos(self, value): self.impl = ((self.impl) & ~(lib.SHADERMODIFIEDUNIFORMS_pos_MASK)) | (((value)) << lib.SHADERMODIFIEDUNIFORMS_pos_SHIFT)

   @property
   def layer(self): return ((((self.impl)) & lib.SHADERMODIFIEDUNIFORMS_layer_MASK) >> lib.SHADERMODIFIEDUNIFORMS_layer_SHIFT)
   @layer.setter
   def layer(self, value): self.impl = ((self.impl) & ~(lib.SHADERMODIFIEDUNIFORMS_layer_MASK)) | (((value)) << lib.SHADERMODIFIEDUNIFORMS_layer_SHIFT)

class SwizzleMode:
   off   = lib.SwizzleMode_off
   alpha = lib.SwizzleMode_alpha
   red   = lib.SwizzleMode_red

def gLABBindBuffer(target, buffer):
   lib.eC_gLABBindBuffer(target, buffer)

def gLABBindVertexArray(vao):
   lib.eC_gLABBindVertexArray(vao)

def gLSetupFog(enable):
   lib.eC_gLSetupFog(enable)

def gLSetupLighting(enable):
   lib.eC_gLSetupLighting(enable)

def gLSetupTexturing(enable):
   lib.eC_gLSetupTexturing(enable)

def useSingleGLContext(useSingle):
   lib.eC_useSingleGLContext(useSingle)

def glimtkBegin(mode):
   lib.eC_glimtkBegin(mode)

def glimtkColor3f(r, g, b):
   lib.eC_glimtkColor3f(r, g, b)

def glimtkColor4f(r, g, b, a):
   lib.eC_glimtkColor4f(r, g, b, a)

def glimtkColor4fv():
   a = ffi.new("float *")
   lib.eC_glimtkColor4fv(a)
   return a[0]

def glimtkColor4ub(r, g, b, a):
   lib.eC_glimtkColor4ub(r, g, b, a)

def glimtkEnd():
   lib.eC_glimtkEnd()

def glimtkNormal3d(x, y, z):
   lib.eC_glimtkNormal3d(x, y, z)

def glimtkNormal3f(x, y, z):
   lib.eC_glimtkNormal3f(x, y, z)

def glimtkNormal3fd():
   coords = ffi.new("double *")
   lib.eC_glimtkNormal3fd(coords)
   return coords[0]

def glimtkNormal3fv():
   coords = ffi.new("float *")
   lib.eC_glimtkNormal3fv(coords)
   return coords[0]

def glimtkRecti(a, b, c, d):
   lib.eC_glimtkRecti(a, b, c, d)

def glimtkTexCoord2d(x, y):
   lib.eC_glimtkTexCoord2d(x, y)

def glimtkTexCoord2f(x, y):
   lib.eC_glimtkTexCoord2f(x, y)

def glimtkTexCoord2fv():
   a = ffi.new("float *")
   lib.eC_glimtkTexCoord2fv(a)
   return a[0]

def glimtkTexCoord2i(x, y):
   lib.eC_glimtkTexCoord2i(x, y)

def glimtkVertex2d(x, y):
   lib.eC_glimtkVertex2d(x, y)

def glimtkVertex2f(x, y):
   lib.eC_glimtkVertex2f(x, y)

def glimtkVertex2i(x, y):
   lib.eC_glimtkVertex2i(x, y)

def glimtkVertex3d(x, y, z):
   lib.eC_glimtkVertex3d(x, y, z)

def glimtkVertex3dv():
   coords = ffi.new("double *")
   lib.eC_glimtkVertex3dv(coords)
   return coords[0]

def glimtkVertex3f(x, y, z):
   lib.eC_glimtkVertex3f(x, y, z)

def glimtkVertex3fv():
   coords = ffi.new("float *")
   lib.eC_glimtkVertex3fv(coords)
   return coords[0]

def glmsFlushMatrices():
   lib.eC_glmsFlushMatrices()

def glmsFrustum(l, r, b, t, n, f):
   lib.eC_glmsFrustum(l, r, b, t, n, f)

def glmsGetDoublev(what):
   i = ffi.new("double *")
   lib.eC_glmsGetDoublev(what, i)
   return i[0]

def glmsGetNearPlane():
   return lib.eC_glmsGetNearPlane()

def glmsLoadIdentity():
   lib.eC_glmsLoadIdentity()

def glmsLoadMatrix(matrix = None):
   if matrix is not None and not isinstance(matrix, Matrix): matrix = Matrix(matrix)
   matrix = ffi.NULL if matrix is None else matrix.impl
   lib.eC_glmsLoadMatrix(ffi.cast("eC_Matrix *", matrix))

def glmsLoadMatrixd():
   i = ffi.new("double *")
   lib.eC_glmsLoadMatrixd(i)
   return i[0]

def glmsLoadMatrixf():
   i = ffi.new("float *")
   lib.eC_glmsLoadMatrixf(i)
   return i[0]

def glmsMatrixMode(mode):
   lib.eC_glmsMatrixMode(mode)

def glmsMultMatrixd():
   i = ffi.new("double *")
   lib.eC_glmsMultMatrixd(i)
   return i[0]

def glmsMultMatrixf():
   i = ffi.new("float *")
   lib.eC_glmsMultMatrixf(i)
   return i[0]

def glmsOrtho(l, r, b, t, n, f):
   lib.eC_glmsOrtho(l, r, b, t, n, f)

def glmsPopMatrix():
   lib.eC_glmsPopMatrix()

def glmsPushMatrix():
   lib.eC_glmsPushMatrix()

def glmsRotated(angle, x, y, z):
   lib.eC_glmsRotated(angle, x, y, z)

def glmsScaled(a, b, c):
   lib.eC_glmsScaled(a, b, c)

def glmsSetNearPlane(value):
   lib.eC_glmsSetNearPlane(value)

def glmsTranslated(a, b, c):
   lib.eC_glmsTranslated(a, b, c)

def glsupLightModeli(pname, param):
   lib.eC_glsupLightModeli(pname, param)

def glsupLineStipple(i, j):
   lib.eC_glsupLineStipple(i, j)

class PrimitiveGroupType(pyBaseClass):
   def __init__(self, primitiveType = 0, vertexRange = False, indices32bit = False, sharedIndices = False, hide = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(primitiveType, PrimitiveGroupType):
         self.impl = primitiveType.impl
      else:
         if isinstance(primitiveType, tuple):
            __tuple = primitiveType
            primitiveType = 0
            if len(__tuple) > 0: primitiveType = __tuple[0]
            if len(__tuple) > 1: vertexRange = __tuple[1]
            if len(__tuple) > 2: indices32bit = __tuple[2]
            if len(__tuple) > 3: sharedIndices = __tuple[3]
            if len(__tuple) > 4: hide = __tuple[4]
         self.impl = (
            (primitiveType << lib.PRIMITIVEGROUPTYPE_primitiveType_SHIFT) |
            (vertexRange   << lib.PRIMITIVEGROUPTYPE_vertexRange_SHIFT)   |
            (indices32bit  << lib.PRIMITIVEGROUPTYPE_indices32bit_SHIFT)  |
            (sharedIndices << lib.PRIMITIVEGROUPTYPE_sharedIndices_SHIFT) |
            (hide          << lib.PRIMITIVEGROUPTYPE_hide_SHIFT)          )

   @property
   def primitiveType(self): return ((((self.impl)) & lib.PRIMITIVEGROUPTYPE_primitiveType_MASK) >> lib.PRIMITIVEGROUPTYPE_primitiveType_SHIFT)
   @primitiveType.setter
   def primitiveType(self, value): self.impl = ((self.impl) & ~(lib.PRIMITIVEGROUPTYPE_primitiveType_MASK)) | (((value)) << lib.PRIMITIVEGROUPTYPE_primitiveType_SHIFT)

   @property
   def vertexRange(self): return ((((self.impl)) & lib.PRIMITIVEGROUPTYPE_vertexRange_MASK) >> lib.PRIMITIVEGROUPTYPE_vertexRange_SHIFT)
   @vertexRange.setter
   def vertexRange(self, value): self.impl = ((self.impl) & ~(lib.PRIMITIVEGROUPTYPE_vertexRange_MASK)) | (((value)) << lib.PRIMITIVEGROUPTYPE_vertexRange_SHIFT)

   @property
   def indices32bit(self): return ((((self.impl)) & lib.PRIMITIVEGROUPTYPE_indices32bit_MASK) >> lib.PRIMITIVEGROUPTYPE_indices32bit_SHIFT)
   @indices32bit.setter
   def indices32bit(self, value): self.impl = ((self.impl) & ~(lib.PRIMITIVEGROUPTYPE_indices32bit_MASK)) | (((value)) << lib.PRIMITIVEGROUPTYPE_indices32bit_SHIFT)

   @property
   def sharedIndices(self): return ((((self.impl)) & lib.PRIMITIVEGROUPTYPE_sharedIndices_MASK) >> lib.PRIMITIVEGROUPTYPE_sharedIndices_SHIFT)
   @sharedIndices.setter
   def sharedIndices(self, value): self.impl = ((self.impl) & ~(lib.PRIMITIVEGROUPTYPE_sharedIndices_MASK)) | (((value)) << lib.PRIMITIVEGROUPTYPE_sharedIndices_SHIFT)

   @property
   def hide(self): return ((((self.impl)) & lib.PRIMITIVEGROUPTYPE_hide_MASK) >> lib.PRIMITIVEGROUPTYPE_hide_SHIFT)
   @hide.setter
   def hide(self, value): self.impl = ((self.impl) & ~(lib.PRIMITIVEGROUPTYPE_hide_MASK)) | (((value)) << lib.PRIMITIVEGROUPTYPE_hide_SHIFT)

class Camera(Instance):
   class_members = [
                      'type',
                      'position',
                      'orientation',
                      'eulerOrientation',
                      'cPosition',
                      'cOrientation',
                      'fov',
                      'zMin',
                      'zMax',
                      'target',
                      'fovDirection',
                      'aspectRatio',
                      'focal',
                   ]

   def init_args(self, args, kwArgs): init_args(Camera, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def type(self): return lib.Camera_get_type(self.impl)
   @type.setter
   def type(self, value):
      lib.Camera_set_type(self.impl, value)

   @property
   def position(self): value = Vector3D(); lib.Camera_get_position(self.impl, ffi.cast("eC_Vector3D *", value.impl)); return value
   @position.setter
   def position(self, value):
      if not isinstance(value, Vector3D): value = Vector3D(value)
      lib.Camera_set_position(self.impl, ffi.cast("eC_Vector3D *", value.impl))

   @property
   def orientation(self): value = Quaternion(); lib.Camera_get_orientation(self.impl, ffi.cast("eC_Quaternion *", value.impl)); return value
   @orientation.setter
   def orientation(self, value):
      if not isinstance(value, Quaternion): value = Quaternion(value)
      lib.Camera_set_orientation(self.impl, ffi.cast("eC_Quaternion *", value.impl))

   @property
   def eulerOrientation(self): value = Euler(); lib.Camera_get_eulerOrientation(self.impl, ffi.cast("eC_Euler *", value.impl)); return value
   @eulerOrientation.setter
   def eulerOrientation(self, value):
      if not isinstance(value, Euler): value = Euler(value)
      lib.Camera_set_eulerOrientation(self.impl, ffi.cast("eC_Euler *", value.impl))

   @property
   def cPosition(self): value = Vector3D(); lib.Camera_get_cPosition(self.impl, ffi.cast("eC_Vector3D *", value.impl)); return value

   @property
   def cOrientation(self): value = Quaternion(); lib.Camera_get_cOrientation(self.impl, ffi.cast("eC_Quaternion *", value.impl)); return value

   @property
   def fov(self): return Degrees(impl = lib.Camera_get_fov(self.impl))
   @fov.setter
   def fov(self, value):
      if not isinstance(value, Angle): value = Degrees(value)
      lib.Camera_set_fov(self.impl, value.impl)

   @property
   def zMin(self): return lib.Camera_get_zMin(self.impl)
   @zMin.setter
   def zMin(self, value):
      lib.Camera_set_zMin(self.impl, value)

   @property
   def zMax(self): return lib.Camera_get_zMax(self.impl)
   @zMax.setter
   def zMax(self, value):
      lib.Camera_set_zMax(self.impl, value)

   @property
   def target(self): return Object(impl = lib.Camera_get_target(self.impl))
   @target.setter
   def target(self, value):
      if not isinstance(value, Object): value = Object(value)
      lib.Camera_set_target(self.impl, value.impl)

   @property
   def fovDirection(self): return lib.Camera_get_fovDirection(self.impl)
   @fovDirection.setter
   def fovDirection(self, value):
      lib.Camera_set_fovDirection(self.impl, value)

   @property
   def aspectRatio(self): return lib.Camera_get_aspectRatio(self.impl)
   @aspectRatio.setter
   def aspectRatio(self, value):
      lib.Camera_set_aspectRatio(self.impl, value)

   @property
   def focal(self): value = Size(); lib.Camera_get_focal(self.impl, ffi.cast("eC_Size *", value.impl)); return value
   @focal.setter
   def focal(self, value):
      if not isinstance(value, Size): value = Size(value)
      lib.Camera_set_focal(self.impl, ffi.cast("eC_Size *", value.impl))

   def adjustAngle(self, angle = None):
      if angle is not None and not isinstance(angle, Quaternion): angle = Quaternion(angle)
      angle = ffi.NULL if angle is None else angle.impl
      lib.Camera_adjustAngle(self.impl, ffi.cast("eC_Quaternion *", angle))

   def adjustPosition(self, position = None):
      if position is not None and not isinstance(position, Vector3D): position = Vector3D(position)
      position = ffi.NULL if position is None else position.impl
      lib.Camera_adjustPosition(self.impl, ffi.cast("eC_Vector3D *", position))

   def move(self, direction = None):
      if direction is not None and not isinstance(direction, Vector3D): direction = Vector3D(direction)
      direction = ffi.NULL if direction is None else direction.impl
      lib.Camera_move(self.impl, ffi.cast("eC_Vector3D *", direction))

   def pointsVisible(self, points, numPoints, threshold):
      return lib.Camera_pointsVisible(self.impl, points, numPoints, threshold)

   def project(self, vector = None, point = None):
      if vector is not None and not isinstance(vector, Vector3D): vector = Vector3D(vector)
      vector = ffi.NULL if vector is None else vector.impl
      if point is not None and not isinstance(point, Vector3D): point = Vector3D(point)
      point = ffi.NULL if point is None else point.impl
      return lib.Camera_project(self.impl, ffi.cast("eC_Vector3D *", vector), ffi.cast("eC_Vector3D *", point))

   def projectSize(self, vector = None, point = None):
      if vector is not None and not isinstance(vector, Vector3D): vector = Vector3D(vector)
      vector = ffi.NULL if vector is None else vector.impl
      if point is not None and not isinstance(point, Point): point = Point(point)
      point = ffi.NULL if point is None else point.impl
      return lib.Camera_projectSize(self.impl, ffi.cast("eC_Vector3D *", vector), ffi.cast("eC_Point *", point))

   def rotatePitch(self, amount, min, max):
      if amount is not None and not isinstance(amount, Angle): amount = Degrees(amount)
      if amount is None: amount = ffi.NULL
      if min is not None and not isinstance(min, Angle): min = Degrees(min)
      if min is None: min = ffi.NULL
      if max is not None and not isinstance(max, Angle): max = Degrees(max)
      if max is None: max = ffi.NULL
      lib.Camera_rotatePitch(self.impl, amount.impl, min.impl, max.impl)

   def rotateRoll(self, amount, min, max):
      if amount is not None and not isinstance(amount, Angle): amount = Degrees(amount)
      if amount is None: amount = ffi.NULL
      if min is not None and not isinstance(min, Angle): min = Degrees(min)
      if min is None: min = ffi.NULL
      if max is not None and not isinstance(max, Angle): max = Degrees(max)
      if max is None: max = ffi.NULL
      lib.Camera_rotateRoll(self.impl, amount.impl, min.impl, max.impl)

   def rotateYaw(self, amount, min, max):
      if amount is not None and not isinstance(amount, Angle): amount = Degrees(amount)
      if amount is None: amount = ffi.NULL
      if min is not None and not isinstance(min, Angle): min = Degrees(min)
      if min is None: min = ffi.NULL
      if max is not None and not isinstance(max, Angle): max = Degrees(max)
      if max is None: max = ffi.NULL
      lib.Camera_rotateYaw(self.impl, amount.impl, min.impl, max.impl)

   def setup(self, width, height, origin = None):
      if origin is not None and not isinstance(origin, Point): origin = Point(origin)
      origin = ffi.NULL if origin is None else origin.impl
      lib.Camera_setup(self.impl, width, height, ffi.cast("eC_Point *", origin))

   def setupVR(self, width, height, prjMatrix = None):
      if prjMatrix is not None and not isinstance(prjMatrix, Matrix): prjMatrix = Matrix(prjMatrix)
      prjMatrix = ffi.NULL if prjMatrix is None else prjMatrix.impl
      lib.Camera_setupVR(self.impl, width, height, ffi.cast("eC_Matrix *", prjMatrix))

   def slerp(self, amount):
      lib.Camera_slerp(self.impl, amount)

   def sphereVisible(self, center, radius):
      if center is not None and not isinstance(center, Vector3D): center = Vector3D(center)
      center = ffi.NULL if center is None else center.impl
      return lib.Camera_sphereVisible(self.impl, ffi.cast("eC_Vector3D *", center), radius)

   def transformMatrix(self, dest = None, src = None):
      if dest is not None and not isinstance(dest, Matrix): dest = Matrix(dest)
      dest = ffi.NULL if dest is None else dest.impl
      if src is not None and not isinstance(src, Matrix): src = Matrix(src)
      src = ffi.NULL if src is None else src.impl
      lib.Camera_transformMatrix(self.impl, ffi.cast("eC_Matrix *", dest), ffi.cast("eC_Matrix *", src))

   def transformNormal(self, dest = None, src = None):
      if dest is not None and not isinstance(dest, Vector3D): dest = Vector3D(dest)
      dest = ffi.NULL if dest is None else dest.impl
      if src is not None and not isinstance(src, Vector3D): src = Vector3D(src)
      src = ffi.NULL if src is None else src.impl
      lib.Camera_transformNormal(self.impl, ffi.cast("eC_Vector3D *", dest), ffi.cast("eC_Vector3D *", src))

   def transformPoint(self, dest = None, src = None):
      if dest is not None and not isinstance(dest, Vector3D): dest = Vector3D(dest)
      dest = ffi.NULL if dest is None else dest.impl
      if src is not None and not isinstance(src, Vector3D): src = Vector3D(src)
      src = ffi.NULL if src is None else src.impl
      lib.Camera_transformPoint(self.impl, ffi.cast("eC_Vector3D *", dest), ffi.cast("eC_Vector3D *", src))

   def unproject(self, point = None, vector = None):
      if point is not None and not isinstance(point, Vector3D): point = Vector3D(point)
      point = ffi.NULL if point is None else point.impl
      if vector is not None and not isinstance(vector, Vector3D): vector = Vector3D(vector)
      vector = ffi.NULL if vector is None else vector.impl
      lib.Camera_unproject(self.impl, ffi.cast("eC_Vector3D *", point), ffi.cast("eC_Vector3D *", vector))

   def untransform(self, src = None, result = None):
      if src is not None and not isinstance(src, Vector3D): src = Vector3D(src)
      src = ffi.NULL if src is None else src.impl
      if result is not None and not isinstance(result, Vector3D): result = Vector3D(result)
      result = ffi.NULL if result is None else result.impl
      lib.Camera_untransform(self.impl, ffi.cast("eC_Vector3D *", src), ffi.cast("eC_Vector3D *", result))

   def update(self):
      return lib.Camera_update(self.impl)

   def setCPosition(self, value = None):
      if value is not None and not isinstance(value, Vector3D): value = Vector3D(value)
      value = ffi.NULL if value is None else value.impl
      lib.Camera_setCPosition(self.impl, ffi.cast("eC_Vector3D *", value))

   def setViewMatrix(self, value = None):
      if value is not None and not isinstance(value, Matrix): value = Matrix(value)
      value = ffi.NULL if value is None else value.impl
      lib.Camera_setViewMatrix(self.impl, ffi.cast("eC_Matrix *", value))

class CameraType:
   fixed              = lib.CameraType_fixed
   fixedQuaternion    = lib.CameraType_fixedQuaternion
   attached           = lib.CameraType_attached
   attachedQuaternion = lib.CameraType_attachedQuaternion
   lookAt             = lib.CameraType_lookAt
   lookAtObject       = lib.CameraType_lookAtObject

class ClippingPlane:
   left   = lib.ClippingPlane_left
   right  = lib.ClippingPlane_right
   top    = lib.ClippingPlane_top
   bottom = lib.ClippingPlane_bottom
   near   = lib.ClippingPlane_near
   far    = lib.ClippingPlane_far

class EulerRotationOrder:
   xyz = lib.EulerRotationOrder_xyz
   xzy = lib.EulerRotationOrder_xzy
   yxz = lib.EulerRotationOrder_yxz
   yzx = lib.EulerRotationOrder_yzx
   zxy = lib.EulerRotationOrder_zxy
   zyx = lib.EulerRotationOrder_zyx

class FovDirection:
   widest     = lib.FovDirection_widest
   horizontal = lib.FovDirection_horizontal
   vertical   = lib.FovDirection_vertical

class FrameKey(Struct):
   def __init__(self, frame = None, tension = None, continuity = None, bias = None, easeFrom = None, easeTo = None, position = None, orientation = None, scaling = None, roll = None, fov = None, color = None, hotSpot = None, fallOff = None, weight = None, hide = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_FrameKey *", impl)
      else:
         if position is not None:
            if not isinstance(position, Vector3Df): position = Vector3Df(position)
         if orientation is not None:
            if not isinstance(orientation, Quaternion): orientation = Quaternion(orientation)
         if scaling is not None:
            if not isinstance(scaling, Vector3Df): scaling = Vector3Df(scaling)
         if color is not None:
            if not isinstance(color, ColorRGB): color = ColorRGB(color)
         __members = { }
         if frame is not None:       __members['frame']       = frame
         if tension is not None:     __members['tension']     = tension
         if continuity is not None:  __members['continuity']  = continuity
         if bias is not None:        __members['bias']        = bias
         if easeFrom is not None:    __members['easeFrom']    = easeFrom
         if easeTo is not None:      __members['easeTo']      = easeTo
         if position is not None:    __members['position']    = position.impl[0]
         if orientation is not None: __members['orientation'] = orientation.impl[0]
         if scaling is not None:     __members['scaling']     = scaling.impl[0]
         if roll is not None:        __members['roll']        = roll
         if fov is not None:         __members['fov']         = fov
         if color is not None:       __members['color']       = color.impl[0]
         if hotSpot is not None:     __members['hotSpot']     = hotSpot
         if fallOff is not None:     __members['fallOff']     = fallOff
         if weight is not None:      __members['weight']      = weight
         if hide is not None:        __members['hide']        = hide
         self.impl = ffi.new("eC_FrameKey *", __members)

   @property
   def frame(self): return self.impl.frame
   @frame.setter
   def frame(self, value): self.impl.frame = value

   @property
   def tension(self): return self.impl.tension
   @tension.setter
   def tension(self, value): self.impl.tension = value

   @property
   def continuity(self): return self.impl.continuity
   @continuity.setter
   def continuity(self, value): self.impl.continuity = value

   @property
   def bias(self): return self.impl.bias
   @bias.setter
   def bias(self, value): self.impl.bias = value

   @property
   def easeFrom(self): return self.impl.easeFrom
   @easeFrom.setter
   def easeFrom(self, value): self.impl.easeFrom = value

   @property
   def easeTo(self): return self.impl.easeTo
   @easeTo.setter
   def easeTo(self, value): self.impl.easeTo = value

   @property
   def position(self): return Vector3Df(impl = self.impl.position)
   @position.setter
   def position(self, value):
      if not isinstance(value, Vector3Df): value = Vector3Df(value)
      self.impl.position = value.impl[0]

   @property
   def orientation(self): return Quaternion(impl = self.impl.orientation)
   @orientation.setter
   def orientation(self, value):
      if not isinstance(value, Quaternion): value = Quaternion(value)
      self.impl.orientation = value.impl[0]

   @property
   def scaling(self): return Vector3Df(impl = self.impl.scaling)
   @scaling.setter
   def scaling(self, value):
      if not isinstance(value, Vector3Df): value = Vector3Df(value)
      self.impl.scaling = value.impl[0]

   @property
   def roll(self): return self.impl.roll
   @roll.setter
   def roll(self, value): self.impl.roll = value

   @property
   def fov(self): return self.impl.fov
   @fov.setter
   def fov(self, value): self.impl.fov = value

   @property
   def color(self): return ColorRGB(impl = self.impl.color)
   @color.setter
   def color(self, value):
      if not isinstance(value, ColorRGB): value = ColorRGB(value)
      self.impl.color = value.impl[0]

   @property
   def hotSpot(self): return self.impl.hotSpot
   @hotSpot.setter
   def hotSpot(self, value): self.impl.hotSpot = value

   @property
   def fallOff(self): return self.impl.fallOff
   @fallOff.setter
   def fallOff(self, value): self.impl.fallOff = value

   @property
   def weight(self): return self.impl.weight
   @weight.setter
   def weight(self, value): self.impl.weight = value

   @property
   def hide(self): return self.impl.hide
   @hide.setter
   def hide(self, value): self.impl.hide = value

class FrameTrack:
   def __init__(self, type = None, numKeys = None, keys = None, morphIndex = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_FrameTrack *", lib.Instance_new(lib.class_FrameTrack))
         if isinstance(type, tuple):
            __tuple = type
            type = 0
            if len(__tuple) > 0: type       = __tuple[0]
            if len(__tuple) > 1: numKeys    = __tuple[1]
            if len(__tuple) > 2: keys       = __tuple[2]
            if len(__tuple) > 3: morphIndex = __tuple[3]
         if type is not None:       self.type       = type
         if numKeys is not None:    self.numKeys    = numKeys
         if keys is not None:       self.keys       = keys
         if morphIndex is not None: self.morphIndex = morphIndex

   @property
   def type(self): return FrameTrackBits(impl = self.impl.type)
   @type.setter
   def type(self, value):
      if not isinstance(value, FrameTrackBits): value = FrameTrackBits(value)
      self.impl.type = value.impl

   @property
   def numKeys(self): return self.impl.numKeys
   @numKeys.setter
   def numKeys(self, value): self.impl.numKeys = value

   @property
   def keys(self): return self.impl.keys
   @keys.setter
   def keys(self, value): self.impl.keys = value

   @property
   def morphIndex(self): return self.impl.morphIndex
   @morphIndex.setter
   def morphIndex(self, value): self.impl.morphIndex = value

class FrameTrackBits(pyBaseClass):
   def __init__(self, type = 0, loop = False, rotationOrder = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(type, FrameTrackBits):
         self.impl = type.impl
      else:
         if isinstance(type, tuple):
            __tuple = type
            type = 0
            if len(__tuple) > 0: type = __tuple[0]
            if len(__tuple) > 1: loop = __tuple[1]
            if len(__tuple) > 2: rotationOrder = __tuple[2]
         self.impl = (
            (type          << lib.FRAMETRACKBITS_type_SHIFT)          |
            (loop          << lib.FRAMETRACKBITS_loop_SHIFT)          |
            (rotationOrder << lib.FRAMETRACKBITS_rotationOrder_SHIFT) )

   @property
   def type(self): return ((((self.impl)) & lib.FRAMETRACKBITS_type_MASK) >> lib.FRAMETRACKBITS_type_SHIFT)
   @type.setter
   def type(self, value): self.impl = ((self.impl) & ~(lib.FRAMETRACKBITS_type_MASK)) | (((value)) << lib.FRAMETRACKBITS_type_SHIFT)

   @property
   def loop(self): return ((((self.impl)) & lib.FRAMETRACKBITS_loop_MASK) >> lib.FRAMETRACKBITS_loop_SHIFT)
   @loop.setter
   def loop(self, value): self.impl = ((self.impl) & ~(lib.FRAMETRACKBITS_loop_MASK)) | (((value)) << lib.FRAMETRACKBITS_loop_SHIFT)

   @property
   def rotationOrder(self): return ((((self.impl)) & lib.FRAMETRACKBITS_rotationOrder_MASK) >> lib.FRAMETRACKBITS_rotationOrder_SHIFT)
   @rotationOrder.setter
   def rotationOrder(self, value): self.impl = ((self.impl) & ~(lib.FRAMETRACKBITS_rotationOrder_MASK)) | (((value)) << lib.FRAMETRACKBITS_rotationOrder_SHIFT)

class FrameTrackType:
   position    = lib.FrameTrackType_position
   rotation    = lib.FrameTrackType_rotation
   scaling     = lib.FrameTrackType_scaling
   fov         = lib.FrameTrackType_fov
   roll        = lib.FrameTrackType_roll
   colorChange = lib.FrameTrackType_colorChange
   morph       = lib.FrameTrackType_morph
   hotSpot     = lib.FrameTrackType_hotSpot
   fallOff     = lib.FrameTrackType_fallOff
   hide        = lib.FrameTrackType_hide
   rYaw        = lib.FrameTrackType_rYaw
   rPitch      = lib.FrameTrackType_rPitch
   rRoll       = lib.FrameTrackType_rRoll

class FrustumPlacement:
   outside      = lib.FrustumPlacement_outside
   inside       = lib.FrustumPlacement_inside
   intersecting = lib.FrustumPlacement_intersecting

class Line(Struct):
   def __init__(self, p0 = None, delta = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Line *", impl)
      else:
         if isinstance(p0, tuple):
            __tuple = p0
            p0 = None
            if len(__tuple) > 0: p0    = __tuple[0]
            if len(__tuple) > 1: delta = __tuple[1]
         if p0 is not None:
            if not isinstance(p0, Vector3D): p0 = Vector3D(p0)
            p0 = p0.impl[0]
         else:
            p0 = Vector3D()
            p0 = p0.impl[0]
         if delta is not None:
            if not isinstance(delta, Vector3D): delta = Vector3D(delta)
            delta = delta.impl[0]
         else:
            delta = Vector3D()
            delta = delta.impl[0]
         self.impl = ffi.new("eC_Line *", { 'p0' : p0, 'delta' : delta })

   @property
   def p0(self): return Vector3D(impl = self.impl.p0)
   @p0.setter
   def p0(self, value):
      if not isinstance(value, Vector3D): value = Vector3D(value)
      self.impl.p0 = value.impl[0]

   @property
   def delta(self): return Vector3D(impl = self.impl.delta)
   @delta.setter
   def delta(self, value):
      if not isinstance(value, Vector3D): value = Vector3D(value)
      self.impl.delta = value.impl[0]

   def intersectSphere(self, radius):
      t = ffi.new("double *")
      r = lib.Line_intersectSphere(ffi.cast("eC_Line *", self.impl), radius, t)
      return r, t[0]

class Material:
   def __init__(self, prev = None, next = None, name = None, opacity = None, diffuse = None, ambient = None, specular = None, emissive = None, power = None, baseMap = None, bumpMap = None, specularMap = None, reflectMap = None, envMap = None, reflectivity = None, refractiveIndex = None, refractiveIndexContainer = None, flags = None, uScale = None, vScale = None, shader = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_Material *", lib.Instance_new(lib.class_Material))
         if shader is not None:                   self.shader                        = shader
         if prev is not None:                     self.prev                     = prev
         if next is not None:                     self.next                     = next
         if name is not None:                     self.name                     = name
         if opacity is not None:                  self.opacity                  = opacity
         if diffuse is not None:                  self.diffuse                  = diffuse
         if ambient is not None:                  self.ambient                  = ambient
         if specular is not None:                 self.specular                 = specular
         if emissive is not None:                 self.emissive                 = emissive
         if power is not None:                    self.power                    = power
         if baseMap is not None:                  self.baseMap                  = baseMap
         if bumpMap is not None:                  self.bumpMap                  = bumpMap
         if specularMap is not None:              self.specularMap              = specularMap
         if reflectMap is not None:               self.reflectMap               = reflectMap
         if envMap is not None:                   self.envMap                   = envMap
         if reflectivity is not None:             self.reflectivity             = reflectivity
         if refractiveIndex is not None:          self.refractiveIndex          = refractiveIndex
         if refractiveIndexContainer is not None: self.refractiveIndexContainer = refractiveIndexContainer
         if flags is not None:                    self.flags                    = flags
         if uScale is not None:                   self.uScale                   = uScale
         if vScale is not None:                   self.vScale                   = vScale
         if shader is not None:                   self.shader                   = shader

   @property
   def prev(self): return self.impl.prev
   @prev.setter
   def prev(self, value):
      if not isinstance(value, Material): value = Material(value)
      self.impl.prev = value.impl

   @property
   def next(self): return self.impl.next
   @next.setter
   def next(self, value):
      if not isinstance(value, Material): value = Material(value)
      self.impl.next = value.impl

   @property
   def name(self): return self.impl.name
   @name.setter
   def name(self, value):
      if isinstance(value, str): value = ffi.new("char[]", value.encode('u8'))
      elif value is None: value = ffi.NULL
      self.impl.name = value

   @property
   def opacity(self): return self.impl.opacity
   @opacity.setter
   def opacity(self, value): self.impl.opacity = value

   @property
   def diffuse(self): return ColorRGB(impl = self.impl.diffuse)
   @diffuse.setter
   def diffuse(self, value):
      if not isinstance(value, ColorRGB): value = ColorRGB(value)
      self.impl.diffuse = value.impl[0]

   @property
   def ambient(self): return ColorRGB(impl = self.impl.ambient)
   @ambient.setter
   def ambient(self, value):
      if not isinstance(value, ColorRGB): value = ColorRGB(value)
      self.impl.ambient = value.impl[0]

   @property
   def specular(self): return ColorRGB(impl = self.impl.specular)
   @specular.setter
   def specular(self, value):
      if not isinstance(value, ColorRGB): value = ColorRGB(value)
      self.impl.specular = value.impl[0]

   @property
   def emissive(self): return ColorRGB(impl = self.impl.emissive)
   @emissive.setter
   def emissive(self, value):
      if not isinstance(value, ColorRGB): value = ColorRGB(value)
      self.impl.emissive = value.impl[0]

   @property
   def power(self): return self.impl.power
   @power.setter
   def power(self, value): self.impl.power = value

   @property
   def baseMap(self): return pyOrNewObject(Bitmap, self.impl.baseMap)
   @baseMap.setter
   def baseMap(self, value):
      if not isinstance(value, Bitmap): value = Bitmap(value)
      self.impl.baseMap = value.impl

   @property
   def bumpMap(self): return pyOrNewObject(Bitmap, self.impl.bumpMap)
   @bumpMap.setter
   def bumpMap(self, value):
      if not isinstance(value, Bitmap): value = Bitmap(value)
      self.impl.bumpMap = value.impl

   @property
   def specularMap(self): return pyOrNewObject(Bitmap, self.impl.specularMap)
   @specularMap.setter
   def specularMap(self, value):
      if not isinstance(value, Bitmap): value = Bitmap(value)
      self.impl.specularMap = value.impl

   @property
   def reflectMap(self): return pyOrNewObject(Bitmap, self.impl.reflectMap)
   @reflectMap.setter
   def reflectMap(self, value):
      if not isinstance(value, Bitmap): value = Bitmap(value)
      self.impl.reflectMap = value.impl

   @property
   def envMap(self): return pyOrNewObject(CubeMap, self.impl.envMap)
   @envMap.setter
   def envMap(self, value):
      if not isinstance(value, CubeMap): value = CubeMap(value)
      self.impl.envMap = value.impl

   @property
   def reflectivity(self): return self.impl.reflectivity
   @reflectivity.setter
   def reflectivity(self, value): self.impl.reflectivity = value

   @property
   def refractiveIndex(self): return self.impl.refractiveIndex
   @refractiveIndex.setter
   def refractiveIndex(self, value): self.impl.refractiveIndex = value

   @property
   def refractiveIndexContainer(self): return self.impl.refractiveIndexContainer
   @refractiveIndexContainer.setter
   def refractiveIndexContainer(self, value): self.impl.refractiveIndexContainer = value

   @property
   def flags(self): return MaterialFlags(impl = self.impl.flags)
   @flags.setter
   def flags(self, value):
      if not isinstance(value, MaterialFlags): value = MaterialFlags(value)
      self.impl.flags = value.impl

   @property
   def uScale(self): return self.impl.uScale
   @uScale.setter
   def uScale(self, value): self.impl.uScale = value

   @property
   def vScale(self): return self.impl.vScale
   @vScale.setter
   def vScale(self, value): self.impl.vScale = value

   @property
   def shader(self): return pyOrNewObject(Shader, lib.Material_get_shader(ffi.cast("struct eC_Material *", self.impl)))
   @shader.setter
   def shader(self, value):
      if not isinstance(value, Shader): value = Shader(value)
      lib.Material_set_shader(ffi.cast("struct eC_Material *", self.impl), value.impl)

   def free(self):
      lib.Material_free(ffi.cast("struct eC_Material *", self.impl))

class MaterialFlags(pyBaseClass):
   def __init__(self, doubleSided = False, translucent = False, tile = False, noFog = False, singleSideLight = False, separateSpecular = False, cubeMap = False, noLighting = False, partlyTransparent = False, setupTextures = False, update = False, constantColor = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(doubleSided, MaterialFlags):
         self.impl = doubleSided.impl
      else:
         self.impl = (
            (doubleSided       << lib.MATERIALFLAGS_doubleSided_SHIFT)       |
            (translucent       << lib.MATERIALFLAGS_translucent_SHIFT)       |
            (tile              << lib.MATERIALFLAGS_tile_SHIFT)              |
            (noFog             << lib.MATERIALFLAGS_noFog_SHIFT)             |
            (singleSideLight   << lib.MATERIALFLAGS_singleSideLight_SHIFT)   |
            (separateSpecular  << lib.MATERIALFLAGS_separateSpecular_SHIFT)  |
            (cubeMap           << lib.MATERIALFLAGS_cubeMap_SHIFT)           |
            (noLighting        << lib.MATERIALFLAGS_noLighting_SHIFT)        |
            (partlyTransparent << lib.MATERIALFLAGS_partlyTransparent_SHIFT) |
            (setupTextures     << lib.MATERIALFLAGS_setupTextures_SHIFT)     |
            (update            << lib.MATERIALFLAGS_update_SHIFT)            |
            (constantColor     << lib.MATERIALFLAGS_constantColor_SHIFT)     )

   @property
   def doubleSided(self): return ((((self.impl)) & lib.MATERIALFLAGS_doubleSided_MASK) >> lib.MATERIALFLAGS_doubleSided_SHIFT)
   @doubleSided.setter
   def doubleSided(self, value): self.impl = ((self.impl) & ~(lib.MATERIALFLAGS_doubleSided_MASK)) | (((value)) << lib.MATERIALFLAGS_doubleSided_SHIFT)

   @property
   def translucent(self): return ((((self.impl)) & lib.MATERIALFLAGS_translucent_MASK) >> lib.MATERIALFLAGS_translucent_SHIFT)
   @translucent.setter
   def translucent(self, value): self.impl = ((self.impl) & ~(lib.MATERIALFLAGS_translucent_MASK)) | (((value)) << lib.MATERIALFLAGS_translucent_SHIFT)

   @property
   def tile(self): return ((((self.impl)) & lib.MATERIALFLAGS_tile_MASK) >> lib.MATERIALFLAGS_tile_SHIFT)
   @tile.setter
   def tile(self, value): self.impl = ((self.impl) & ~(lib.MATERIALFLAGS_tile_MASK)) | (((value)) << lib.MATERIALFLAGS_tile_SHIFT)

   @property
   def noFog(self): return ((((self.impl)) & lib.MATERIALFLAGS_noFog_MASK) >> lib.MATERIALFLAGS_noFog_SHIFT)
   @noFog.setter
   def noFog(self, value): self.impl = ((self.impl) & ~(lib.MATERIALFLAGS_noFog_MASK)) | (((value)) << lib.MATERIALFLAGS_noFog_SHIFT)

   @property
   def singleSideLight(self): return ((((self.impl)) & lib.MATERIALFLAGS_singleSideLight_MASK) >> lib.MATERIALFLAGS_singleSideLight_SHIFT)
   @singleSideLight.setter
   def singleSideLight(self, value): self.impl = ((self.impl) & ~(lib.MATERIALFLAGS_singleSideLight_MASK)) | (((value)) << lib.MATERIALFLAGS_singleSideLight_SHIFT)

   @property
   def separateSpecular(self): return ((((self.impl)) & lib.MATERIALFLAGS_separateSpecular_MASK) >> lib.MATERIALFLAGS_separateSpecular_SHIFT)
   @separateSpecular.setter
   def separateSpecular(self, value): self.impl = ((self.impl) & ~(lib.MATERIALFLAGS_separateSpecular_MASK)) | (((value)) << lib.MATERIALFLAGS_separateSpecular_SHIFT)

   @property
   def cubeMap(self): return ((((self.impl)) & lib.MATERIALFLAGS_cubeMap_MASK) >> lib.MATERIALFLAGS_cubeMap_SHIFT)
   @cubeMap.setter
   def cubeMap(self, value): self.impl = ((self.impl) & ~(lib.MATERIALFLAGS_cubeMap_MASK)) | (((value)) << lib.MATERIALFLAGS_cubeMap_SHIFT)

   @property
   def noLighting(self): return ((((self.impl)) & lib.MATERIALFLAGS_noLighting_MASK) >> lib.MATERIALFLAGS_noLighting_SHIFT)
   @noLighting.setter
   def noLighting(self, value): self.impl = ((self.impl) & ~(lib.MATERIALFLAGS_noLighting_MASK)) | (((value)) << lib.MATERIALFLAGS_noLighting_SHIFT)

   @property
   def partlyTransparent(self): return ((((self.impl)) & lib.MATERIALFLAGS_partlyTransparent_MASK) >> lib.MATERIALFLAGS_partlyTransparent_SHIFT)
   @partlyTransparent.setter
   def partlyTransparent(self, value): self.impl = ((self.impl) & ~(lib.MATERIALFLAGS_partlyTransparent_MASK)) | (((value)) << lib.MATERIALFLAGS_partlyTransparent_SHIFT)

   @property
   def setupTextures(self): return ((((self.impl)) & lib.MATERIALFLAGS_setupTextures_MASK) >> lib.MATERIALFLAGS_setupTextures_SHIFT)
   @setupTextures.setter
   def setupTextures(self, value): self.impl = ((self.impl) & ~(lib.MATERIALFLAGS_setupTextures_MASK)) | (((value)) << lib.MATERIALFLAGS_setupTextures_SHIFT)

   @property
   def update(self): return ((((self.impl)) & lib.MATERIALFLAGS_update_MASK) >> lib.MATERIALFLAGS_update_SHIFT)
   @update.setter
   def update(self, value): self.impl = ((self.impl) & ~(lib.MATERIALFLAGS_update_MASK)) | (((value)) << lib.MATERIALFLAGS_update_SHIFT)

   @property
   def constantColor(self): return ((((self.impl)) & lib.MATERIALFLAGS_constantColor_MASK) >> lib.MATERIALFLAGS_constantColor_SHIFT)
   @constantColor.setter
   def constantColor(self, value): self.impl = ((self.impl) & ~(lib.MATERIALFLAGS_constantColor_MASK)) | (((value)) << lib.MATERIALFLAGS_constantColor_SHIFT)

class Mesh:
   def __init__(self, texCoords = None, nVertices = None, vertices = None, nIndices = None, meab = None, baseIndex = None, baseVertex = None, indices = None, normals = None, tangents = None, colors = None, lightVectors = None, flags = None, skin = None, dupVerts = None, morphs = None, unmorphedMesh = None, parts = None, groups = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_Mesh *", lib.Instance_new(lib.class_Mesh))
         if texCoords is not None:     self.texCoords          = texCoords
         if nVertices is not None:     self.nVertices          = nVertices
         if vertices is not None:      self.vertices           = vertices
         if nIndices is not None:      self.nIndices           = nIndices
         if meab is not None:          self.meab               = meab
         if baseIndex is not None:     self.baseIndex          = baseIndex
         if baseVertex is not None:    self.baseVertex         = baseVertex
         if indices is not None:       self.indices            = indices
         if normals is not None:       self.normals            = normals
         if tangents is not None:      self.tangents           = tangents
         if colors is not None:        self.colors             = colors
         if lightVectors is not None:  self.lightVectors       = lightVectors
         if flags is not None:         self.flags              = flags
         if skin is not None:          self.skin               = skin
         if dupVerts is not None:      self.dupVerts           = dupVerts
         if morphs is not None:        self.morphs             = morphs
         if unmorphedMesh is not None: self.unmorphedMesh      = unmorphedMesh
         if parts is not None:         self.parts              = parts
         if texCoords is not None:     self.texCoords     = texCoords
         if nVertices is not None:     self.nVertices     = nVertices
         if vertices is not None:      self.vertices      = vertices
         if nIndices is not None:      self.nIndices      = nIndices
         if meab is not None:          self.meab          = meab
         if baseIndex is not None:     self.baseIndex     = baseIndex
         if baseVertex is not None:    self.baseVertex    = baseVertex
         if indices is not None:       self.indices       = indices
         if normals is not None:       self.normals       = normals
         if tangents is not None:      self.tangents      = tangents
         if colors is not None:        self.colors        = colors
         if lightVectors is not None:  self.lightVectors  = lightVectors
         if flags is not None:         self.flags         = flags
         if skin is not None:          self.skin          = skin
         if dupVerts is not None:      self.dupVerts      = dupVerts
         if morphs is not None:        self.morphs        = morphs
         if unmorphedMesh is not None: self.unmorphedMesh = unmorphedMesh
         if parts is not None:         self.parts         = parts

   @property
   def texCoords(self): return lib.Mesh_get_texCoords(ffi.cast("struct eC_Mesh *", self.impl))
   @texCoords.setter
   def texCoords(self, value):
      lib.Mesh_set_texCoords(ffi.cast("struct eC_Mesh *", self.impl), value.impl)

   @property
   def nVertices(self): return lib.Mesh_get_nVertices(ffi.cast("struct eC_Mesh *", self.impl))
   @nVertices.setter
   def nVertices(self, value):
      lib.Mesh_set_nVertices(ffi.cast("struct eC_Mesh *", self.impl), value)

   @property
   def vertices(self): return lib.Mesh_get_vertices(ffi.cast("struct eC_Mesh *", self.impl))
   @vertices.setter
   def vertices(self, value):
      lib.Mesh_set_vertices(ffi.cast("struct eC_Mesh *", self.impl), value.impl)

   @property
   def nIndices(self): return lib.Mesh_get_nIndices(ffi.cast("struct eC_Mesh *", self.impl))
   @nIndices.setter
   def nIndices(self, value):
      lib.Mesh_set_nIndices(ffi.cast("struct eC_Mesh *", self.impl), value)

   @property
   def meab(self): return pyOrNewObject(GLMB, lib.Mesh_get_meab(ffi.cast("struct eC_Mesh *", self.impl)))
   @meab.setter
   def meab(self, value):
      if not isinstance(value, GLMB): value = GLMB(value)
      lib.Mesh_set_meab(ffi.cast("struct eC_Mesh *", self.impl), value.impl)

   @property
   def baseIndex(self): return lib.Mesh_get_baseIndex(ffi.cast("struct eC_Mesh *", self.impl))
   @baseIndex.setter
   def baseIndex(self, value):
      lib.Mesh_set_baseIndex(ffi.cast("struct eC_Mesh *", self.impl), value)

   @property
   def baseVertex(self): return lib.Mesh_get_baseVertex(ffi.cast("struct eC_Mesh *", self.impl))
   @baseVertex.setter
   def baseVertex(self, value):
      lib.Mesh_set_baseVertex(ffi.cast("struct eC_Mesh *", self.impl), value)

   @property
   def indices(self): return lib.Mesh_get_indices(ffi.cast("struct eC_Mesh *", self.impl))
   @indices.setter
   def indices(self, value):
      lib.Mesh_set_indices(ffi.cast("struct eC_Mesh *", self.impl), value)

   @property
   def normals(self): return lib.Mesh_get_normals(ffi.cast("struct eC_Mesh *", self.impl))
   @normals.setter
   def normals(self, value):
      lib.Mesh_set_normals(ffi.cast("struct eC_Mesh *", self.impl), value.impl)

   @property
   def tangents(self): return lib.Mesh_get_tangents(ffi.cast("struct eC_Mesh *", self.impl))
   @tangents.setter
   def tangents(self, value):
      lib.Mesh_set_tangents(ffi.cast("struct eC_Mesh *", self.impl), value.impl)

   @property
   def colors(self): return lib.Mesh_get_colors(ffi.cast("struct eC_Mesh *", self.impl))
   @colors.setter
   def colors(self, value):
      lib.Mesh_set_colors(ffi.cast("struct eC_Mesh *", self.impl), value.impl)

   @property
   def lightVectors(self): return lib.Mesh_get_lightVectors(ffi.cast("struct eC_Mesh *", self.impl))
   @lightVectors.setter
   def lightVectors(self, value):
      lib.Mesh_set_lightVectors(ffi.cast("struct eC_Mesh *", self.impl), value.impl)

   @property
   def groups(self): value = OldList(); lib.Mesh_get_groups(ffi.cast("struct eC_Mesh *", self.impl), ffi.cast("eC_OldList *", value.impl)); return value

   @property
   def flags(self): return MeshFeatures(impl = lib.Mesh_get_flags(ffi.cast("struct eC_Mesh *", self.impl)))
   @flags.setter
   def flags(self, value):
      if not isinstance(value, MeshFeatures): value = MeshFeatures(value)
      lib.Mesh_set_flags(ffi.cast("struct eC_Mesh *", self.impl), value.impl)

   @property
   def skin(self): return pyOrNewObject(MeshSkin, lib.Mesh_get_skin(ffi.cast("struct eC_Mesh *", self.impl)))
   @skin.setter
   def skin(self, value):
      if not isinstance(value, MeshSkin): value = MeshSkin(value)
      lib.Mesh_set_skin(ffi.cast("struct eC_Mesh *", self.impl), value.impl)

   @property
   def dupVerts(self): return pyOrNewObject(Array, lib.Mesh_get_dupVerts(ffi.cast("struct eC_Mesh *", self.impl)))
   @dupVerts.setter
   def dupVerts(self, value):
      lib.Mesh_set_dupVerts(ffi.cast("struct eC_Mesh *", self.impl), value.impl)

   @property
   def morphs(self): return pyOrNewObject(Array, lib.Mesh_get_morphs(ffi.cast("struct eC_Mesh *", self.impl)))
   @morphs.setter
   def morphs(self, value):
      lib.Mesh_set_morphs(ffi.cast("struct eC_Mesh *", self.impl), value.impl)

   @property
   def unmorphedMesh(self): return Mesh(impl = lib.Mesh_get_unmorphedMesh(ffi.cast("struct eC_Mesh *", self.impl)))
   @unmorphedMesh.setter
   def unmorphedMesh(self, value):
      if not isinstance(value, Mesh): value = Mesh(value)
      lib.Mesh_set_unmorphedMesh(ffi.cast("struct eC_Mesh *", self.impl), value.impl)

   @property
   def translucentPrimitives(self): return lib.Mesh_get_translucentPrimitives(ffi.cast("struct eC_Mesh *", self.impl))

   @property
   def nTranslucentPrimitives(self): return lib.Mesh_get_nTranslucentPrimitives(ffi.cast("struct eC_Mesh *", self.impl))

   @property
   def parts(self): return pyOrNewObject(Array, lib.Mesh_get_parts(ffi.cast("struct eC_Mesh *", self.impl)))
   @parts.setter
   def parts(self, value):
      lib.Mesh_set_parts(ffi.cast("struct eC_Mesh *", self.impl), value.impl)

   def addPrimitiveGroup(self, flags, nIndices):
      if flags is not None and not isinstance(flags, PrimitiveGroupType): flags = PrimitiveGroupType(flags)
      if flags is None: flags = ffi.NULL
      return lib.Mesh_addPrimitiveGroup(ffi.cast("struct eC_Mesh *", self.impl), flags, nIndices)

   def allocate(self, what, nVertices, displaySystem = None):
      if what is not None and not isinstance(what, MeshFeatures): what = MeshFeatures(what)
      if what is None: what = ffi.NULL
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Mesh_allocate(ffi.cast("struct eC_Mesh *", self.impl), what, nVertices, displaySystem)

   def allocatePrimitive(self, primitive, flags, nIndices):
      if primitive is not None and not isinstance(primitive, PrimitiveSingle): primitive = PrimitiveSingle(primitive)
      primitive = ffi.NULL if primitive is None else primitive.impl
      if flags is not None and not isinstance(flags, PrimitiveGroupType): flags = PrimitiveGroupType(flags)
      if flags is None: flags = ffi.NULL
      return lib.Mesh_allocatePrimitive(ffi.cast("struct eC_Mesh *", self.impl), ffi.cast("eC_PrimitiveSingle *", primitive), flags, nIndices)

   def applyMaterial(self, material = None):
      if material is not None and not isinstance(material, Material): material = Material(material)
      material = ffi.NULL if material is None else material.impl
      lib.Mesh_applyMaterial(ffi.cast("struct eC_Mesh *", self.impl), ffi.cast("struct eC_Material *", material))

   def applyMorphs(self, recomputeNormals):
      lib.Mesh_applyMorphs(ffi.cast("struct eC_Mesh *", self.impl), recomputeNormals)

   def applySkin(self):
      lib.Mesh_applySkin(ffi.cast("struct eC_Mesh *", self.impl))

   def applyTranslucency(self, object = None):
      if object is not None and not isinstance(object, Object): object = Object(object)
      object = ffi.NULL if object is None else object.impl
      return lib.Mesh_applyTranslucency(ffi.cast("struct eC_Mesh *", self.impl), ffi.cast("struct eC_Object *", object))

   def combineMorphs(self, combined = None):
      lib.Mesh_combineMorphs(ffi.cast("struct eC_Mesh *", self.impl), Array.impl)

   def computeNormals(self):
      lib.Mesh_computeNormals(ffi.cast("struct eC_Mesh *", self.impl))

   def computeNormals2(self, computeNormals, computeTangents):
      lib.Mesh_computeNormals2(ffi.cast("struct eC_Mesh *", self.impl), computeNormals, computeTangents)

   def computeNormals3(self, computeNormals, computeTangents, unlock):
      lib.Mesh_computeNormals3(ffi.cast("struct eC_Mesh *", self.impl), computeNormals, computeTangents, unlock)

   def copy(self):
      return lib.Mesh_copy(ffi.cast("struct eC_Mesh *", self.impl))

   def findClosestVertex(self, local = None, actual = None):
      if local is not None and not isinstance(local, Vector3D): local = Vector3D(local)
      local = ffi.NULL if local is None else local.impl
      if actual is not None and not isinstance(actual, Vector3Df): actual = Vector3Df(actual)
      actual = ffi.NULL if actual is None else actual.impl
      return lib.Mesh_findClosestVertex(ffi.cast("struct eC_Mesh *", self.impl), ffi.cast("eC_Vector3D *", local), ffi.cast("eC_Vector3Df *", actual))

   def free(self, what):
      if what is not None and not isinstance(what, MeshFeatures): what = MeshFeatures(what)
      if what is None: what = ffi.NULL
      lib.Mesh_free(ffi.cast("struct eC_Mesh *", self.impl), what)

   def freeCPUVertexAttributes(self, what):
      if what is not None and not isinstance(what, MeshFeatures): what = MeshFeatures(what)
      if what is None: what = ffi.NULL
      lib.Mesh_freeCPUVertexAttributes(ffi.cast("struct eC_Mesh *", self.impl), what)

   def freePrimitive(self, primitive = None):
      if primitive is not None and not isinstance(primitive, PrimitiveSingle): primitive = PrimitiveSingle(primitive)
      primitive = ffi.NULL if primitive is None else primitive.impl
      lib.Mesh_freePrimitive(ffi.cast("struct eC_Mesh *", self.impl), ffi.cast("eC_PrimitiveSingle *", primitive))

   def freePrimitiveGroup(self, group = None):
      if group is not None and not isinstance(group, PrimitiveGroup): group = PrimitiveGroup(group)
      group = ffi.NULL if group is None else group.impl
      lib.Mesh_freePrimitiveGroup(ffi.cast("struct eC_Mesh *", self.impl), ffi.cast("struct eC_PrimitiveGroup *", group))

   def getData(self):
      return lib.Mesh_getData(ffi.cast("struct eC_Mesh *", self.impl))

   def lock(self, flags):
      if flags is not None and not isinstance(flags, MeshFeatures): flags = MeshFeatures(flags)
      if flags is None: flags = ffi.NULL
      return lib.Mesh_lock(ffi.cast("struct eC_Mesh *", self.impl), flags)

   def lockPrimitive(self, primitive = None):
      if primitive is not None and not isinstance(primitive, PrimitiveSingle): primitive = PrimitiveSingle(primitive)
      primitive = ffi.NULL if primitive is None else primitive.impl
      return lib.Mesh_lockPrimitive(ffi.cast("struct eC_Mesh *", self.impl), ffi.cast("eC_PrimitiveSingle *", primitive))

   def lockPrimitiveGroup(self, group = None):
      if group is not None and not isinstance(group, PrimitiveGroup): group = PrimitiveGroup(group)
      group = ffi.NULL if group is None else group.impl
      return lib.Mesh_lockPrimitiveGroup(ffi.cast("struct eC_Mesh *", self.impl), ffi.cast("struct eC_PrimitiveGroup *", group))

   def setData(self, value):
      if hasattr(value, 'impl'): value = value.impl
      if value is None: value = ffi.NULL
      lib.Mesh_setData(ffi.cast("struct eC_Mesh *", self.impl), value)

   def unapplySkin(self):
      lib.Mesh_unapplySkin(ffi.cast("struct eC_Mesh *", self.impl))

   def unapplyTranslucency(self, object = None):
      if object is not None and not isinstance(object, Object): object = Object(object)
      object = ffi.NULL if object is None else object.impl
      return lib.Mesh_unapplyTranslucency(ffi.cast("struct eC_Mesh *", self.impl), ffi.cast("struct eC_Object *", object))

   def unlock(self, flags):
      if flags is not None and not isinstance(flags, MeshFeatures): flags = MeshFeatures(flags)
      if flags is None: flags = ffi.NULL
      lib.Mesh_unlock(ffi.cast("struct eC_Mesh *", self.impl), flags)

   def unlockPrimitive(self, primitive = None):
      if primitive is not None and not isinstance(primitive, PrimitiveSingle): primitive = PrimitiveSingle(primitive)
      primitive = ffi.NULL if primitive is None else primitive.impl
      lib.Mesh_unlockPrimitive(ffi.cast("struct eC_Mesh *", self.impl), ffi.cast("eC_PrimitiveSingle *", primitive))

   def unlockPrimitiveGroup(self, group = None):
      if group is not None and not isinstance(group, PrimitiveGroup): group = PrimitiveGroup(group)
      group = ffi.NULL if group is None else group.impl
      lib.Mesh_unlockPrimitiveGroup(ffi.cast("struct eC_Mesh *", self.impl), ffi.cast("struct eC_PrimitiveGroup *", group))

   def upload(self, displaySystem, uploadTextures, mab, meab, nAT, mAT):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      if mab is not None and not isinstance(mab, GLMB): mab = GLMB(mab)
      mab = ffi.NULL if mab is None else mab.impl
      if meab is not None and not isinstance(meab, GLMB): meab = GLMB(meab)
      meab = ffi.NULL if meab is None else meab.impl
      return lib.Mesh_upload(ffi.cast("struct eC_Mesh *", self.impl), displaySystem, uploadTextures, mab, meab, nAT, mAT)

   def uploadPrimitive(self, g, displaySystem, uploadTextures, nAT, mAT, clearData, unlockAndDelete):
      if g is not None and not isinstance(g, PrimitiveSingle): g = PrimitiveSingle(g)
      g = ffi.NULL if g is None else g.impl
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      lib.Mesh_uploadPrimitive(ffi.cast("struct eC_Mesh *", self.impl), ffi.cast("eC_PrimitiveSingle *", g), displaySystem, uploadTextures, nAT, mAT, clearData, unlockAndDelete)

   def uploadTexture(self, bitmap = None, displaySystem = None, at = None):
      if bitmap is not None and not isinstance(bitmap, Bitmap): bitmap = Bitmap(bitmap)
      bitmap = ffi.NULL if bitmap is None else bitmap.impl
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      if at is not None and not isinstance(at, GLArrayTexture): at = GLArrayTexture(at)
      at = ffi.NULL if at is None else at.impl
      lib.Mesh_uploadTexture(ffi.cast("struct eC_Mesh *", self.impl), bitmap, displaySystem, ffi.cast("eC_GLArrayTexture *", at))

   def fixMorphSkin(self):
      lib.Mesh_fixMorphSkin(ffi.cast("struct eC_Mesh *", self.impl))

   def fixSkeletonBones(self, bone, boneIx):
      lib.Mesh_fixSkeletonBones(ffi.cast("struct eC_Mesh *", self.impl), bone, boneIx)

class MeshFeatures(pyBaseClass):
   def __init__(self, vertices = False, normals = False, texCoords1 = False, texCoords2 = False, doubleNormals = False, doubleVertices = False, colors = False, lightVectors = False, tangents = False, intVertices = False, memAllocOnly = False, interleaved = False, ownMEAB = False, bones = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(vertices, MeshFeatures):
         self.impl = vertices.impl
      else:
         self.impl = (
            (vertices       << lib.MESHFEATURES_vertices_SHIFT)       |
            (normals        << lib.MESHFEATURES_normals_SHIFT)        |
            (texCoords1     << lib.MESHFEATURES_texCoords1_SHIFT)     |
            (texCoords2     << lib.MESHFEATURES_texCoords2_SHIFT)     |
            (doubleNormals  << lib.MESHFEATURES_doubleNormals_SHIFT)  |
            (doubleVertices << lib.MESHFEATURES_doubleVertices_SHIFT) |
            (colors         << lib.MESHFEATURES_colors_SHIFT)         |
            (lightVectors   << lib.MESHFEATURES_lightVectors_SHIFT)   |
            (tangents       << lib.MESHFEATURES_tangents_SHIFT)       |
            (intVertices    << lib.MESHFEATURES_intVertices_SHIFT)    |
            (memAllocOnly   << lib.MESHFEATURES_memAllocOnly_SHIFT)   |
            (interleaved    << lib.MESHFEATURES_interleaved_SHIFT)    |
            (ownMEAB        << lib.MESHFEATURES_ownMEAB_SHIFT)        |
            (bones          << lib.MESHFEATURES_bones_SHIFT)          )

   @property
   def vertices(self): return ((((self.impl)) & lib.MESHFEATURES_vertices_MASK) >> lib.MESHFEATURES_vertices_SHIFT)
   @vertices.setter
   def vertices(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_vertices_MASK)) | (((value)) << lib.MESHFEATURES_vertices_SHIFT)

   @property
   def normals(self): return ((((self.impl)) & lib.MESHFEATURES_normals_MASK) >> lib.MESHFEATURES_normals_SHIFT)
   @normals.setter
   def normals(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_normals_MASK)) | (((value)) << lib.MESHFEATURES_normals_SHIFT)

   @property
   def texCoords1(self): return ((((self.impl)) & lib.MESHFEATURES_texCoords1_MASK) >> lib.MESHFEATURES_texCoords1_SHIFT)
   @texCoords1.setter
   def texCoords1(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_texCoords1_MASK)) | (((value)) << lib.MESHFEATURES_texCoords1_SHIFT)

   @property
   def texCoords2(self): return ((((self.impl)) & lib.MESHFEATURES_texCoords2_MASK) >> lib.MESHFEATURES_texCoords2_SHIFT)
   @texCoords2.setter
   def texCoords2(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_texCoords2_MASK)) | (((value)) << lib.MESHFEATURES_texCoords2_SHIFT)

   @property
   def doubleNormals(self): return ((((self.impl)) & lib.MESHFEATURES_doubleNormals_MASK) >> lib.MESHFEATURES_doubleNormals_SHIFT)
   @doubleNormals.setter
   def doubleNormals(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_doubleNormals_MASK)) | (((value)) << lib.MESHFEATURES_doubleNormals_SHIFT)

   @property
   def doubleVertices(self): return ((((self.impl)) & lib.MESHFEATURES_doubleVertices_MASK) >> lib.MESHFEATURES_doubleVertices_SHIFT)
   @doubleVertices.setter
   def doubleVertices(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_doubleVertices_MASK)) | (((value)) << lib.MESHFEATURES_doubleVertices_SHIFT)

   @property
   def colors(self): return ((((self.impl)) & lib.MESHFEATURES_colors_MASK) >> lib.MESHFEATURES_colors_SHIFT)
   @colors.setter
   def colors(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_colors_MASK)) | (((value)) << lib.MESHFEATURES_colors_SHIFT)

   @property
   def lightVectors(self): return ((((self.impl)) & lib.MESHFEATURES_lightVectors_MASK) >> lib.MESHFEATURES_lightVectors_SHIFT)
   @lightVectors.setter
   def lightVectors(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_lightVectors_MASK)) | (((value)) << lib.MESHFEATURES_lightVectors_SHIFT)

   @property
   def tangents(self): return ((((self.impl)) & lib.MESHFEATURES_tangents_MASK) >> lib.MESHFEATURES_tangents_SHIFT)
   @tangents.setter
   def tangents(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_tangents_MASK)) | (((value)) << lib.MESHFEATURES_tangents_SHIFT)

   @property
   def intVertices(self): return ((((self.impl)) & lib.MESHFEATURES_intVertices_MASK) >> lib.MESHFEATURES_intVertices_SHIFT)
   @intVertices.setter
   def intVertices(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_intVertices_MASK)) | (((value)) << lib.MESHFEATURES_intVertices_SHIFT)

   @property
   def memAllocOnly(self): return ((((self.impl)) & lib.MESHFEATURES_memAllocOnly_MASK) >> lib.MESHFEATURES_memAllocOnly_SHIFT)
   @memAllocOnly.setter
   def memAllocOnly(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_memAllocOnly_MASK)) | (((value)) << lib.MESHFEATURES_memAllocOnly_SHIFT)

   @property
   def interleaved(self): return ((((self.impl)) & lib.MESHFEATURES_interleaved_MASK) >> lib.MESHFEATURES_interleaved_SHIFT)
   @interleaved.setter
   def interleaved(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_interleaved_MASK)) | (((value)) << lib.MESHFEATURES_interleaved_SHIFT)

   @property
   def ownMEAB(self): return ((((self.impl)) & lib.MESHFEATURES_ownMEAB_MASK) >> lib.MESHFEATURES_ownMEAB_SHIFT)
   @ownMEAB.setter
   def ownMEAB(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_ownMEAB_MASK)) | (((value)) << lib.MESHFEATURES_ownMEAB_SHIFT)

   @property
   def bones(self): return ((((self.impl)) & lib.MESHFEATURES_bones_MASK) >> lib.MESHFEATURES_bones_SHIFT)
   @bones.setter
   def bones(self, value): self.impl = ((self.impl) & ~(lib.MESHFEATURES_bones_MASK)) | (((value)) << lib.MESHFEATURES_bones_SHIFT)

class MeshMorph(Struct):
   def __init__(self, target = None, weight = 0.0, name = None, updated = False, firstV = 0, lastV = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_MeshMorph *", impl)
      else:
         if isinstance(target, tuple):
            __tuple = target
            target = None
            if len(__tuple) > 0: target  = __tuple[0]
            if len(__tuple) > 1: weight  = __tuple[1]
            if len(__tuple) > 2: name    = __tuple[2]
            if len(__tuple) > 3: updated = __tuple[3]
         if target is not None:
            if not isinstance(target, Mesh): target = Mesh(target)
            target = target.impl
         else:
            target = ffi.NULL
         if name is not None:
            if not isinstance(name, String): name = String(name)
            name = name.impl
         else:
            name = ffi.NULL
         self.impl = ffi.new("eC_MeshMorph *", {
                                'target' : target,
                                'weight' : weight,
                                'name' : name,
                                'updated' : updated,
                                'firstV' : firstV,
                                'lastV' : lastV
                             })

   @property
   def target(self): return self.impl.target
   @target.setter
   def target(self, value):
      if not isinstance(value, Mesh): value = Mesh(value)
      self.impl.target = value.impl

   @property
   def weight(self): return self.impl.weight
   @weight.setter
   def weight(self, value): self.impl.weight = value

   @property
   def name(self): return String(self.impl.name)
   @name.setter
   def name(self, value):
      if isinstance(value, str): value = ffi.new("char[]", value.encode('u8'))
      elif value is None: value = ffi.NULL
      self.impl.name = value

   @property
   def updated(self): return self.impl.updated
   @updated.setter
   def updated(self, value): self.impl.updated = value

   @property
   def firstV(self): return self.impl.firstV
   @firstV.setter
   def firstV(self, value): self.impl.firstV = value

   @property
   def lastV(self): return self.impl.lastV
   @lastV.setter
   def lastV(self, value): self.impl.lastV = value

class MeshPart(Struct):
   def __init__(self, id = 0, start = 0, count = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_MeshPart *", impl)
      else:
         if isinstance(id, tuple):
            __tuple = id
            id = 0
            if len(__tuple) > 0: id    = __tuple[0]
            if len(__tuple) > 1: start = __tuple[1]
            if len(__tuple) > 2: count = __tuple[2]
         self.impl = ffi.new("eC_MeshPart *", { 'id' : id, 'start' : start, 'count' : count })

   @property
   def id(self): return self.impl.id
   @id.setter
   def id(self, value): self.impl.id = value

   @property
   def start(self): return self.impl.start
   @start.setter
   def start(self, value): self.impl.start = value

   @property
   def count(self): return self.impl.count
   @count.setter
   def count(self, value): self.impl.count = value

class MeshSkin(Instance):
   class_members = [
                      'bindShapeMatrix',
                      'bones',
                      'skinVerts',
                      'invShape',
                      'bsIsIdentity',
                   ]

   def init_args(self, args, kwArgs): init_args(MeshSkin, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def bindShapeMatrix(self): return Matrix(impl = IPTR(lib, ffi, self, MeshSkin).bindShapeMatrix)
   @bindShapeMatrix.setter
   def bindShapeMatrix(self, value):
      if not isinstance(value, Matrix): value = Matrix(value)
      IPTR(lib, ffi, self, MeshSkin).bindShapeMatrix = value.impl

   @property
   def bones(self): return pyOrNewObject(Array, IPTR(lib, ffi, self, MeshSkin).bones)
   @bones.setter
   def bones(self, value): IPTR(lib, ffi, self, MeshSkin).bones = value.impl

   @property
   def skinVerts(self): return pyOrNewObject(Array, IPTR(lib, ffi, self, MeshSkin).skinVerts)
   @skinVerts.setter
   def skinVerts(self, value): IPTR(lib, ffi, self, MeshSkin).skinVerts = value.impl

   @property
   def invShape(self): return Matrix(impl = IPTR(lib, ffi, self, MeshSkin).invShape)
   @invShape.setter
   def invShape(self, value):
      if not isinstance(value, Matrix): value = Matrix(value)
      IPTR(lib, ffi, self, MeshSkin).invShape = value.impl

   @property
   def bsIsIdentity(self): return IPTR(lib, ffi, self, MeshSkin).bsIsIdentity
   @bsIsIdentity.setter
   def bsIsIdentity(self, value): IPTR(lib, ffi, self, MeshSkin).bsIsIdentity = value

class Object:
   def __init__(self, transform = None, eulerOrientation = None, material = None, tag = None, frame = None, startFrame = None, endFrame = None, mesh = None, name = None, cameraTarget = None, flags = None, light = None, rotationOrder = None, displaySystem = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_Object *", lib.Instance_new(lib.class_Object))
         if transform is not None:        self.transform             = transform
         if eulerOrientation is not None: self.eulerOrientation      = eulerOrientation
         if material is not None:         self.material              = material
         if tag is not None:              self.tag                   = tag
         if frame is not None:            self.frame                 = frame
         if startFrame is not None:       self.startFrame            = startFrame
         if endFrame is not None:         self.endFrame              = endFrame
         if mesh is not None:             self.mesh                  = mesh
         if name is not None:             self.name                  = name
         if cameraTarget is not None:     self.cameraTarget          = cameraTarget
         if flags is not None:            self.flags                 = flags
         if light is not None:            self.light                 = light
         if rotationOrder is not None:    self.rotationOrder         = rotationOrder
         if displaySystem is not None:    self.displaySystem         = displaySystem
         if transform is not None:        self.transform        = transform
         if eulerOrientation is not None: self.eulerOrientation = eulerOrientation
         if material is not None:         self.material         = material
         if tag is not None:              self.tag              = tag
         if frame is not None:            self.frame            = frame
         if startFrame is not None:       self.startFrame       = startFrame
         if endFrame is not None:         self.endFrame         = endFrame
         if mesh is not None:             self.mesh             = mesh
         if name is not None:             self.name             = name
         if cameraTarget is not None:     self.cameraTarget     = cameraTarget
         if flags is not None:            self.flags            = flags
         if light is not None:            self.light            = light
         if rotationOrder is not None:    self.rotationOrder    = rotationOrder
         if displaySystem is not None:    self.displaySystem    = displaySystem

   @property
   def transform(self): value = Transform(); lib.Object_get_transform(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Transform *", value.impl)); return value
   @transform.setter
   def transform(self, value):
      if not isinstance(value, Transform): value = Transform(value)
      lib.Object_set_transform(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Transform *", value.impl))

   @property
   def eulerOrientation(self): value = Euler(); lib.Object_get_eulerOrientation(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Euler *", value.impl)); return value
   @eulerOrientation.setter
   def eulerOrientation(self, value):
      if not isinstance(value, Euler): value = Euler(value)
      lib.Object_set_eulerOrientation(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Euler *", value.impl))

   @property
   def material(self): return Material(impl = lib.Object_get_material(ffi.cast("struct eC_Object *", self.impl)))
   @material.setter
   def material(self, value):
      if not isinstance(value, Material): value = Material(value)
      lib.Object_set_material(ffi.cast("struct eC_Object *", self.impl), value.impl)

   @property
   def max(self): value = Vector3Df(); lib.Object_get_max(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Vector3Df *", value.impl)); return value

   @property
   def min(self): value = Vector3Df(); lib.Object_get_min(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Vector3Df *", value.impl)); return value

   @property
   def center(self): value = Vector3Df(); lib.Object_get_center(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Vector3Df *", value.impl)); return value

   @property
   def radius(self): return lib.Object_get_radius(ffi.cast("struct eC_Object *", self.impl))

   @property
   def wmax(self): value = Vector3D(); lib.Object_get_wmax(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Vector3D *", value.impl)); return value

   @property
   def wmin(self): value = Vector3D(); lib.Object_get_wmin(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Vector3D *", value.impl)); return value

   @property
   def wcenter(self): value = Vector3D(); lib.Object_get_wcenter(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Vector3D *", value.impl)); return value

   @property
   def wradius(self): return lib.Object_get_wradius(ffi.cast("struct eC_Object *", self.impl))

   @property
   def tag(self): return lib.Object_get_tag(ffi.cast("struct eC_Object *", self.impl))
   @tag.setter
   def tag(self, value):
      lib.Object_set_tag(ffi.cast("struct eC_Object *", self.impl), value)

   @property
   def frame(self): return lib.Object_get_frame(ffi.cast("struct eC_Object *", self.impl))
   @frame.setter
   def frame(self, value):
      lib.Object_set_frame(ffi.cast("struct eC_Object *", self.impl), value)

   @property
   def startFrame(self): return lib.Object_get_startFrame(ffi.cast("struct eC_Object *", self.impl))
   @startFrame.setter
   def startFrame(self, value):
      lib.Object_set_startFrame(ffi.cast("struct eC_Object *", self.impl), value)

   @property
   def endFrame(self): return lib.Object_get_endFrame(ffi.cast("struct eC_Object *", self.impl))
   @endFrame.setter
   def endFrame(self, value):
      lib.Object_set_endFrame(ffi.cast("struct eC_Object *", self.impl), value)

   @property
   def mesh(self): return Mesh(impl = lib.Object_get_mesh(ffi.cast("struct eC_Object *", self.impl)))
   @mesh.setter
   def mesh(self, value):
      if not isinstance(value, Mesh): value = Mesh(value)
      lib.Object_set_mesh(ffi.cast("struct eC_Object *", self.impl), value.impl)

   @property
   def camera(self): return pyOrNewObject(Camera, lib.Object_get_camera(ffi.cast("struct eC_Object *", self.impl)))

   @property
   def firstChild(self): return Object(impl = lib.Object_get_firstChild(ffi.cast("struct eC_Object *", self.impl)))

   @property
   def next(self): return Object(impl = lib.Object_get_next(ffi.cast("struct eC_Object *", self.impl)))

   @property
   def name(self): value = lib.Object_get_name(ffi.cast("struct eC_Object *", self.impl)); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @name.setter
   def name(self, value):
      lib.Object_set_name(ffi.cast("struct eC_Object *", self.impl), value.encode('u8'))

   @property
   def matrix(self): value = Matrix(); lib.Object_get_matrix(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Matrix *", value.impl)); return value

   @property
   def cameraTarget(self): return Object(impl = lib.Object_get_cameraTarget(ffi.cast("struct eC_Object *", self.impl)))
   @cameraTarget.setter
   def cameraTarget(self, value):
      if not isinstance(value, Object): value = Object(value)
      lib.Object_set_cameraTarget(ffi.cast("struct eC_Object *", self.impl), value.impl)

   @property
   def tracks(self): return lib.Object_get_tracks(ffi.cast("struct eC_Object *", self.impl))

   @property
   def flags(self): return ObjectFlags(impl = lib.Object_get_flags(ffi.cast("struct eC_Object *", self.impl)))
   @flags.setter
   def flags(self, value):
      if not isinstance(value, ObjectFlags): value = ObjectFlags(value)
      lib.Object_set_flags(ffi.cast("struct eC_Object *", self.impl), value.impl)

   @property
   def parent(self): return Object(impl = lib.Object_get_parent(ffi.cast("struct eC_Object *", self.impl)))

   @property
   def numChildren(self): return lib.Object_get_numChildren(ffi.cast("struct eC_Object *", self.impl))

   @property
   def localMatrixPtr(self): return lib.Object_get_localMatrixPtr(ffi.cast("struct eC_Object *", self.impl))

   @property
   def matrixPtr(self): return lib.Object_get_matrixPtr(ffi.cast("struct eC_Object *", self.impl))

   @property
   def light(self): value = Light(); lib.Object_get_light(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Light *", value.impl)); return value
   @light.setter
   def light(self, value):
      if not isinstance(value, Light): value = Light(value)
      lib.Object_set_light(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Light *", value.impl))

   @property
   def rotationOrder(self): return lib.Object_get_rotationOrder(ffi.cast("struct eC_Object *", self.impl))
   @rotationOrder.setter
   def rotationOrder(self, value):
      lib.Object_set_rotationOrder(ffi.cast("struct eC_Object *", self.impl), value)

   @property
   def displaySystem(self): return pyOrNewObject(DisplaySystem, lib.Object_get_displaySystem(ffi.cast("struct eC_Object *", self.impl)))
   @displaySystem.setter
   def displaySystem(self, value):
      if not isinstance(value, DisplaySystem): value = DisplaySystem(value)
      lib.Object_set_displaySystem(ffi.cast("struct eC_Object *", self.impl), value.impl)

   def add(self, object = None):
      if object is not None and not isinstance(object, Object): object = Object(object)
      object = ffi.NULL if object is None else object.impl
      lib.Object_add(ffi.cast("struct eC_Object *", self.impl), ffi.cast("struct eC_Object *", object))

   def addFrameTrack(self, track = None):
      if track is not None and not isinstance(track, FrameTrack): track = FrameTrack(track)
      track = ffi.NULL if track is None else track.impl
      lib.Object_addFrameTrack(ffi.cast("struct eC_Object *", self.impl), ffi.cast("struct eC_FrameTrack *", track))

   def addName(self, object, name):
      if object is not None and not isinstance(object, Object): object = Object(object)
      object = ffi.NULL if object is None else object.impl
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      return lib.Object_addName(ffi.cast("struct eC_Object *", self.impl), ffi.cast("struct eC_Object *", object), name)

   def animate(self, frame):
      lib.Object_animate(ffi.cast("struct eC_Object *", self.impl), frame)

   def applyMorphs(self, recomputeNormals):
      lib.Object_applyMorphs(ffi.cast("struct eC_Object *", self.impl), recomputeNormals)

   def applySkins(self):
      lib.Object_applySkins(ffi.cast("struct eC_Object *", self.impl))

   def combineMorphs(self):
      lib.Object_combineMorphs(ffi.cast("struct eC_Object *", self.impl))

   def delete(self, child = None, displaySystem = None):
      if child is not None and not isinstance(child, Object): child = Object(child)
      child = ffi.NULL if child is None else child.impl
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      lib.Object_delete(ffi.cast("struct eC_Object *", self.impl), ffi.cast("struct eC_Object *", child), displaySystem)

   def doubleSided(self, flag):
      lib.Object_doubleSided(ffi.cast("struct eC_Object *", self.impl), flag)

   def duplicate(self, model = None):
      if model is not None and not isinstance(model, Object): model = Object(model)
      model = ffi.NULL if model is None else model.impl
      lib.Object_duplicate(ffi.cast("struct eC_Object *", self.impl), ffi.cast("struct eC_Object *", model))

   def duplicate2(self, model, takeOwnership):
      if model is not None and not isinstance(model, Object): model = Object(model)
      model = ffi.NULL if model is None else model.impl
      lib.Object_duplicate2(ffi.cast("struct eC_Object *", self.impl), ffi.cast("struct eC_Object *", model), takeOwnership)

   def find(self, name):
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      return lib.Object_find(ffi.cast("struct eC_Object *", self.impl), name)

   def free(self, displaySystem = None):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      lib.Object_free(ffi.cast("struct eC_Object *", self.impl), displaySystem)

   def freeMesh(self, displaySystem = None):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      lib.Object_freeMesh(ffi.cast("struct eC_Object *", self.impl), displaySystem)

   def initialize(self):
      lib.Object_initialize(ffi.cast("struct eC_Object *", self.impl))

   def initializeMesh(self, displaySystem = None):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Object_initializeMesh(ffi.cast("struct eC_Object *", self.impl), displaySystem)

   def insideFrustum(self, planes):
      return lib.Object_insideFrustum(ffi.cast("struct eC_Object *", self.impl), planes)

   def intersectsGroundPolygon(self, count, pointfs):
      return lib.Object_intersectsGroundPolygon(ffi.cast("struct eC_Object *", self.impl), count, pointfs)

   def inverseKinematics(self, boneIX, limits, vertex, target, maxDepth):
      if target is not None and not isinstance(target, Vector3D): target = Vector3D(target)
      target = ffi.NULL if target is None else target.impl
      lib.Object_inverseKinematics(ffi.cast("struct eC_Object *", self.impl), boneIX, Array.impl, vertex, ffi.cast("eC_Vector3D *", target), maxDepth)

   def load(self, fileName, type, displaySystem = None):
      if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
      elif fileName is None: fileName = ffi.NULL
      if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
      elif type is None: type = ffi.NULL
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Object_load(ffi.cast("struct eC_Object *", self.impl), fileName, type, displaySystem)

   def loadEx(self, fileName, type, displaySystem, options):
      if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
      elif fileName is None: fileName = ffi.NULL
      if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
      elif type is None: type = ffi.NULL
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      if hasattr(options, 'impl'): options = options.impl
      if options is None: options = ffi.NULL
      return lib.Object_loadEx(ffi.cast("struct eC_Object *", self.impl), fileName, type, displaySystem, options)

   def merge(self, displaySystem = None):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Object_merge(ffi.cast("struct eC_Object *", self.impl), displaySystem)

   def mergeEx(self, displaySystem, deleteCPUAttrOptions):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      if deleteCPUAttrOptions is not None and not isinstance(deleteCPUAttrOptions, MeshFeatures): deleteCPUAttrOptions = MeshFeatures(deleteCPUAttrOptions)
      if deleteCPUAttrOptions is None: deleteCPUAttrOptions = ffi.NULL
      return lib.Object_mergeEx(ffi.cast("struct eC_Object *", self.impl), displaySystem, deleteCPUAttrOptions)

   def move(self, direction = None):
      if direction is not None and not isinstance(direction, Vector3D): direction = Vector3D(direction)
      direction = ffi.NULL if direction is None else direction.impl
      lib.Object_move(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Vector3D *", direction))

   def remove(self, child = None):
      if child is not None and not isinstance(child, Object): child = Object(child)
      child = ffi.NULL if child is None else child.impl
      lib.Object_remove(ffi.cast("struct eC_Object *", self.impl), ffi.cast("struct eC_Object *", child))

   def resetPose(self):
      lib.Object_resetPose(ffi.cast("struct eC_Object *", self.impl))

   def rotateEuler(self, rotation = None, min = None, max = None):
      if rotation is not None and not isinstance(rotation, Euler): rotation = Euler(rotation)
      rotation = ffi.NULL if rotation is None else rotation.impl
      if min is not None and not isinstance(min, Euler): min = Euler(min)
      min = ffi.NULL if min is None else min.impl
      if max is not None and not isinstance(max, Euler): max = Euler(max)
      max = ffi.NULL if max is None else max.impl
      lib.Object_rotateEuler(ffi.cast("struct eC_Object *", self.impl), ffi.cast("eC_Euler *", rotation), ffi.cast("eC_Euler *", min), ffi.cast("eC_Euler *", max))

   def save(self, fileName, type):
      if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
      elif fileName is None: fileName = ffi.NULL
      if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
      elif type is None: type = ffi.NULL
      return lib.Object_save(ffi.cast("struct eC_Object *", self.impl), fileName, type)

   def saveEx(self, fileName, type, options):
      if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
      elif fileName is None: fileName = ffi.NULL
      if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
      elif type is None: type = ffi.NULL
      if hasattr(options, 'impl'): options = options.impl
      if options is None: options = ffi.NULL
      return lib.Object_saveEx(ffi.cast("struct eC_Object *", self.impl), fileName, type, options)

   def setMinMaxRadius(self, processMesh):
      lib.Object_setMinMaxRadius(ffi.cast("struct eC_Object *", self.impl), processMesh)

   def updateTransform(self):
      lib.Object_updateTransform(ffi.cast("struct eC_Object *", self.impl))

   def upload(self, displaySystem, mab, meab, nAT, mAT):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      if mab is not None and not isinstance(mab, GLMB): mab = GLMB(mab)
      mab = ffi.NULL if mab is None else mab.impl
      if meab is not None and not isinstance(meab, GLMB): meab = GLMB(meab)
      meab = ffi.NULL if meab is None else meab.impl
      lib.Object_upload(ffi.cast("struct eC_Object *", self.impl), displaySystem, mab, meab, nAT, mAT)

   def listTextures(file, fileName, type, options):
      if file is not None and not isinstance(file, File): file = File(file)
      file = ffi.NULL if file is None else file.impl
      if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
      elif fileName is None: fileName = ffi.NULL
      if isinstance(type, str): type = ffi.new("char[]", type.encode('u8'))
      elif type is None: type = ffi.NULL
      if hasattr(options, 'impl'): options = options.impl
      if options is None: options = ffi.NULL
      return pyOrNewObject(Array, lib.Object_listTextures(file, fileName, type, options), "<String>")

class ObjectFlags(pyBaseClass):
   def __init__(self, root = False, viewSpace = False, ownMesh = False, translucent = False, flipWindings = False, keysLoaded = False, transform = False, mesh = False, light = False, camera = False, localMatrixSet = False, computeLightVectors = False, skinApplied = False, hide = False, skeleton = False, bone = False, hierarchy = 0, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(root, ObjectFlags):
         self.impl = root.impl
      else:
         self.impl = (
            (root                << lib.OBJECTFLAGS_root_SHIFT)                |
            (viewSpace           << lib.OBJECTFLAGS_viewSpace_SHIFT)           |
            (ownMesh             << lib.OBJECTFLAGS_ownMesh_SHIFT)             |
            (translucent         << lib.OBJECTFLAGS_translucent_SHIFT)         |
            (flipWindings        << lib.OBJECTFLAGS_flipWindings_SHIFT)        |
            (keysLoaded          << lib.OBJECTFLAGS_keysLoaded_SHIFT)          |
            (transform           << lib.OBJECTFLAGS_transform_SHIFT)           |
            (mesh                << lib.OBJECTFLAGS_mesh_SHIFT)                |
            (light               << lib.OBJECTFLAGS_light_SHIFT)               |
            (camera              << lib.OBJECTFLAGS_camera_SHIFT)              |
            (localMatrixSet      << lib.OBJECTFLAGS_localMatrixSet_SHIFT)      |
            (computeLightVectors << lib.OBJECTFLAGS_computeLightVectors_SHIFT) |
            (skinApplied         << lib.OBJECTFLAGS_skinApplied_SHIFT)         |
            (hide                << lib.OBJECTFLAGS_hide_SHIFT)                |
            (skeleton            << lib.OBJECTFLAGS_skeleton_SHIFT)            |
            (bone                << lib.OBJECTFLAGS_bone_SHIFT)                |
            (hierarchy           << lib.OBJECTFLAGS_hierarchy_SHIFT)           )

   @property
   def root(self): return ((((self.impl)) & lib.OBJECTFLAGS_root_MASK) >> lib.OBJECTFLAGS_root_SHIFT)
   @root.setter
   def root(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_root_MASK)) | (((value)) << lib.OBJECTFLAGS_root_SHIFT)

   @property
   def viewSpace(self): return ((((self.impl)) & lib.OBJECTFLAGS_viewSpace_MASK) >> lib.OBJECTFLAGS_viewSpace_SHIFT)
   @viewSpace.setter
   def viewSpace(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_viewSpace_MASK)) | (((value)) << lib.OBJECTFLAGS_viewSpace_SHIFT)

   @property
   def ownMesh(self): return ((((self.impl)) & lib.OBJECTFLAGS_ownMesh_MASK) >> lib.OBJECTFLAGS_ownMesh_SHIFT)
   @ownMesh.setter
   def ownMesh(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_ownMesh_MASK)) | (((value)) << lib.OBJECTFLAGS_ownMesh_SHIFT)

   @property
   def translucent(self): return ((((self.impl)) & lib.OBJECTFLAGS_translucent_MASK) >> lib.OBJECTFLAGS_translucent_SHIFT)
   @translucent.setter
   def translucent(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_translucent_MASK)) | (((value)) << lib.OBJECTFLAGS_translucent_SHIFT)

   @property
   def flipWindings(self): return ((((self.impl)) & lib.OBJECTFLAGS_flipWindings_MASK) >> lib.OBJECTFLAGS_flipWindings_SHIFT)
   @flipWindings.setter
   def flipWindings(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_flipWindings_MASK)) | (((value)) << lib.OBJECTFLAGS_flipWindings_SHIFT)

   @property
   def keysLoaded(self): return ((((self.impl)) & lib.OBJECTFLAGS_keysLoaded_MASK) >> lib.OBJECTFLAGS_keysLoaded_SHIFT)
   @keysLoaded.setter
   def keysLoaded(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_keysLoaded_MASK)) | (((value)) << lib.OBJECTFLAGS_keysLoaded_SHIFT)

   @property
   def transform(self): return ((((self.impl)) & lib.OBJECTFLAGS_transform_MASK) >> lib.OBJECTFLAGS_transform_SHIFT)
   @transform.setter
   def transform(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_transform_MASK)) | (((value)) << lib.OBJECTFLAGS_transform_SHIFT)

   @property
   def mesh(self): return ((((self.impl)) & lib.OBJECTFLAGS_mesh_MASK) >> lib.OBJECTFLAGS_mesh_SHIFT)
   @mesh.setter
   def mesh(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_mesh_MASK)) | (((value)) << lib.OBJECTFLAGS_mesh_SHIFT)

   @property
   def light(self): return ((((self.impl)) & lib.OBJECTFLAGS_light_MASK) >> lib.OBJECTFLAGS_light_SHIFT)
   @light.setter
   def light(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_light_MASK)) | (((value)) << lib.OBJECTFLAGS_light_SHIFT)

   @property
   def camera(self): return ((((self.impl)) & lib.OBJECTFLAGS_camera_MASK) >> lib.OBJECTFLAGS_camera_SHIFT)
   @camera.setter
   def camera(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_camera_MASK)) | (((value)) << lib.OBJECTFLAGS_camera_SHIFT)

   @property
   def localMatrixSet(self): return ((((self.impl)) & lib.OBJECTFLAGS_localMatrixSet_MASK) >> lib.OBJECTFLAGS_localMatrixSet_SHIFT)
   @localMatrixSet.setter
   def localMatrixSet(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_localMatrixSet_MASK)) | (((value)) << lib.OBJECTFLAGS_localMatrixSet_SHIFT)

   @property
   def computeLightVectors(self): return ((((self.impl)) & lib.OBJECTFLAGS_computeLightVectors_MASK) >> lib.OBJECTFLAGS_computeLightVectors_SHIFT)
   @computeLightVectors.setter
   def computeLightVectors(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_computeLightVectors_MASK)) | (((value)) << lib.OBJECTFLAGS_computeLightVectors_SHIFT)

   @property
   def skinApplied(self): return ((((self.impl)) & lib.OBJECTFLAGS_skinApplied_MASK) >> lib.OBJECTFLAGS_skinApplied_SHIFT)
   @skinApplied.setter
   def skinApplied(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_skinApplied_MASK)) | (((value)) << lib.OBJECTFLAGS_skinApplied_SHIFT)

   @property
   def hide(self): return ((((self.impl)) & lib.OBJECTFLAGS_hide_MASK) >> lib.OBJECTFLAGS_hide_SHIFT)
   @hide.setter
   def hide(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_hide_MASK)) | (((value)) << lib.OBJECTFLAGS_hide_SHIFT)

   @property
   def skeleton(self): return ((((self.impl)) & lib.OBJECTFLAGS_skeleton_MASK) >> lib.OBJECTFLAGS_skeleton_SHIFT)
   @skeleton.setter
   def skeleton(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_skeleton_MASK)) | (((value)) << lib.OBJECTFLAGS_skeleton_SHIFT)

   @property
   def bone(self): return ((((self.impl)) & lib.OBJECTFLAGS_bone_MASK) >> lib.OBJECTFLAGS_bone_SHIFT)
   @bone.setter
   def bone(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_bone_MASK)) | (((value)) << lib.OBJECTFLAGS_bone_SHIFT)

   @property
   def hierarchy(self): return ((((self.impl)) & lib.OBJECTFLAGS_hierarchy_MASK) >> lib.OBJECTFLAGS_hierarchy_SHIFT)
   @hierarchy.setter
   def hierarchy(self, value): self.impl = ((self.impl) & ~(lib.OBJECTFLAGS_hierarchy_MASK)) | (((value)) << lib.OBJECTFLAGS_hierarchy_SHIFT)

@ffi.callback("eC_bool(eC_ObjectFormat, eC_Object *, const char *, eC_DisplaySystem, void *)")
def cb_ObjectFormat_load(__e, object, fileName, displaySystem, options):
   objectformat = pyOrNewObject(ObjectFormat, __e)
   return objectformat.fn_ObjectFormat_load(objectformat, Object(impl = object), fileName.encode('u8'), pyOrNewObject(DisplaySystem, displaySystem), options)

@ffi.callback("eC_bool(eC_ObjectFormat, eC_Object *, const char *, void *)")
def cb_ObjectFormat_save(__e, object, fileName, options):
   objectformat = pyOrNewObject(ObjectFormat, __e)
   return objectformat.fn_ObjectFormat_save(objectformat, Object(impl = object), fileName.encode('u8'), options)

@ffi.callback("template_Array_String(eC_ObjectFormat, eC_File, const char *, void *)")
def cb_ObjectFormat_listTextures(__e, f, fileName, options):
   objectformat = pyOrNewObject(ObjectFormat, __e)
   return objectformat.fn_ObjectFormat_listTextures(objectformat, pyOrNewObject(File, f), fileName.encode('u8'), options)

class ObjectFormat(Instance):
   class_members = [
                      'load',
                      'save',
                      'listTextures',
                   ]

   def init_args(self, args, kwArgs): init_args(ObjectFormat, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def fn_unset_ObjectFormat_load(self, object, fileName, displaySystem, options):
      return lib.ObjectFormat_load(self.impl, ffi.NULL if object is None else object.impl, fileName, ffi.NULL if displaySystem is None else displaySystem.impl, options)

   @property
   def load(self):
      if hasattr(self, 'fn_ObjectFormat_load'): return self.fn_ObjectFormat_load
      else: return self.fn_unset_ObjectFormat_load
   @load.setter
   def load(self, value):
      self.fn_ObjectFormat_load = value
      lib.Instance_setMethod(self.impl, "Load".encode('u8'), cb_ObjectFormat_load)

   def fn_unset_ObjectFormat_save(self, object, fileName, options):
      return lib.ObjectFormat_save(self.impl, ffi.NULL if object is None else object.impl, fileName, options)

   @property
   def save(self):
      if hasattr(self, 'fn_ObjectFormat_save'): return self.fn_ObjectFormat_save
      else: return self.fn_unset_ObjectFormat_save
   @save.setter
   def save(self, value):
      self.fn_ObjectFormat_save = value
      lib.Instance_setMethod(self.impl, "Save".encode('u8'), cb_ObjectFormat_save)

   def fn_unset_ObjectFormat_listTextures(self, f, fileName, options):
      return pyOrNewObject(Array, lib.ObjectFormat_listTextures(self.impl, ffi.NULL if f is None else f.impl, fileName, options))

   @property
   def listTextures(self):
      if hasattr(self, 'fn_ObjectFormat_listTextures'): return self.fn_ObjectFormat_listTextures
      else: return self.fn_unset_ObjectFormat_listTextures
   @listTextures.setter
   def listTextures(self, value):
      self.fn_ObjectFormat_listTextures = value
      lib.Instance_setMethod(self.impl, "listTextures".encode('u8'), cb_ObjectFormat_listTextures)

class Plane(Struct):
   def __init__(self, a = None, b = None, c = None, d = None, normal = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Plane *", impl)
      else:
         if isinstance(a, tuple):
            __tuple = a
            a = 0.0
            if len(__tuple) > 0: a      = __tuple[0]
            if len(__tuple) > 1: d      = __tuple[1]
         if normal is not None:
            if not isinstance(normal, Vector3D): normal = Vector3D(normal)
         __members = { }
         if a is not None:      __members['a']      = a
         if b is not None:      __members['b']      = b
         if c is not None:      __members['c']      = c
         if d is not None:      __members['d']      = d
         if normal is not None: __members['normal'] = normal.impl[0]
         self.impl = ffi.new("eC_Plane *", __members)

   @property
   def a(self): return self.impl.a
   @a.setter
   def a(self, value): self.impl.a = value

   @property
   def b(self): return self.impl.b
   @b.setter
   def b(self, value): self.impl.b = value

   @property
   def c(self): return self.impl.c
   @c.setter
   def c(self, value): self.impl.c = value

   @property
   def normal(self): return Vector3D(impl = self.impl.normal)
   @normal.setter
   def normal(self, value):
      if not isinstance(value, Vector3D): value = Vector3D(value)
      self.impl.normal = value.impl[0]

   @property
   def d(self): return self.impl.d
   @d.setter
   def d(self, value): self.impl.d = value

   def fromPointNormal(self, normal = None, point = None):
      if normal is not None and not isinstance(normal, Vector3D): normal = Vector3D(normal)
      normal = ffi.NULL if normal is None else normal.impl
      if point is not None and not isinstance(point, Vector3D): point = Vector3D(point)
      point = ffi.NULL if point is None else point.impl
      lib.Plane_fromPointNormal(ffi.cast("eC_Plane *", self.impl), ffi.cast("eC_Vector3D *", normal), ffi.cast("eC_Vector3D *", point))

   def fromPoints(self, v1 = None, v2 = None, v3 = None):
      if v1 is not None and not isinstance(v1, Vector3D): v1 = Vector3D(v1)
      v1 = ffi.NULL if v1 is None else v1.impl
      if v2 is not None and not isinstance(v2, Vector3D): v2 = Vector3D(v2)
      v2 = ffi.NULL if v2 is None else v2.impl
      if v3 is not None and not isinstance(v3, Vector3D): v3 = Vector3D(v3)
      v3 = ffi.NULL if v3 is None else v3.impl
      lib.Plane_fromPoints(ffi.cast("eC_Plane *", self.impl), ffi.cast("eC_Vector3D *", v1), ffi.cast("eC_Vector3D *", v2), ffi.cast("eC_Vector3D *", v3))

   def fromPointsf(self, v1 = None, v2 = None, v3 = None):
      if v1 is not None and not isinstance(v1, Vector3Df): v1 = Vector3Df(v1)
      v1 = ffi.NULL if v1 is None else v1.impl
      if v2 is not None and not isinstance(v2, Vector3Df): v2 = Vector3Df(v2)
      v2 = ffi.NULL if v2 is None else v2.impl
      if v3 is not None and not isinstance(v3, Vector3Df): v3 = Vector3Df(v3)
      v3 = ffi.NULL if v3 is None else v3.impl
      lib.Plane_fromPointsf(ffi.cast("eC_Plane *", self.impl), ffi.cast("eC_Vector3Df *", v1), ffi.cast("eC_Vector3Df *", v2), ffi.cast("eC_Vector3Df *", v3))

   def intersectLine(self, line = None, result = None):
      if line is not None and not isinstance(line, Line): line = Line(line)
      line = ffi.NULL if line is None else line.impl
      if result is not None and not isinstance(result, Vector3D): result = Vector3D(result)
      result = ffi.NULL if result is None else result.impl
      lib.Plane_intersectLine(ffi.cast("eC_Plane *", self.impl), ffi.cast("eC_Line *", line), ffi.cast("eC_Vector3D *", result))

   def intersectLinef(self, line = None, result = None):
      if line is not None and not isinstance(line, Line): line = Line(line)
      line = ffi.NULL if line is None else line.impl
      if result is not None and not isinstance(result, Vector3Df): result = Vector3Df(result)
      result = ffi.NULL if result is None else result.impl
      lib.Plane_intersectLinef(ffi.cast("eC_Plane *", self.impl), ffi.cast("eC_Line *", line), ffi.cast("eC_Vector3Df *", result))

   def intersectLinefT(self, line = None, result = None):
      if line is not None and not isinstance(line, Line): line = Line(line)
      line = ffi.NULL if line is None else line.impl
      if result is not None and not isinstance(result, Vector3Df): result = Vector3Df(result)
      result = ffi.NULL if result is None else result.impl
      rt = ffi.new("double *")
      r = lib.Plane_intersectLinefT(ffi.cast("eC_Plane *", self.impl), ffi.cast("eC_Line *", line), ffi.cast("eC_Vector3Df *", result), rt)
      return r, rt[0]

   def multMatrix(self, source = None, inverseTranspose = None):
      if source is not None and not isinstance(source, Plane): source = Plane(source)
      source = ffi.NULL if source is None else source.impl
      if inverseTranspose is not None and not isinstance(inverseTranspose, Matrix): inverseTranspose = Matrix(inverseTranspose)
      inverseTranspose = ffi.NULL if inverseTranspose is None else inverseTranspose.impl
      lib.Plane_multMatrix(ffi.cast("eC_Plane *", self.impl), ffi.cast("eC_Plane *", source), ffi.cast("eC_Matrix *", inverseTranspose))

class PrimitiveGroup:
   def __init__(self, prev = None, next = None, type = None, baseIndexMesh = None, baseIndexBuffer = None, indices = None, nIndices = None, material = None, first = None, nVertices = None, indices32 = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_PrimitiveGroup *", lib.Instance_new(lib.class_PrimitiveGroup))
         if prev is not None:            self.prev            = prev
         if next is not None:            self.next            = next
         if type is not None:            self.type            = type
         if baseIndexMesh is not None:   self.baseIndexMesh   = baseIndexMesh
         if baseIndexBuffer is not None: self.baseIndexBuffer = baseIndexBuffer
         if indices is not None:         self.indices         = indices
         if nIndices is not None:        self.nIndices        = nIndices
         if material is not None:        self.material        = material
         if first is not None:           self.first           = first
         if nVertices is not None:       self.nVertices       = nVertices
         if indices32 is not None:       self.indices32       = indices32

   @property
   def prev(self): return self.impl.prev
   @prev.setter
   def prev(self, value):
      if not isinstance(value, PrimitiveGroup): value = PrimitiveGroup(value)
      self.impl.prev = value.impl

   @property
   def next(self): return self.impl.next
   @next.setter
   def next(self, value):
      if not isinstance(value, PrimitiveGroup): value = PrimitiveGroup(value)
      self.impl.next = value.impl

   @property
   def type(self): return PrimitiveGroupType(impl = self.impl.type)
   @type.setter
   def type(self, value):
      if not isinstance(value, PrimitiveGroupType): value = PrimitiveGroupType(value)
      self.impl.type = value.impl

   @property
   def baseIndexMesh(self): return self.impl.baseIndexMesh
   @baseIndexMesh.setter
   def baseIndexMesh(self, value): self.impl.baseIndexMesh = value

   @property
   def baseIndexBuffer(self): return self.impl.baseIndexBuffer
   @baseIndexBuffer.setter
   def baseIndexBuffer(self, value): self.impl.baseIndexBuffer = value

   @property
   def indices(self): return self.impl.indices
   @indices.setter
   def indices(self, value): self.impl.indices = value

   @property
   def indices32(self): return self.impl.indices32
   @indices32.setter
   def indices32(self, value): self.impl.indices32 = value

   @property
   def nIndices(self): return self.impl.nIndices
   @nIndices.setter
   def nIndices(self, value): self.impl.nIndices = value

   @property
   def first(self): return self.impl.first
   @first.setter
   def first(self, value): self.impl.first = value

   @property
   def nVertices(self): return self.impl.nVertices
   @nVertices.setter
   def nVertices(self, value): self.impl.nVertices = value

   @property
   def material(self): return self.impl.material
   @material.setter
   def material(self, value):
      if not isinstance(value, Material): value = Material(value)
      self.impl.material = value.impl

class PrimitiveSingle(Struct):
   def __init__(self, type = None, baseIndexMesh = None, baseIndexBuffer = None, indices = None, nIndices = None, material = None, data = None, middle = None, plane = None, first = None, nVertices = None, indices32 = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_PrimitiveSingle *", impl)
      else:
         if type is not None:
            if not isinstance(type, PrimitiveGroupType): type = PrimitiveGroupType(type)
         if material is not None:
            if not isinstance(material, Material): material = Material(material)
         if middle is not None:
            if not isinstance(middle, Vector3Df): middle = Vector3Df(middle)
         if plane is not None:
            if not isinstance(plane, Plane): plane = Plane(plane)
         __members = { }
         if type is not None:            __members['type']            = type.impl
         if baseIndexMesh is not None:   __members['baseIndexMesh']   = baseIndexMesh
         if baseIndexBuffer is not None: __members['baseIndexBuffer'] = baseIndexBuffer
         if indices is not None:         __members['indices']         = indices
         if nIndices is not None:        __members['nIndices']        = nIndices
         if material is not None:        __members['material']        = material.impl
         if data is not None:            __members['data']            = data
         if middle is not None:          __members['middle']          = middle.impl[0]
         if plane is not None:           __members['plane']           = plane.impl[0]
         if first is not None:           __members['first']           = first
         if nVertices is not None:       __members['nVertices']       = nVertices
         if indices32 is not None:       __members['indices32']       = indices32
         self.impl = ffi.new("eC_PrimitiveSingle *", __members)

   @property
   def type(self): return PrimitiveGroupType(impl = self.impl.type)
   @type.setter
   def type(self, value):
      if not isinstance(value, PrimitiveGroupType): value = PrimitiveGroupType(value)
      self.impl.type = value.impl

   @property
   def baseIndexMesh(self): return self.impl.baseIndexMesh
   @baseIndexMesh.setter
   def baseIndexMesh(self, value): self.impl.baseIndexMesh = value

   @property
   def baseIndexBuffer(self): return self.impl.baseIndexBuffer
   @baseIndexBuffer.setter
   def baseIndexBuffer(self, value): self.impl.baseIndexBuffer = value

   @property
   def indices(self): return self.impl.indices
   @indices.setter
   def indices(self, value): self.impl.indices = value

   @property
   def indices32(self): return self.impl.indices32
   @indices32.setter
   def indices32(self, value): self.impl.indices32 = value

   @property
   def nIndices(self): return self.impl.nIndices
   @nIndices.setter
   def nIndices(self, value): self.impl.nIndices = value

   @property
   def first(self): return self.impl.first
   @first.setter
   def first(self, value): self.impl.first = value

   @property
   def nVertices(self): return self.impl.nVertices
   @nVertices.setter
   def nVertices(self, value): self.impl.nVertices = value

   @property
   def material(self): return self.impl.material
   @material.setter
   def material(self, value):
      if not isinstance(value, Material): value = Material(value)
      self.impl.material = value.impl

   @property
   def data(self): return self.impl.data
   @data.setter
   def data(self, value): self.impl.data = value

   @property
   def middle(self): return Vector3Df(impl = self.impl.middle)
   @middle.setter
   def middle(self, value):
      if not isinstance(value, Vector3Df): value = Vector3Df(value)
      self.impl.middle = value.impl[0]

   @property
   def plane(self): return Plane(impl = self.impl.plane)
   @plane.setter
   def plane(self, value):
      if not isinstance(value, Plane): value = Plane(value)
      self.impl.plane = value.impl[0]

class RenderPrimitiveType(PrimitiveGroupType):
   dot       = PrimitiveGroupType(impl = lib.RenderPrimitiveType_dot)
   lines     = PrimitiveGroupType(impl = lib.RenderPrimitiveType_lines)
   triangles = PrimitiveGroupType(impl = lib.RenderPrimitiveType_triangles)
   triStrip  = PrimitiveGroupType(impl = lib.RenderPrimitiveType_triStrip)
   triFan    = PrimitiveGroupType(impl = lib.RenderPrimitiveType_triFan)
   quads     = PrimitiveGroupType(impl = lib.RenderPrimitiveType_quads)
   quadStrip = PrimitiveGroupType(impl = lib.RenderPrimitiveType_quadStrip)
   lineStrip = PrimitiveGroupType(impl = lib.RenderPrimitiveType_lineStrip)

class SkinBone(Struct):
   def __init__(self, name = None, invBindMatrix = None, bsInvBindMatrix = None, object = None, min = None, max = None, origTransform = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_SkinBone *", impl)
      else:
         if name is not None:
            if not isinstance(name, String): name = String(name)
            name = name.impl
         else:
            name = ffi.NULL
         if invBindMatrix is not None:
            if not isinstance(invBindMatrix, Matrix): invBindMatrix = Matrix(invBindMatrix)
            invBindMatrix = invBindMatrix.impl[0]
         else:
            invBindMatrix = Matrix()
            invBindMatrix = invBindMatrix.impl[0]
         if bsInvBindMatrix is not None:
            if not isinstance(bsInvBindMatrix, Matrix): bsInvBindMatrix = Matrix(bsInvBindMatrix)
            bsInvBindMatrix = bsInvBindMatrix.impl[0]
         else:
            bsInvBindMatrix = Matrix()
            bsInvBindMatrix = bsInvBindMatrix.impl[0]
         if object is not None:
            if not isinstance(object, Object): object = Object(object)
            object = object.impl
         else:
            object = ffi.NULL
         if min is not None:
            if not isinstance(min, Vector3Df): min = Vector3Df(min)
            min = min.impl[0]
         else:
            min = Vector3Df()
            min = min.impl[0]
         if max is not None:
            if not isinstance(max, Vector3Df): max = Vector3Df(max)
            max = max.impl[0]
         else:
            max = Vector3Df()
            max = max.impl[0]
         if origTransform is not None:
            if not isinstance(origTransform, Transform): origTransform = Transform(origTransform)
            origTransform = origTransform.impl[0]
         else:
            origTransform = Transform()
            origTransform = origTransform.impl[0]
         self.impl = ffi.new("eC_SkinBone *", {
                                'name' : name,
                                'invBindMatrix' : invBindMatrix,
                                'bsInvBindMatrix' : bsInvBindMatrix,
                                'object' : object,
                                'min' : min,
                                'max' : max,
                                'origTransform' : origTransform
                             })

   @property
   def name(self): return String(self.impl.name)
   @name.setter
   def name(self, value):
      if isinstance(value, str): value = ffi.new("char[]", value.encode('u8'))
      elif value is None: value = ffi.NULL
      self.impl.name = value

   @property
   def invBindMatrix(self): return Matrix(impl = self.impl.invBindMatrix)
   @invBindMatrix.setter
   def invBindMatrix(self, value):
      if not isinstance(value, Matrix): value = Matrix(value)
      self.impl.invBindMatrix = value.impl[0]

   @property
   def bsInvBindMatrix(self): return Matrix(impl = self.impl.bsInvBindMatrix)
   @bsInvBindMatrix.setter
   def bsInvBindMatrix(self, value):
      if not isinstance(value, Matrix): value = Matrix(value)
      self.impl.bsInvBindMatrix = value.impl[0]

   @property
   def object(self): return self.impl.object
   @object.setter
   def object(self, value):
      if not isinstance(value, Object): value = Object(value)
      self.impl.object = value.impl

   @property
   def min(self): return Vector3Df(impl = self.impl.min)
   @min.setter
   def min(self, value):
      if not isinstance(value, Vector3Df): value = Vector3Df(value)
      self.impl.min = value.impl[0]

   @property
   def max(self): return Vector3Df(impl = self.impl.max)
   @max.setter
   def max(self, value):
      if not isinstance(value, Vector3Df): value = Vector3Df(value)
      self.impl.max = value.impl[0]

   @property
   def origTransform(self): return Transform(impl = self.impl.origTransform)
   @origTransform.setter
   def origTransform(self, value):
      if not isinstance(value, Transform): value = Transform(value)
      self.impl.origTransform = value.impl[0]

class SkinVert(Struct):
   def __init__(self, bones = None, weights = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_SkinVert *", impl)
      else:
         if isinstance(bones, tuple):
            __tuple = bones
            bones = None
            if len(__tuple) > 0: bones   = __tuple[0]
            if len(__tuple) > 1: weights = __tuple[1]
         self.impl = ffi.new("eC_SkinVert *", { 'bones' : bones, 'weights' : weights })

   @property
   def bones(self): return self.impl.bones
   @bones.setter
   def bones(self, value): self.impl.bones = value

   @property
   def weights(self): return self.impl.weights
   @weights.setter
   def weights(self, value): self.impl.weights = value

class Transform(Struct):
   def __init__(self, position = None, orientation = None, scaling = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Transform *", impl)
      else:
         if isinstance(position, tuple):
            __tuple = position
            position = None
            if len(__tuple) > 0: position    = __tuple[0]
            if len(__tuple) > 1: orientation = __tuple[1]
            if len(__tuple) > 2: scaling     = __tuple[2]
         elif isinstance(position, Matrix):
            self.impl = ffi.new("eC_Transform *")
            lib.Transform_from_Matrix(self.impl, position.impl)
            return
         if position is not None:
            if not isinstance(position, Vector3D): position = Vector3D(position)
            position = position.impl[0]
         else:
            position = Vector3D()
            position = position.impl[0]
         if orientation is not None:
            if not isinstance(orientation, Quaternion): orientation = Quaternion(orientation)
            orientation = orientation.impl[0]
         else:
            orientation = Quaternion()
            orientation = orientation.impl[0]
         if scaling is not None:
            if not isinstance(scaling, Vector3Df): scaling = Vector3Df(scaling)
            scaling = scaling.impl[0]
         else:
            scaling = Vector3Df()
            scaling = scaling.impl[0]
         self.impl = ffi.new("eC_Transform *", { 'position' : position, 'orientation' : orientation, 'scaling' : scaling })

   @property
   def position(self): return Vector3D(impl = self.impl.position)
   @position.setter
   def position(self, value):
      if not isinstance(value, Vector3D): value = Vector3D(value)
      self.impl.position = value.impl[0]

   @property
   def orientation(self): return Quaternion(impl = self.impl.orientation)
   @orientation.setter
   def orientation(self, value):
      if not isinstance(value, Quaternion): value = Quaternion(value)
      self.impl.orientation = value.impl[0]

   @property
   def scaling(self): return Vector3Df(impl = self.impl.scaling)
   @scaling.setter
   def scaling(self, value):
      if not isinstance(value, Vector3Df): value = Vector3Df(value)
      self.impl.scaling = value.impl[0]

   # def Transform_to_Matrix(self): value = Matrix(); lib.Transform_to_Matrix(self.impl, ffi.cast("eC_Matrix *", value.impl)); return

   # here is an unhandled conversion: Transform::Matrix (StructClass 2 StructClass)
   # Transform_to_Matrix
   # Transform_from_Matrix

   def getMatrix3x4f(self, m):
      lib.Transform_getMatrix3x4f(ffi.cast("eC_Transform *", self.impl), m)

class Vector3D(Struct):
   def __init__(self, x = 0.0, y = 0.0, z = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Vector3D *", impl)
      else:
         if isinstance(x, tuple):
            __tuple = x
            x = 0.0
            if len(__tuple) > 0: x = __tuple[0]
            if len(__tuple) > 1: y = __tuple[1]
            if len(__tuple) > 2: z = __tuple[2]
         self.impl = ffi.new("eC_Vector3D *", { 'x' : x, 'y' : y, 'z' : z })

   @property
   def x(self): return self.impl.x
   @x.setter
   def x(self, value): self.impl.x = value

   @property
   def y(self): return self.impl.y
   @y.setter
   def y(self, value): self.impl.y = value

   @property
   def z(self): return self.impl.z
   @z.setter
   def z(self, value): self.impl.z = value

   @property
   def length(self): return lib.Vector3D_get_length(self.impl)

   @property
   def lengthApprox(self): return lib.Vector3D_get_lengthApprox(self.impl)

   def add(self, vector1 = None, vector2 = None):
      if vector1 is not None and not isinstance(vector1, Vector3D): vector1 = Vector3D(vector1)
      vector1 = ffi.NULL if vector1 is None else vector1.impl
      if vector2 is not None and not isinstance(vector2, Vector3D): vector2 = Vector3D(vector2)
      vector2 = ffi.NULL if vector2 is None else vector2.impl
      lib.Vector3D_add(ffi.cast("eC_Vector3D *", self.impl), ffi.cast("eC_Vector3D *", vector1), ffi.cast("eC_Vector3D *", vector2))

   def crossProduct(self, vector1 = None, vector2 = None):
      if vector1 is not None and not isinstance(vector1, Vector3D): vector1 = Vector3D(vector1)
      vector1 = ffi.NULL if vector1 is None else vector1.impl
      if vector2 is not None and not isinstance(vector2, Vector3D): vector2 = Vector3D(vector2)
      vector2 = ffi.NULL if vector2 is None else vector2.impl
      lib.Vector3D_crossProduct(ffi.cast("eC_Vector3D *", self.impl), ffi.cast("eC_Vector3D *", vector1), ffi.cast("eC_Vector3D *", vector2))

   def divideMatrix(self, v = None, m = None):
      if v is not None and not isinstance(v, Vector3D): v = Vector3D(v)
      v = ffi.NULL if v is None else v.impl
      if m is not None and not isinstance(m, Matrix): m = Matrix(m)
      m = ffi.NULL if m is None else m.impl
      lib.Vector3D_divideMatrix(ffi.cast("eC_Vector3D *", self.impl), ffi.cast("eC_Vector3D *", v), ffi.cast("eC_Matrix *", m))

   def dotProduct(self, vector2 = None):
      if vector2 is not None and not isinstance(vector2, Vector3D): vector2 = Vector3D(vector2)
      vector2 = ffi.NULL if vector2 is None else vector2.impl
      return lib.Vector3D_dotProduct(ffi.cast("eC_Vector3D *", self.impl), ffi.cast("eC_Vector3D *", vector2))

   def dotProductf(self, vector2 = None):
      if vector2 is not None and not isinstance(vector2, Vector3Df): vector2 = Vector3Df(vector2)
      vector2 = ffi.NULL if vector2 is None else vector2.impl
      return lib.Vector3D_dotProductf(ffi.cast("eC_Vector3D *", self.impl), ffi.cast("eC_Vector3Df *", vector2))

   def multMatrix(self, source = None, matrix = None):
      if source is not None and not isinstance(source, Vector3D): source = Vector3D(source)
      source = ffi.NULL if source is None else source.impl
      if matrix is not None and not isinstance(matrix, Matrix): matrix = Matrix(matrix)
      matrix = ffi.NULL if matrix is None else matrix.impl
      lib.Vector3D_multMatrix(ffi.cast("eC_Vector3D *", self.impl), ffi.cast("eC_Vector3D *", source), ffi.cast("eC_Matrix *", matrix))

   def multMatrixf(self, source = None, matrix = None):
      if source is not None and not isinstance(source, Vector3Df): source = Vector3Df(source)
      source = ffi.NULL if source is None else source.impl
      if matrix is not None and not isinstance(matrix, Matrix): matrix = Matrix(matrix)
      matrix = ffi.NULL if matrix is None else matrix.impl
      lib.Vector3D_multMatrixf(ffi.cast("eC_Vector3D *", self.impl), ffi.cast("eC_Vector3Df *", source), ffi.cast("eC_Matrix *", matrix))

   def multQuaternion(self, s = None, quat = None):
      if s is not None and not isinstance(s, Vector3D): s = Vector3D(s)
      s = ffi.NULL if s is None else s.impl
      if quat is not None and not isinstance(quat, Quaternion): quat = Quaternion(quat)
      quat = ffi.NULL if quat is None else quat.impl
      lib.Vector3D_multQuaternion(ffi.cast("eC_Vector3D *", self.impl), ffi.cast("eC_Vector3D *", s), ffi.cast("eC_Quaternion *", quat))

   def normalize(self, source = None):
      if source is not None and not isinstance(source, Vector3D): source = Vector3D(source)
      source = ffi.NULL if source is None else source.impl
      lib.Vector3D_normalize(ffi.cast("eC_Vector3D *", self.impl), ffi.cast("eC_Vector3D *", source))

   def scale(self, vector1, s):
      if vector1 is not None and not isinstance(vector1, Vector3D): vector1 = Vector3D(vector1)
      vector1 = ffi.NULL if vector1 is None else vector1.impl
      lib.Vector3D_scale(ffi.cast("eC_Vector3D *", self.impl), ffi.cast("eC_Vector3D *", vector1), s)

   def subtract(self, vector1 = None, vector2 = None):
      if vector1 is not None and not isinstance(vector1, Vector3D): vector1 = Vector3D(vector1)
      vector1 = ffi.NULL if vector1 is None else vector1.impl
      if vector2 is not None and not isinstance(vector2, Vector3D): vector2 = Vector3D(vector2)
      vector2 = ffi.NULL if vector2 is None else vector2.impl
      lib.Vector3D_subtract(ffi.cast("eC_Vector3D *", self.impl), ffi.cast("eC_Vector3D *", vector1), ffi.cast("eC_Vector3D *", vector2))

class Vector3Df(Struct):
   def __init__(self, x = 0.0, y = 0.0, z = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Vector3Df *", impl)
      else:
         if isinstance(x, tuple):
            __tuple = x
            x = 0.0
            if len(__tuple) > 0: x = __tuple[0]
            if len(__tuple) > 1: y = __tuple[1]
            if len(__tuple) > 2: z = __tuple[2]
         self.impl = ffi.new("eC_Vector3Df *", { 'x' : x, 'y' : y, 'z' : z })

   @property
   def x(self): return self.impl.x
   @x.setter
   def x(self, value): self.impl.x = value

   @property
   def y(self): return self.impl.y
   @y.setter
   def y(self, value): self.impl.y = value

   @property
   def z(self): return self.impl.z
   @z.setter
   def z(self, value): self.impl.z = value

   @property
   def length(self): return lib.Vector3Df_get_length(self.impl)

   @property
   def lengthApprox(self): return lib.Vector3Df_get_lengthApprox(self.impl)

   def add(self, vector1 = None, vector2 = None):
      if vector1 is not None and not isinstance(vector1, Vector3Df): vector1 = Vector3Df(vector1)
      vector1 = ffi.NULL if vector1 is None else vector1.impl
      if vector2 is not None and not isinstance(vector2, Vector3Df): vector2 = Vector3Df(vector2)
      vector2 = ffi.NULL if vector2 is None else vector2.impl
      lib.Vector3Df_add(ffi.cast("eC_Vector3Df *", self.impl), ffi.cast("eC_Vector3Df *", vector1), ffi.cast("eC_Vector3Df *", vector2))

   def crossProduct(self, vector1 = None, vector2 = None):
      if vector1 is not None and not isinstance(vector1, Vector3Df): vector1 = Vector3Df(vector1)
      vector1 = ffi.NULL if vector1 is None else vector1.impl
      if vector2 is not None and not isinstance(vector2, Vector3Df): vector2 = Vector3Df(vector2)
      vector2 = ffi.NULL if vector2 is None else vector2.impl
      lib.Vector3Df_crossProduct(ffi.cast("eC_Vector3Df *", self.impl), ffi.cast("eC_Vector3Df *", vector1), ffi.cast("eC_Vector3Df *", vector2))

   def divideMatrix(self, source = None, matrix = None):
      if source is not None and not isinstance(source, Vector3Df): source = Vector3Df(source)
      source = ffi.NULL if source is None else source.impl
      if matrix is not None and not isinstance(matrix, Matrix): matrix = Matrix(matrix)
      matrix = ffi.NULL if matrix is None else matrix.impl
      lib.Vector3Df_divideMatrix(ffi.cast("eC_Vector3Df *", self.impl), ffi.cast("eC_Vector3Df *", source), ffi.cast("eC_Matrix *", matrix))

   def dotProduct(self, vector2 = None):
      if vector2 is not None and not isinstance(vector2, Vector3Df): vector2 = Vector3Df(vector2)
      vector2 = ffi.NULL if vector2 is None else vector2.impl
      return lib.Vector3Df_dotProduct(ffi.cast("eC_Vector3Df *", self.impl), ffi.cast("eC_Vector3Df *", vector2))

   def multMatrix(self, source = None, matrix = None):
      if source is not None and not isinstance(source, Vector3Df): source = Vector3Df(source)
      source = ffi.NULL if source is None else source.impl
      if matrix is not None and not isinstance(matrix, Matrix): matrix = Matrix(matrix)
      matrix = ffi.NULL if matrix is None else matrix.impl
      lib.Vector3Df_multMatrix(ffi.cast("eC_Vector3Df *", self.impl), ffi.cast("eC_Vector3Df *", source), ffi.cast("eC_Matrix *", matrix))

   def multQuaternion(self, source = None, quat = None):
      if source is not None and not isinstance(source, Vector3Df): source = Vector3Df(source)
      source = ffi.NULL if source is None else source.impl
      if quat is not None and not isinstance(quat, Quaternion): quat = Quaternion(quat)
      quat = ffi.NULL if quat is None else quat.impl
      lib.Vector3Df_multQuaternion(ffi.cast("eC_Vector3Df *", self.impl), ffi.cast("eC_Vector3Df *", source), ffi.cast("eC_Quaternion *", quat))

   def normalize(self, source = None):
      if source is not None and not isinstance(source, Vector3Df): source = Vector3Df(source)
      source = ffi.NULL if source is None else source.impl
      lib.Vector3Df_normalize(ffi.cast("eC_Vector3Df *", self.impl), ffi.cast("eC_Vector3Df *", source))

   def scale(self, vector1, s):
      if vector1 is not None and not isinstance(vector1, Vector3Df): vector1 = Vector3Df(vector1)
      vector1 = ffi.NULL if vector1 is None else vector1.impl
      lib.Vector3Df_scale(ffi.cast("eC_Vector3Df *", self.impl), ffi.cast("eC_Vector3Df *", vector1), s)

   def subtract(self, vector1 = None, vector2 = None):
      if vector1 is not None and not isinstance(vector1, Vector3Df): vector1 = Vector3Df(vector1)
      vector1 = ffi.NULL if vector1 is None else vector1.impl
      if vector2 is not None and not isinstance(vector2, Vector3Df): vector2 = Vector3Df(vector2)
      vector2 = ffi.NULL if vector2 is None else vector2.impl
      lib.Vector3Df_subtract(ffi.cast("eC_Vector3Df *", self.impl), ffi.cast("eC_Vector3Df *", vector1), ffi.cast("eC_Vector3Df *", vector2))

def fastInvSqrt(x):
   return lib.eC_fastInvSqrt(x)

def fastInvSqrtDouble(x):
   return lib.eC_fastInvSqrtDouble(x)

class Cube(Object):
   def __init__(self, transform = None, eulerOrientation = None, material = None, tag = None, frame = None, startFrame = None, endFrame = None, mesh = None, name = None, cameraTarget = None, flags = None, light = None, rotationOrder = None, displaySystem = None, size = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_Cube *", lib.Instance_new(lib.class_Cube))
         if transform is not None:        self.transform             = transform
         if eulerOrientation is not None: self.eulerOrientation      = eulerOrientation
         if material is not None:         self.material              = material
         if tag is not None:              self.tag                   = tag
         if frame is not None:            self.frame                 = frame
         if startFrame is not None:       self.startFrame            = startFrame
         if endFrame is not None:         self.endFrame              = endFrame
         if mesh is not None:             self.mesh                  = mesh
         if name is not None:             self.name                  = name
         if cameraTarget is not None:     self.cameraTarget          = cameraTarget
         if flags is not None:            self.flags                 = flags
         if light is not None:            self.light                 = light
         if rotationOrder is not None:    self.rotationOrder         = rotationOrder
         if displaySystem is not None:    self.displaySystem         = displaySystem
         if size is not None:             self.size                  = size
         if transform is not None:        self.transform        = transform
         if eulerOrientation is not None: self.eulerOrientation = eulerOrientation
         if material is not None:         self.material         = material
         if tag is not None:              self.tag              = tag
         if frame is not None:            self.frame            = frame
         if startFrame is not None:       self.startFrame       = startFrame
         if endFrame is not None:         self.endFrame         = endFrame
         if mesh is not None:             self.mesh             = mesh
         if name is not None:             self.name             = name
         if cameraTarget is not None:     self.cameraTarget     = cameraTarget
         if flags is not None:            self.flags            = flags
         if light is not None:            self.light            = light
         if rotationOrder is not None:    self.rotationOrder    = rotationOrder
         if displaySystem is not None:    self.displaySystem    = displaySystem
         if size is not None:             self.size             = size

   @property
   def size(self): return None
   @size.setter
   def size(self, value):
      if not isinstance(value, Vector3Df): value = Vector3Df(value)
      lib.Cube_set_size(ffi.cast("struct eC_Cube *", self.impl), ffi.cast("eC_Vector3Df *", value.impl))

   def create(self, displaySystem = None):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Cube_create(ffi.cast("struct eC_Cube *", self.impl), displaySystem)

class SkyBox(Object):
   def __init__(self, transform = None, eulerOrientation = None, material = None, tag = None, frame = None, startFrame = None, endFrame = None, mesh = None, name = None, cameraTarget = None, flags = None, light = None, rotationOrder = None, displaySystem = None, size = None, folder = None, extension = None, newStyle = None, cubeMap = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_SkyBox *", lib.Instance_new(lib.class_SkyBox))
         if transform is not None:        self.transform             = transform
         if eulerOrientation is not None: self.eulerOrientation      = eulerOrientation
         if material is not None:         self.material              = material
         if tag is not None:              self.tag                   = tag
         if frame is not None:            self.frame                 = frame
         if startFrame is not None:       self.startFrame            = startFrame
         if endFrame is not None:         self.endFrame              = endFrame
         if mesh is not None:             self.mesh                  = mesh
         if name is not None:             self.name                  = name
         if cameraTarget is not None:     self.cameraTarget          = cameraTarget
         if flags is not None:            self.flags                 = flags
         if light is not None:            self.light                 = light
         if rotationOrder is not None:    self.rotationOrder         = rotationOrder
         if displaySystem is not None:    self.displaySystem         = displaySystem
         if size is not None:             self.size                  = size
         if folder is not None:           self.folder                = folder
         if extension is not None:        self.extension             = extension
         if newStyle is not None:         self.newStyle              = newStyle
         if cubeMap is not None:          self.cubeMap               = cubeMap
         if transform is not None:        self.transform        = transform
         if eulerOrientation is not None: self.eulerOrientation = eulerOrientation
         if material is not None:         self.material         = material
         if tag is not None:              self.tag              = tag
         if frame is not None:            self.frame            = frame
         if startFrame is not None:       self.startFrame       = startFrame
         if endFrame is not None:         self.endFrame         = endFrame
         if mesh is not None:             self.mesh             = mesh
         if name is not None:             self.name             = name
         if cameraTarget is not None:     self.cameraTarget     = cameraTarget
         if flags is not None:            self.flags            = flags
         if light is not None:            self.light            = light
         if rotationOrder is not None:    self.rotationOrder    = rotationOrder
         if displaySystem is not None:    self.displaySystem    = displaySystem
         if size is not None:             self.size             = size
         if folder is not None:           self.folder           = folder
         if extension is not None:        self.extension        = extension
         if newStyle is not None:         self.newStyle         = newStyle
         if cubeMap is not None:          self.cubeMap          = cubeMap

   @property
   def size(self): return None
   @size.setter
   def size(self, value):
      if not isinstance(value, Vector3Df): value = Vector3Df(value)
      lib.SkyBox_set_size(ffi.cast("struct eC_SkyBox *", self.impl), ffi.cast("eC_Vector3Df *", value.impl))

   @property
   def folder(self): return None
   @folder.setter
   def folder(self, value):
      lib.SkyBox_set_folder(ffi.cast("struct eC_SkyBox *", self.impl), value.encode('u8'))

   @property
   def extension(self): return None
   @extension.setter
   def extension(self, value):
      lib.SkyBox_set_extension(ffi.cast("struct eC_SkyBox *", self.impl), value.encode('u8'))

   @property
   def newStyle(self): return None
   @newStyle.setter
   def newStyle(self, value):
      lib.SkyBox_set_newStyle(ffi.cast("struct eC_SkyBox *", self.impl), value)

   @property
   def cubeMap(self): return None
   @cubeMap.setter
   def cubeMap(self, value):
      if not isinstance(value, CubeMap): value = CubeMap(value)
      lib.SkyBox_set_cubeMap(ffi.cast("struct eC_SkyBox *", self.impl), value.impl)

   def create(self, displaySystem = None):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.SkyBox_create(ffi.cast("struct eC_SkyBox *", self.impl), displaySystem)

   def render(self, camera = None, display = None):
      if camera is not None and not isinstance(camera, Camera): camera = Camera(camera)
      camera = ffi.NULL if camera is None else camera.impl
      if display is not None and not isinstance(display, Display): display = Display(display)
      display = ffi.NULL if display is None else display.impl
      lib.SkyBox_render(ffi.cast("struct eC_SkyBox *", self.impl), camera, display)

class Sphere(Object):
   def __init__(self, transform = None, eulerOrientation = None, material = None, tag = None, frame = None, startFrame = None, endFrame = None, mesh = None, name = None, cameraTarget = None, flags = None, light = None, rotationOrder = None, displaySystem = None, numLat = None, numLon = None, flattenedBody = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_Sphere *", lib.Instance_new(lib.class_Sphere))
         if transform is not None:        self.transform             = transform
         if eulerOrientation is not None: self.eulerOrientation      = eulerOrientation
         if material is not None:         self.material              = material
         if tag is not None:              self.tag                   = tag
         if frame is not None:            self.frame                 = frame
         if startFrame is not None:       self.startFrame            = startFrame
         if endFrame is not None:         self.endFrame              = endFrame
         if mesh is not None:             self.mesh                  = mesh
         if name is not None:             self.name                  = name
         if cameraTarget is not None:     self.cameraTarget          = cameraTarget
         if flags is not None:            self.flags                 = flags
         if light is not None:            self.light                 = light
         if rotationOrder is not None:    self.rotationOrder         = rotationOrder
         if displaySystem is not None:    self.displaySystem         = displaySystem
         if numLat is not None:           self.numLat                = numLat
         if numLon is not None:           self.numLon                = numLon
         if flattenedBody is not None:    self.flattenedBody         = flattenedBody
         if transform is not None:        self.transform        = transform
         if eulerOrientation is not None: self.eulerOrientation = eulerOrientation
         if material is not None:         self.material         = material
         if tag is not None:              self.tag              = tag
         if frame is not None:            self.frame            = frame
         if startFrame is not None:       self.startFrame       = startFrame
         if endFrame is not None:         self.endFrame         = endFrame
         if mesh is not None:             self.mesh             = mesh
         if name is not None:             self.name             = name
         if cameraTarget is not None:     self.cameraTarget     = cameraTarget
         if flags is not None:            self.flags            = flags
         if light is not None:            self.light            = light
         if rotationOrder is not None:    self.rotationOrder    = rotationOrder
         if displaySystem is not None:    self.displaySystem    = displaySystem
         if numLat is not None:           self.numLat           = numLat
         if numLon is not None:           self.numLon           = numLon
         if flattenedBody is not None:    self.flattenedBody    = flattenedBody

   @property
   def numLat(self): return None
   @numLat.setter
   def numLat(self, value):
      lib.Sphere_set_numLat(ffi.cast("struct eC_Sphere *", self.impl), value)

   @property
   def numLon(self): return None
   @numLon.setter
   def numLon(self, value):
      lib.Sphere_set_numLon(ffi.cast("struct eC_Sphere *", self.impl), value)

   @property
   def flattenedBody(self): return None
   @flattenedBody.setter
   def flattenedBody(self, value):
      lib.Sphere_set_flattenedBody(ffi.cast("struct eC_Sphere *", self.impl), value)

   def create(self, displaySystem = None):
      if displaySystem is not None and not isinstance(displaySystem, DisplaySystem): displaySystem = DisplaySystem(displaySystem)
      displaySystem = ffi.NULL if displaySystem is None else displaySystem.impl
      return lib.Sphere_create(ffi.cast("struct eC_Sphere *", self.impl), displaySystem)

class BorderBits(pyBaseClass):
   def __init__(self, contour = False, fixed = False, sizable = False, deep = False, bevel = False, thin = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(contour, BorderBits):
         self.impl = contour.impl
      else:
         if isinstance(contour, tuple):
            __tuple = contour
            contour = False
            if len(__tuple) > 0: contour = __tuple[0]
            if len(__tuple) > 1: fixed = __tuple[1]
            if len(__tuple) > 2: sizable = __tuple[2]
            if len(__tuple) > 3: deep = __tuple[3]
            if len(__tuple) > 4: bevel = __tuple[4]
            if len(__tuple) > 5: thin = __tuple[5]
         self.impl = (
            (contour << lib.BORDERBITS_contour_SHIFT) |
            (fixed   << lib.BORDERBITS_fixed_SHIFT)   |
            (sizable << lib.BORDERBITS_sizable_SHIFT) |
            (deep    << lib.BORDERBITS_deep_SHIFT)    |
            (bevel   << lib.BORDERBITS_bevel_SHIFT)   |
            (thin    << lib.BORDERBITS_thin_SHIFT)    )

   @property
   def contour(self): return ((((self.impl)) & lib.BORDERBITS_contour_MASK) >> lib.BORDERBITS_contour_SHIFT)
   @contour.setter
   def contour(self, value): self.impl = ((self.impl) & ~(lib.BORDERBITS_contour_MASK)) | (((value)) << lib.BORDERBITS_contour_SHIFT)

   @property
   def fixed(self): return ((((self.impl)) & lib.BORDERBITS_fixed_MASK) >> lib.BORDERBITS_fixed_SHIFT)
   @fixed.setter
   def fixed(self, value): self.impl = ((self.impl) & ~(lib.BORDERBITS_fixed_MASK)) | (((value)) << lib.BORDERBITS_fixed_SHIFT)

   @property
   def sizable(self): return ((((self.impl)) & lib.BORDERBITS_sizable_MASK) >> lib.BORDERBITS_sizable_SHIFT)
   @sizable.setter
   def sizable(self, value): self.impl = ((self.impl) & ~(lib.BORDERBITS_sizable_MASK)) | (((value)) << lib.BORDERBITS_sizable_SHIFT)

   @property
   def deep(self): return ((((self.impl)) & lib.BORDERBITS_deep_MASK) >> lib.BORDERBITS_deep_SHIFT)
   @deep.setter
   def deep(self, value): self.impl = ((self.impl) & ~(lib.BORDERBITS_deep_MASK)) | (((value)) << lib.BORDERBITS_deep_SHIFT)

   @property
   def bevel(self): return ((((self.impl)) & lib.BORDERBITS_bevel_MASK) >> lib.BORDERBITS_bevel_SHIFT)
   @bevel.setter
   def bevel(self, value): self.impl = ((self.impl) & ~(lib.BORDERBITS_bevel_MASK)) | (((value)) << lib.BORDERBITS_bevel_SHIFT)

   @property
   def thin(self): return ((((self.impl)) & lib.BORDERBITS_thin_MASK) >> lib.BORDERBITS_thin_SHIFT)
   @thin.setter
   def thin(self, value): self.impl = ((self.impl) & ~(lib.BORDERBITS_thin_MASK)) | (((value)) << lib.BORDERBITS_thin_SHIFT)

class Anchor(Struct):
   def __init__(self, left = None, top = None, right = None, bottom = None, horz = None, vert = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Anchor *", impl)
      else:
         if isinstance(left, tuple):
            __tuple = left
            left = None
            if len(__tuple) > 0: left   = __tuple[0]
            if len(__tuple) > 1: top    = __tuple[1]
            if len(__tuple) > 2: right  = __tuple[2]
            if len(__tuple) > 3: bottom = __tuple[3]
         if left is not None:
            if not isinstance(left, AnchorValue): left = AnchorValue(left)
         if top is not None:
            if not isinstance(top, AnchorValue): top = AnchorValue(top)
         if right is not None:
            if not isinstance(right, AnchorValue): right = AnchorValue(right)
         if bottom is not None:
            if not isinstance(bottom, AnchorValue): bottom = AnchorValue(bottom)
         if horz is not None:
            if not isinstance(horz, MiddleAnchorValue): horz = MiddleAnchorValue(horz)
         if vert is not None:
            if not isinstance(vert, MiddleAnchorValue): vert = MiddleAnchorValue(vert)
         __members = { }
         if left is not None:   __members['left']   = left.impl[0]
         if top is not None:    __members['top']    = top.impl[0]
         if right is not None:  __members['right']  = right.impl[0]
         if bottom is not None: __members['bottom'] = bottom.impl[0]
         if horz is not None:   __members['horz']   = horz.impl[0]
         if vert is not None:   __members['vert']   = vert.impl[0]
         self.impl = ffi.new("eC_Anchor *", __members)

   @property
   def left(self): return AnchorValue(impl = self.impl.left)
   @left.setter
   def left(self, value):
      if not isinstance(value, AnchorValue): value = AnchorValue(value)
      self.impl.left = value.impl[0]

   @property
   def horz(self): return MiddleAnchorValue(impl = self.impl.horz)
   @horz.setter
   def horz(self, value):
      if not isinstance(value, MiddleAnchorValue): value = MiddleAnchorValue(value)
      self.impl.horz = value.impl[0]

   @property
   def top(self): return AnchorValue(impl = self.impl.top)
   @top.setter
   def top(self, value):
      if not isinstance(value, AnchorValue): value = AnchorValue(value)
      self.impl.top = value.impl[0]

   @property
   def vert(self): return MiddleAnchorValue(impl = self.impl.vert)
   @vert.setter
   def vert(self, value):
      if not isinstance(value, MiddleAnchorValue): value = MiddleAnchorValue(value)
      self.impl.vert = value.impl[0]

   @property
   def right(self): return AnchorValue(impl = self.impl.right)
   @right.setter
   def right(self, value):
      if not isinstance(value, AnchorValue): value = AnchorValue(value)
      self.impl.right = value.impl[0]

   @property
   def bottom(self): return AnchorValue(impl = self.impl.bottom)
   @bottom.setter
   def bottom(self, value):
      if not isinstance(value, AnchorValue): value = AnchorValue(value)
      self.impl.bottom = value.impl[0]

class AnchorValueType:
   none           = lib.AnchorValueType_none
   offset         = lib.AnchorValueType_offset
   relative       = lib.AnchorValueType_relative
   middleRelative = lib.AnchorValueType_middleRelative
   cascade        = lib.AnchorValueType_cascade
   vTiled         = lib.AnchorValueType_vTiled
   hTiled         = lib.AnchorValueType_hTiled

class BorderStyle(BorderBits):
   none         = BorderBits(impl = lib.BorderStyle_none)
   contour      = BorderBits(impl = lib.BorderStyle_contour)
   fixed        = BorderBits(impl = lib.BorderStyle_fixed)
   sizable      = BorderBits(impl = lib.BorderStyle_sizable)
   thin         = BorderBits(impl = lib.BorderStyle_thin)
   sizableThin  = BorderBits(impl = lib.BorderStyle_sizableThin)
   deep         = BorderBits(impl = lib.BorderStyle_deep)
   bevel        = BorderBits(impl = lib.BorderStyle_bevel)
   sizableDeep  = BorderBits(impl = lib.BorderStyle_sizableDeep)
   sizableBevel = BorderBits(impl = lib.BorderStyle_sizableBevel)
   fixedDeep    = BorderBits(impl = lib.BorderStyle_fixedDeep)
   fixedBevel   = BorderBits(impl = lib.BorderStyle_fixedBevel)
   deepContour  = BorderBits(impl = lib.BorderStyle_deepContour)

class ClipBoard:
   def __init__(self, text = None, handle = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_ClipBoard *", lib.Instance_new(lib.class_ClipBoard))
         if isinstance(text, tuple):
            __tuple = text
            text = None
            if len(__tuple) > 0: text   = __tuple[0]
            if len(__tuple) > 1: handle = __tuple[1]
         if text is not None:   self.text   = text
         if handle is not None: self.handle = handle

   @property
   def text(self): return self.impl.text
   @text.setter
   def text(self, value):
      if isinstance(value, str): value = ffi.new("char[]", value.encode('u8'))
      elif value is None: value = ffi.NULL
      self.impl.text = value

   @property
   def handle(self): return self.impl.handle
   @handle.setter
   def handle(self, value): self.impl.handle = value

   @property
   def memory(self): value = lib.ClipBoard_get_memory(ffi.cast("struct eC_ClipBoard *", self.impl)); return None if value == ffi.NULL else ffi.string(value).decode('u8')

   def allocate(self, size):
      return lib.ClipBoard_allocate(ffi.cast("struct eC_ClipBoard *", self.impl), size)

   def clear(self):
      lib.ClipBoard_clear(ffi.cast("struct eC_ClipBoard *", self.impl))

   def load(self):
      return lib.ClipBoard_load(ffi.cast("struct eC_ClipBoard *", self.impl))

   def save(self):
      return lib.ClipBoard_save(ffi.cast("struct eC_ClipBoard *", self.impl))

   def unload(self):
      lib.ClipBoard_unload(ffi.cast("struct eC_ClipBoard *", self.impl))

class ControllableWindow(Window):
   class_members = []

   def init_args(self, args, kwArgs): init_args(ControllableWindow, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class CreationActivationOption:
   activate  = lib.CreationActivationOption_activate
   flash     = lib.CreationActivationOption_flash
   doNothing = lib.CreationActivationOption_doNothing

class Cursor(Instance):
   class_members = [
                      'systemCursor',
                   ]

   def init_args(self, args, kwArgs): init_args(Cursor, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def systemCursor(self): return None
   @systemCursor.setter
   def systemCursor(self, value):
      lib.Cursor_set_systemCursor(self.impl, value)

   def free(self):
      lib.Cursor_free(self.impl)

   def load(self, name, hotSpotX, hotSpotY, paletteShades, ds = None):
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      if ds is not None and not isinstance(ds, DisplaySystem): ds = DisplaySystem(ds)
      ds = ffi.NULL if ds is None else ds.impl
      return lib.Cursor_load(self.impl, name, hotSpotX, hotSpotY, paletteShades, ds)

class DialogResult:
   cancel = lib.DialogResult_cancel
   yes    = lib.DialogResult_yes
   no     = lib.DialogResult_no
   ok     = lib.DialogResult_ok

class Extent(OldList):
   def __init__(self, first = None, last = None, count = 0, offset = 0, circ = False, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Extent *", impl)
      else:
         if isinstance(first, tuple):
            __tuple = first
            first = None
            if len(__tuple) > 0: first  = __tuple[0]
            if len(__tuple) > 1: last   = __tuple[1]
            if len(__tuple) > 2: count  = __tuple[2]
            if len(__tuple) > 3: offset = __tuple[3]
         self.impl = ffi.new("eC_Extent *", {
                                'first' : first,
                                'last' : last,
                                'count' : count,
                                'offset' : offset,
                                'circ' : circ
                             })

   def addBox(self, box = None):
      if box is not None and not isinstance(box, Box): box = Box(box)
      box = ffi.NULL if box is None else box.impl
      lib.Extent_addBox(ffi.cast("eC_Extent *", self.impl), ffi.cast("eC_Box *", box))

   def copy(self, source = None):
      if source is not None and not isinstance(source, Extent): source = Extent(source)
      source = ffi.NULL if source is None else source.impl
      lib.Extent_copy(ffi.cast("eC_Extent *", self.impl), ffi.cast("eC_Extent *", source))

   def empty(self):
      lib.Extent_empty(ffi.cast("eC_Extent *", self.impl))

   def excludeBox(self, box = None, temp = None):
      if box is not None and not isinstance(box, Box): box = Box(box)
      box = ffi.NULL if box is None else box.impl
      if temp is not None and not isinstance(temp, Extent): temp = Extent(temp)
      temp = ffi.NULL if temp is None else temp.impl
      lib.Extent_excludeBox(ffi.cast("eC_Extent *", self.impl), ffi.cast("eC_Box *", box), ffi.cast("eC_Extent *", temp))

   def exclusion(self, b = None, temp = None):
      if b is not None and not isinstance(b, Extent): b = Extent(b)
      b = ffi.NULL if b is None else b.impl
      if temp is not None and not isinstance(temp, Extent): temp = Extent(temp)
      temp = ffi.NULL if temp is None else temp.impl
      lib.Extent_exclusion(ffi.cast("eC_Extent *", self.impl), ffi.cast("eC_Extent *", b), ffi.cast("eC_Extent *", temp))

   def intersectBox(self, box = None):
      if box is not None and not isinstance(box, Box): box = Box(box)
      box = ffi.NULL if box is None else box.impl
      lib.Extent_intersectBox(ffi.cast("eC_Extent *", self.impl), ffi.cast("eC_Box *", box))

   def intersection(self, b = None, temp = None, temp2 = None, temp3 = None):
      if b is not None and not isinstance(b, Extent): b = Extent(b)
      b = ffi.NULL if b is None else b.impl
      if temp is not None and not isinstance(temp, Extent): temp = Extent(temp)
      temp = ffi.NULL if temp is None else temp.impl
      if temp2 is not None and not isinstance(temp2, Extent): temp2 = Extent(temp2)
      temp2 = ffi.NULL if temp2 is None else temp2.impl
      if temp3 is not None and not isinstance(temp3, Extent): temp3 = Extent(temp3)
      temp3 = ffi.NULL if temp3 is None else temp3.impl
      lib.Extent_intersection(ffi.cast("eC_Extent *", self.impl), ffi.cast("eC_Extent *", b), ffi.cast("eC_Extent *", temp), ffi.cast("eC_Extent *", temp2), ffi.cast("eC_Extent *", temp3))

   def offset(self, x, y):
      lib.Extent_offset(ffi.cast("eC_Extent *", self.impl), x, y)

   def union(self, b = None, temp = None):
      if b is not None and not isinstance(b, Extent): b = Extent(b)
      b = ffi.NULL if b is None else b.impl
      if temp is not None and not isinstance(temp, Extent): temp = Extent(temp)
      temp = ffi.NULL if temp is None else temp.impl
      lib.Extent_union(ffi.cast("eC_Extent *", self.impl), ffi.cast("eC_Extent *", b), ffi.cast("eC_Extent *", temp))

   def unionBox(self, box = None, temp = None):
      if box is not None and not isinstance(box, Box): box = Box(box)
      box = ffi.NULL if box is None else box.impl
      if temp is not None and not isinstance(temp, Extent): temp = Extent(temp)
      temp = ffi.NULL if temp is None else temp.impl
      lib.Extent_unionBox(ffi.cast("eC_Extent *", self.impl), ffi.cast("eC_Box *", box), ffi.cast("eC_Extent *", temp))

@ffi.callback("eC_bool(eC_GuiApplication, eC_bool)")
def cb_GuiApplication_cycle(__e, idle):
   guiapplication = pyOrNewObject(GuiApplication, __e)
   return guiapplication.fn_GuiApplication_cycle(guiapplication, idle)

@ffi.callback("eC_bool(eC_GuiApplication)")
def cb_GuiApplication_init(__e):
   guiapplication = pyOrNewObject(GuiApplication, __e)
   return guiapplication.fn_GuiApplication_init(guiapplication)

@ffi.callback("void(eC_GuiApplication)")
def cb_GuiApplication_terminate(__e):
   guiapplication = pyOrNewObject(GuiApplication, __e)
   guiapplication.fn_GuiApplication_terminate(guiapplication)

class GuiApplication(Application):
   # hack: hardcoded content
   def __init__(self, appGlobals = None):
      Application.__init__(self)
      lib.ecere_init(self.impl)
      rApp = ffi.new("eC_Instance *", self.impl); lib.Instance_evolve(rApp, lib.class_GuiApplication); self.impl = rApp[0]
      if appGlobals is not None:
         self.appGlobals.append(appGlobals)
      else:
         self.appGlobals.append(globals())
   # hack: end of hardcoded content
      self.registerClass(Bitmap, True)
      self.registerClass(BitmapFormat, True)
      self.registerClass(BitmapResource, True)
      self.registerClass(CubeMap, True)
      self.registerClass(Display, True)
      self.registerClass(DisplayDriver, True)
      self.registerClass(DisplaySystem, True)
      self.registerClass(DrawList, True)
      self.registerClass(DrawManager, True)
      self.registerClass(FontManager, True)
      self.registerClass(FontManagerRenderer, True)
      self.registerClass(FontRenderer, True)
      self.registerClass(FontResource, True)
      self.registerClass(Resource, True)
      self.registerClass(Surface, True)
      self.registerClass(DefaultShader, True)
      self.registerClass(FreeBlockMap, True)
      self.registerClass(GLMB, True)
      self.registerClass(GLStats, True)
      self.registerClass(LFBDisplayDriver, True)
      self.registerClass(Shader, True)
      self.registerClass(Camera, True)
      self.registerClass(MeshSkin, True)
      self.registerClass(ObjectFormat, True)
      self.registerClass(CommonControl, True)
      self.registerClass(ControllableWindow, True)
      self.registerClass(Cursor, True)
      self.registerClass(GuiApplication, True)
      self.registerClass(Interface, True)
      self.registerClass(MultiLineString, True)
      self.registerClass(Skin, True)
      self.registerClass(Timer, True)
      self.registerClass(Window, True)
      self.registerClass(WindowController, True)
      self.registerClass(Button, True)
      self.registerClass(CalendarControl, True)
      self.registerClass(DataBox, True)
      self.registerClass(DataField, True)
      self.registerClass(DataRow, True)
      self.registerClass(DirPath, True)
      self.registerClass(DirectoriesBox, True)
      self.registerClass(DropBox, True)
      self.registerClass(EditBox, True)
      self.registerClass(EditBoxStream, True)
      self.registerClass(EditSyntaxHL, True)
      self.registerClass(EditableSelectorButton, True)
      self.registerClass(FilePath, True)
      self.registerClass(Label, True)
      self.registerClass(ListBox, True)
      self.registerClass(Menu, True)
      self.registerClass(MenuDivider, True)
      self.registerClass(MenuItem, True)
      self.registerClass(MenuPlacement, True)
      self.registerClass(OldArray, True)
      self.registerClass(PaneSplitter, True)
      self.registerClass(PathBox, True)
      self.registerClass(Picture, True)
      self.registerClass(PopupMenu, True)
      self.registerClass(ProgressBar, True)
      self.registerClass(SavingDataBox, True)
      self.registerClass(ScrollBar, True)
      self.registerClass(SelectorBar, True)
      self.registerClass(SelectorButton, True)
      self.registerClass(Stacker, True)
      self.registerClass(StatusBar, True)
      self.registerClass(StatusField, True)
      self.registerClass(Tab, True)
      self.registerClass(TabControl, True)
      self.registerClass(ToolBar, True)
      self.registerClass(ToolButton, True)
      self.registerClass(ToolSeparator, True)
      self.registerClass(ToolTip, True)
      self.registerClass(UndoBuffer, True)
      self.registerClass(ColorPicker, True)
      self.registerClass(CreateDirectoryDialog, True)
      self.registerClass(FileDialog, True)
      self.registerClass(FindDialog, True)
      self.registerClass(GoToDialog, True)
      self.registerClass(MessageBox, True)
      self.registerClass(ReplaceDialog, True)
      self.registerClass(WindowList, True)
      self.registerClass(TVisionSkin_Window, True)
      self.registerClass(WindowsSkin_Button, True)
      self.registerClass(WindowsSkin_Window, True)
      self.registerClass(DCOMClientObject, True)
      self.registerClass(DCOMSendControl, True)
      self.registerClass(DCOMServerObject, True)
      self.registerClass(DCOMServerSocket, True)
      self.registerClass(DCOMService, True)
      self.registerClass(FileServerConnection, True)
      self.registerClass(HTTPFile, True)
      self.registerClass(NetworkClientFile, True)
      self.registerClass(SSLSocket, True)
      self.registerClass(Service, True)
      self.registerClass(Socket, True)
      self.registerClass(Archive, True)
      self.registerClass(ArchiveDir, True)
      self.registerClass(BufferedFile, True)
      self.registerClass(ConsoleFile, True)
      self.registerClass(DualPipe, True)
      self.registerClass(ECONGlobalSettings, True)
      self.registerClass(ECONParser, True)
      self.registerClass(File, True)
      self.registerClass(FileMonitor, True)
      self.registerClass(GlobalAppSettings, True)
      self.registerClass(GlobalSettings, True)
      self.registerClass(GlobalSettingsData, True)
      self.registerClass(GlobalSettingsDriver, True)
      self.registerClass(JSONGlobalSettings, True)
      self.registerClass(JSONParser, True)
      self.registerClass(OptionsMap, True)
      self.registerClass(RepButton, True)
      self.registerClass(TempFile, True)
      self.registerClass(Thread, True)

      lib.Instance_evolve(rApp, GuiApplication.pyClass_GuiApplication)
      self.impl = rApp[0]
      ffi.cast("void **", ffi.cast("char *", self.impl) + self.impl._class.offset)[0] = self.handle

   @property
   def appName(self): value = lib.GuiApplication_get_appName(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @appName.setter
   def appName(self, value):
      lib.GuiApplication_set_appName(self.impl, value.encode('u8'))

   @property
   def semaphore(self): return Semaphore(impl = lib.GuiApplication_get_semaphore(self.impl))

   @property
   def alwaysEmptyInput(self): return lib.GuiApplication_get_alwaysEmptyInput(self.impl)
   @alwaysEmptyInput.setter
   def alwaysEmptyInput(self, value):
      lib.GuiApplication_set_alwaysEmptyInput(self.impl, value)

   @property
   def fullScreen(self): return lib.GuiApplication_get_fullScreen(self.impl)
   @fullScreen.setter
   def fullScreen(self, value):
      lib.GuiApplication_set_fullScreen(self.impl, value)

   @property
   def driver(self): value = lib.GuiApplication_get_driver(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @driver.setter
   def driver(self, value):
      lib.GuiApplication_set_driver(self.impl, value.encode('u8'))

   @property
   def resolution(self): return lib.GuiApplication_get_resolution(self.impl)
   @resolution.setter
   def resolution(self, value):
      lib.GuiApplication_set_resolution(self.impl, value)

   @property
   def pixelFormat(self): return lib.GuiApplication_get_pixelFormat(self.impl)
   @pixelFormat.setter
   def pixelFormat(self, value):
      lib.GuiApplication_set_pixelFormat(self.impl, value)

   @property
   def refreshRate(self): return lib.GuiApplication_get_refreshRate(self.impl)
   @refreshRate.setter
   def refreshRate(self, value):
      lib.GuiApplication_set_refreshRate(self.impl, value)

   @property
   def skin(self): value = lib.GuiApplication_get_skin(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @skin.setter
   def skin(self, value):
      lib.GuiApplication_set_skin(self.impl, value.encode('u8'))

   @property
   def textMode(self): return lib.GuiApplication_get_textMode(self.impl)
   @textMode.setter
   def textMode(self, value):
      lib.GuiApplication_set_textMode(self.impl, value)

   @property
   def desktop(self): return pyOrNewObject(Window, lib.GuiApplication_get_desktop(self.impl))

   @property
   def drivers(self): return lib.GuiApplication_get_drivers(self.impl)

   @property
   def skins(self): return lib.GuiApplication_get_skins(self.impl)

   @property
   def currentSkin(self): value = Class(); return lib.GuiApplication_get_currentSkin(self.impl, value.impl)

   @property
   def numDrivers(self): return lib.GuiApplication_get_numDrivers(self.impl)

   @property
   def numSkins(self): return lib.GuiApplication_get_numSkins(self.impl)

   @property
   def timerResolution(self): return None
   @timerResolution.setter
   def timerResolution(self, value):
      lib.GuiApplication_set_timerResolution(self.impl, value)

   @property
   def acquiredWindow(self): return pyOrNewObject(Window, lib.GuiApplication_get_acquiredWindow(self.impl))

   def fn_unset_GuiApplication_cycle(self, idle):
      return lib.GuiApplication_cycle(self.impl, idle)

   @property
   def cycle(self):
      if hasattr(self, 'fn_GuiApplication_cycle'): return self.fn_GuiApplication_cycle
      else: return self.fn_unset_GuiApplication_cycle
   @cycle.setter
   def cycle(self, value):
      self.fn_GuiApplication_cycle = value
      lib.Instance_setMethod(self.impl, "Cycle".encode('u8'), cb_GuiApplication_cycle)

   def getCursor(self, cursor):
      return pyOrNewObject(Cursor, lib.GuiApplication_getCursor(self.impl, cursor))

   def getKeyState(self, key):
      if key is not None and not isinstance(key, Key): key = Key(key)
      if key is None: key = ffi.NULL
      return lib.GuiApplication_getKeyState(self.impl, key)

   def getMouseState(self):
      buttons = ffi.new("eC_MouseButtons *")
      x = ffi.new("int *")
      y = ffi.new("int *")
      r = lib.GuiApplication_getMouseState(self.impl, buttons, x, y)
      return r, MouseButtons(impl = buttons[0]), x[0], y[0]

   def fn_unset_GuiApplication_init(self):
      return lib.GuiApplication_init(self.impl)

   @property
   def init(self):
      if hasattr(self, 'fn_GuiApplication_init'): return self.fn_GuiApplication_init
      else: return self.fn_unset_GuiApplication_init
   @init.setter
   def init(self, value):
      self.fn_GuiApplication_init = value
      lib.Instance_setMethod(self.impl, "Init".encode('u8'), cb_GuiApplication_init)

   def lock(self):
      lib.GuiApplication_lock(self.impl)

   def lockEx(self, count):
      lib.GuiApplication_lockEx(self.impl, count)

   def pauseNetworkEvents(self):
      lib.GuiApplication_pauseNetworkEvents(self.impl)

   def processFileNotifications(self):
      return lib.GuiApplication_processFileNotifications(self.impl)

   def processInput(self, useProcessAll):
      return lib.GuiApplication_processInput(self.impl, useProcessAll)

   def processNetworkEvents(self):
      return lib.GuiApplication_processNetworkEvents(self.impl)

   def resumeNetworkEvents(self):
      lib.GuiApplication_resumeNetworkEvents(self.impl)

   def setDesktopPosition(self, x, y, w, h, moveChildren):
      return lib.GuiApplication_setDesktopPosition(self.impl, x, y, w, h, moveChildren)

   def signalEvent(self):
      lib.GuiApplication_signalEvent(self.impl)

   def switchMode(self, fullScreen, driverName, resolution, colorDepth, refreshRate, skinName, fallBack):
      if isinstance(driverName, str): driverName = ffi.new("char[]", driverName.encode('u8'))
      elif driverName is None: driverName = ffi.NULL
      if isinstance(skinName, str): skinName = ffi.new("char[]", skinName.encode('u8'))
      elif skinName is None: skinName = ffi.NULL
      return lib.GuiApplication_switchMode(self.impl, fullScreen, driverName, resolution, colorDepth, refreshRate, skinName, fallBack)

   def fn_unset_GuiApplication_terminate(self):
      return lib.GuiApplication_terminate(self.impl)

   @property
   def terminate(self):
      if hasattr(self, 'fn_GuiApplication_terminate'): return self.fn_GuiApplication_terminate
      else: return self.fn_unset_GuiApplication_terminate
   @terminate.setter
   def terminate(self, value):
      self.fn_GuiApplication_terminate = value
      lib.Instance_setMethod(self.impl, "Terminate".encode('u8'), cb_GuiApplication_terminate)

   def unlock(self):
      lib.GuiApplication_unlock(self.impl)

   def unlockEx(self):
      return lib.GuiApplication_unlockEx(self.impl)

   def updateDisplay(self):
      lib.GuiApplication_updateDisplay(self.impl)

   def wait(self):
      lib.GuiApplication_wait(self.impl)

   def waitEvent(self):
      lib.GuiApplication_waitEvent(self.impl)

   def waitNetworkEvent(self):
      lib.GuiApplication_waitNetworkEvent(self.impl)

@ffi.callback("eC_bool(eC_Interface, eC_Window, eC_bool)")
def cb_Interface_acquireInput(__e, window, state):
   interface = pyOrNewObject(Interface, __e)
   return interface.fn_Interface_acquireInput(interface, pyOrNewObject(Window, window), state)

@ffi.callback("void(eC_Interface, eC_Window)")
def cb_Interface_activateRootWindow(__e, window):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_activateRootWindow(interface, pyOrNewObject(Window, window))

@ffi.callback("eC_bool(eC_Interface, eC_ClipBoard *, uint)")
def cb_Interface_allocateClipboard(__e, clipBoard, size):
   interface = pyOrNewObject(Interface, __e)
   return interface.fn_Interface_allocateClipboard(interface, ClipBoard(impl = clipBoard), size)

@ffi.callback("void(eC_Interface)")
def cb_Interface_clearClipboard(__e):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_clearClipboard(interface)

@ffi.callback("void * *(eC_Interface, eC_Window)")
def cb_Interface_createRootWindow(__e, window):
   interface = pyOrNewObject(Interface, __e)
   return interface.fn_Interface_createRootWindow(interface, pyOrNewObject(Window, window))

@ffi.callback("void(eC_Interface, eC_Window)")
def cb_Interface_destroyRootWindow(__e, window):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_destroyRootWindow(interface, pyOrNewObject(Window, window))

@ffi.callback("void(eC_Interface, eC_bool *)")
def cb_Interface_ensureFullScreen(__e, fullScreen):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_ensureFullScreen(interface, fullScreen)

@ffi.callback("void(eC_Interface, eC_Window)")
def cb_Interface_flashRootWindow(__e, window):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_flashRootWindow(interface, pyOrNewObject(Window, window))

@ffi.callback("void(eC_Interface, eC_bool *, eC_Resolution *, eC_PixelFormat *, int *)")
def cb_Interface_getCurrentMode(__e, fullScreen, resolution, colorDepth, refreshRate):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_getCurrentMode(interface, fullScreen, resolution, colorDepth, refreshRate)

@ffi.callback("eC_bool(eC_Interface, int, eC_Joystick *)")
def cb_Interface_getJoystickState(__e, device, joystick):
   interface = pyOrNewObject(Interface, __e)
   return interface.fn_Interface_getJoystickState(interface, device, Joystick(impl = joystick))

@ffi.callback("eC_bool(eC_Interface, eC_Key)")
def cb_Interface_getKeyState(__e, key):
   interface = pyOrNewObject(Interface, __e)
   return interface.fn_Interface_getKeyState(interface, Key(impl = key))

@ffi.callback("void(eC_Interface, int *, int *)")
def cb_Interface_getMousePosition(__e, x, y):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_getMousePosition(interface, x, y)

@ffi.callback("eC_bool(eC_Interface, eC_MouseButtons *, int *, int *)")
def cb_Interface_getMouseState(__e, buttons, x, y):
   interface = pyOrNewObject(Interface, __e)
   return interface.fn_Interface_getMouseState(interface, buttons, x, y)

@ffi.callback("void(eC_Interface, eC_Window, eC_Box *)")
def cb_Interface_getScreenArea(__e, window, box):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_getScreenArea(interface, pyOrNewObject(Window, window), Box(impl = box))

@ffi.callback("const char * * * *(eC_Interface, int *)")
def cb_Interface_graphicsDrivers(__e, numDrivers):
   interface = pyOrNewObject(Interface, __e)
   return interface.fn_Interface_graphicsDrivers(interface, numDrivers)

@ffi.callback("eC_bool(eC_Interface)")
def cb_Interface_initialize(__e):
   interface = pyOrNewObject(Interface, __e)
   return interface.fn_Interface_initialize(interface)

@ffi.callback("eC_bool(eC_Interface, eC_ClipBoard *)")
def cb_Interface_loadClipboard(__e, clipBoard):
   interface = pyOrNewObject(Interface, __e)
   return interface.fn_Interface_loadClipboard(interface, ClipBoard(impl = clipBoard))

@ffi.callback("void(eC_Interface, eC_Window)")
def cb_Interface_lock(__e, window):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_lock(interface, pyOrNewObject(Window, window))

@ffi.callback("void(eC_Interface, eC_Window, int *, int *)")
def cb_Interface_offsetWindow(__e, window, x, y):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_offsetWindow(interface, pyOrNewObject(Window, window), x, y)

@ffi.callback("void(eC_Interface, eC_Window, eC_bool)")
def cb_Interface_orderRootWindow(__e, window, topMost):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_orderRootWindow(interface, pyOrNewObject(Window, window), topMost)

@ffi.callback("void(eC_Interface, eC_Window, int, int, int, int, eC_bool, eC_bool)")
def cb_Interface_positionRootWindow(__e, window, x, y, w, h, move, resize):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_positionRootWindow(interface, pyOrNewObject(Window, window), x, y, w, h, move, resize)

@ffi.callback("eC_bool(eC_Interface, eC_bool)")
def cb_Interface_processInput(__e, processAll):
   interface = pyOrNewObject(Interface, __e)
   return interface.fn_Interface_processInput(interface, processAll)

@ffi.callback("eC_bool(eC_Interface, eC_ClipBoard *)")
def cb_Interface_saveClipboard(__e, clipBoard):
   interface = pyOrNewObject(Interface, __e)
   return interface.fn_Interface_saveClipboard(interface, ClipBoard(impl = clipBoard))

@ffi.callback("eC_bool(eC_Interface, eC_bool, eC_Resolution, eC_PixelFormat, int, eC_bool *)")
def cb_Interface_screenMode(__e, fullScreen, resolution, colorDepth, refreshRate, textMode):
   interface = pyOrNewObject(Interface, __e)
   return interface.fn_Interface_screenMode(interface, fullScreen, Resolution(impl = resolution), PixelFormat(impl = colorDepth), refreshRate, textMode)

@ffi.callback("void(eC_Interface, int, int, int)")
def cb_Interface_setCaret(__e, caretX, caretY, size):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_setCaret(interface, caretX, caretY, size)

@ffi.callback("eC_bool(eC_Interface, eC_Window, eC_BitmapResource)")
def cb_Interface_setIcon(__e, window, icon):
   interface = pyOrNewObject(Interface, __e)
   return interface.fn_Interface_setIcon(interface, pyOrNewObject(Window, window), pyOrNewObject(BitmapResource, icon))

@ffi.callback("void(eC_Interface, eC_Window)")
def cb_Interface_setMouseCapture(__e, window):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_setMouseCapture(interface, pyOrNewObject(Window, window))

@ffi.callback("void(eC_Interface, eC_Window, eC_SystemCursor)")
def cb_Interface_setMouseCursor(__e, window, cursor):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_setMouseCursor(interface, pyOrNewObject(Window, window), SystemCursor(impl = cursor))

@ffi.callback("void(eC_Interface, int, int)")
def cb_Interface_setMousePosition(__e, x, y):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_setMousePosition(interface, x, y)

@ffi.callback("void(eC_Interface, eC_Window, eC_Box *)")
def cb_Interface_setMouseRange(__e, window, box):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_setMouseRange(interface, pyOrNewObject(Window, window), Box(impl = box))

@ffi.callback("void(eC_Interface, eC_Window, const char *)")
def cb_Interface_setRootWindowCaption(__e, window, name):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_setRootWindowCaption(interface, pyOrNewObject(Window, window), name.encode('u8'))

@ffi.callback("void(eC_Interface, eC_Window)")
def cb_Interface_setRootWindowColor(__e, window):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_setRootWindowColor(interface, pyOrNewObject(Window, window))

@ffi.callback("void(eC_Interface, eC_Window, eC_WindowState, eC_bool)")
def cb_Interface_setRootWindowState(__e, window, state, visible):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_setRootWindowState(interface, pyOrNewObject(Window, window), WindowState(impl = state), visible)

@ffi.callback("void(eC_Interface, uint)")
def cb_Interface_setTimerResolution(__e, hertz):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_setTimerResolution(interface, hertz)

@ffi.callback("void(eC_Interface, eC_Window, int, int, eC_bool)")
def cb_Interface_startMoving(__e, window, x, y, fromKeyBoard):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_startMoving(interface, pyOrNewObject(Window, window), x, y, fromKeyBoard)

@ffi.callback("void(eC_Interface, eC_Window)")
def cb_Interface_stopMoving(__e, window):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_stopMoving(interface, pyOrNewObject(Window, window))

@ffi.callback("void(eC_Interface)")
def cb_Interface_terminate(__e):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_terminate(interface)

@ffi.callback("void(eC_Interface, eC_ClipBoard *)")
def cb_Interface_unloadClipboard(__e, clipBoard):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_unloadClipboard(interface, ClipBoard(impl = clipBoard))

@ffi.callback("void(eC_Interface, eC_Window)")
def cb_Interface_unlock(__e, window):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_unlock(interface, pyOrNewObject(Window, window))

@ffi.callback("void(eC_Interface, eC_Window)")
def cb_Interface_updateRootWindow(__e, window):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_updateRootWindow(interface, pyOrNewObject(Window, window))

@ffi.callback("void(eC_Interface)")
def cb_Interface_wait(__e):
   interface = pyOrNewObject(Interface, __e)
   interface.fn_Interface_wait(interface)

class Interface(Instance):
   class_members = [
                      'acquireInput',
                      'activateRootWindow',
                      'allocateClipboard',
                      'clearClipboard',
                      'createRootWindow',
                      'destroyRootWindow',
                      'ensureFullScreen',
                      'flashRootWindow',
                      'getCurrentMode',
                      'getJoystickState',
                      'getKeyState',
                      'getMousePosition',
                      'getMouseState',
                      'getScreenArea',
                      'graphicsDrivers',
                      'initialize',
                      'loadClipboard',
                      'lock',
                      'offsetWindow',
                      'orderRootWindow',
                      'positionRootWindow',
                      'processInput',
                      'saveClipboard',
                      'screenMode',
                      'setCaret',
                      'setIcon',
                      'setMouseCapture',
                      'setMouseCursor',
                      'setMousePosition',
                      'setMouseRange',
                      'setRootWindowCaption',
                      'setRootWindowColor',
                      'setRootWindowState',
                      'setTimerResolution',
                      'startMoving',
                      'stopMoving',
                      'terminate',
                      'unloadClipboard',
                      'unlock',
                      'updateRootWindow',
                      'wait',
                   ]

   def init_args(self, args, kwArgs): init_args(Interface, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def fn_unset_Interface_acquireInput(self, window, state):
      return lib.Interface_acquireInput(self.impl, ffi.NULL if window is None else window.impl, state)

   @property
   def acquireInput(self):
      if hasattr(self, 'fn_Interface_acquireInput'): return self.fn_Interface_acquireInput
      else: return self.fn_unset_Interface_acquireInput
   @acquireInput.setter
   def acquireInput(self, value):
      self.fn_Interface_acquireInput = value
      lib.Instance_setMethod(self.impl, "AcquireInput".encode('u8'), cb_Interface_acquireInput)

   def fn_unset_Interface_activateRootWindow(self, window):
      return lib.Interface_activateRootWindow(self.impl, ffi.NULL if window is None else window.impl)

   @property
   def activateRootWindow(self):
      if hasattr(self, 'fn_Interface_activateRootWindow'): return self.fn_Interface_activateRootWindow
      else: return self.fn_unset_Interface_activateRootWindow
   @activateRootWindow.setter
   def activateRootWindow(self, value):
      self.fn_Interface_activateRootWindow = value
      lib.Instance_setMethod(self.impl, "ActivateRootWindow".encode('u8'), cb_Interface_activateRootWindow)

   def fn_unset_Interface_allocateClipboard(self, clipBoard, size):
      return lib.Interface_allocateClipboard(self.impl, ffi.NULL if clipBoard is None else clipBoard.impl, size)

   @property
   def allocateClipboard(self):
      if hasattr(self, 'fn_Interface_allocateClipboard'): return self.fn_Interface_allocateClipboard
      else: return self.fn_unset_Interface_allocateClipboard
   @allocateClipboard.setter
   def allocateClipboard(self, value):
      self.fn_Interface_allocateClipboard = value
      lib.Instance_setMethod(self.impl, "AllocateClipboard".encode('u8'), cb_Interface_allocateClipboard)

   def fn_unset_Interface_clearClipboard(self):
      return lib.Interface_clearClipboard(self.impl)

   @property
   def clearClipboard(self):
      if hasattr(self, 'fn_Interface_clearClipboard'): return self.fn_Interface_clearClipboard
      else: return self.fn_unset_Interface_clearClipboard
   @clearClipboard.setter
   def clearClipboard(self, value):
      self.fn_Interface_clearClipboard = value
      lib.Instance_setMethod(self.impl, "ClearClipboard".encode('u8'), cb_Interface_clearClipboard)

   def fn_unset_Interface_createRootWindow(self, window):
      return lib.Interface_createRootWindow(self.impl, ffi.NULL if window is None else window.impl)

   @property
   def createRootWindow(self):
      if hasattr(self, 'fn_Interface_createRootWindow'): return self.fn_Interface_createRootWindow
      else: return self.fn_unset_Interface_createRootWindow
   @createRootWindow.setter
   def createRootWindow(self, value):
      self.fn_Interface_createRootWindow = value
      lib.Instance_setMethod(self.impl, "CreateRootWindow".encode('u8'), cb_Interface_createRootWindow)

   def fn_unset_Interface_destroyRootWindow(self, window):
      return lib.Interface_destroyRootWindow(self.impl, ffi.NULL if window is None else window.impl)

   @property
   def destroyRootWindow(self):
      if hasattr(self, 'fn_Interface_destroyRootWindow'): return self.fn_Interface_destroyRootWindow
      else: return self.fn_unset_Interface_destroyRootWindow
   @destroyRootWindow.setter
   def destroyRootWindow(self, value):
      self.fn_Interface_destroyRootWindow = value
      lib.Instance_setMethod(self.impl, "DestroyRootWindow".encode('u8'), cb_Interface_destroyRootWindow)

   def fn_unset_Interface_ensureFullScreen(self, fullScreen):
      if fullScreen is None: fullScreen = ffi.NULL
      return lib.Interface_ensureFullScreen(self.impl, fullScreen)

   @property
   def ensureFullScreen(self):
      if hasattr(self, 'fn_Interface_ensureFullScreen'): return self.fn_Interface_ensureFullScreen
      else: return self.fn_unset_Interface_ensureFullScreen
   @ensureFullScreen.setter
   def ensureFullScreen(self, value):
      self.fn_Interface_ensureFullScreen = value
      lib.Instance_setMethod(self.impl, "EnsureFullScreen".encode('u8'), cb_Interface_ensureFullScreen)

   def fn_unset_Interface_flashRootWindow(self, window):
      return lib.Interface_flashRootWindow(self.impl, ffi.NULL if window is None else window.impl)

   @property
   def flashRootWindow(self):
      if hasattr(self, 'fn_Interface_flashRootWindow'): return self.fn_Interface_flashRootWindow
      else: return self.fn_unset_Interface_flashRootWindow
   @flashRootWindow.setter
   def flashRootWindow(self, value):
      self.fn_Interface_flashRootWindow = value
      lib.Instance_setMethod(self.impl, "FlashRootWindow".encode('u8'), cb_Interface_flashRootWindow)

   def fn_unset_Interface_getCurrentMode(self, fullScreen, resolution, colorDepth, refreshRate):
      if fullScreen is None: fullScreen = ffi.NULL
      if refreshRate is None: refreshRate = ffi.NULL
      return lib.Interface_getCurrentMode(self.impl, fullScreen, resolution, colorDepth, refreshRate)

   @property
   def getCurrentMode(self):
      if hasattr(self, 'fn_Interface_getCurrentMode'): return self.fn_Interface_getCurrentMode
      else: return self.fn_unset_Interface_getCurrentMode
   @getCurrentMode.setter
   def getCurrentMode(self, value):
      self.fn_Interface_getCurrentMode = value
      lib.Instance_setMethod(self.impl, "GetCurrentMode".encode('u8'), cb_Interface_getCurrentMode)

   def getExtendedKey(key):
      if key is not None and not isinstance(key, Key): key = Key(key)
      if key is None: key = ffi.NULL
      return Key(impl = lib.Interface_getExtendedKey(key))

   def fn_unset_Interface_getJoystickState(self, device, joystick):
      return lib.Interface_getJoystickState(self.impl, device, ffi.NULL if joystick is None else joystick.impl)

   @property
   def getJoystickState(self):
      if hasattr(self, 'fn_Interface_getJoystickState'): return self.fn_Interface_getJoystickState
      else: return self.fn_unset_Interface_getJoystickState
   @getJoystickState.setter
   def getJoystickState(self, value):
      self.fn_Interface_getJoystickState = value
      lib.Instance_setMethod(self.impl, "GetJoystickState".encode('u8'), cb_Interface_getJoystickState)

   def fn_unset_Interface_getKeyState(self, key):
      return lib.Interface_getKeyState(self.impl, key)

   @property
   def getKeyState(self):
      if hasattr(self, 'fn_Interface_getKeyState'): return self.fn_Interface_getKeyState
      else: return self.fn_unset_Interface_getKeyState
   @getKeyState.setter
   def getKeyState(self, value):
      self.fn_Interface_getKeyState = value
      lib.Instance_setMethod(self.impl, "GetKeyState".encode('u8'), cb_Interface_getKeyState)

   def fn_unset_Interface_getMousePosition(self, x, y):
      if x is None: x = ffi.NULL
      if y is None: y = ffi.NULL
      return lib.Interface_getMousePosition(self.impl, x, y)

   @property
   def getMousePosition(self):
      if hasattr(self, 'fn_Interface_getMousePosition'): return self.fn_Interface_getMousePosition
      else: return self.fn_unset_Interface_getMousePosition
   @getMousePosition.setter
   def getMousePosition(self, value):
      self.fn_Interface_getMousePosition = value
      lib.Instance_setMethod(self.impl, "GetMousePosition".encode('u8'), cb_Interface_getMousePosition)

   def fn_unset_Interface_getMouseState(self, buttons, x, y):
      if buttons is None: buttons = ffi.NULL
      if x is None: x = ffi.NULL
      if y is None: y = ffi.NULL
      return lib.Interface_getMouseState(self.impl, buttons, x, y)

   @property
   def getMouseState(self):
      if hasattr(self, 'fn_Interface_getMouseState'): return self.fn_Interface_getMouseState
      else: return self.fn_unset_Interface_getMouseState
   @getMouseState.setter
   def getMouseState(self, value):
      self.fn_Interface_getMouseState = value
      lib.Instance_setMethod(self.impl, "GetMouseState".encode('u8'), cb_Interface_getMouseState)

   def fn_unset_Interface_getScreenArea(self, window, box):
      return lib.Interface_getScreenArea(self.impl, ffi.NULL if window is None else window.impl, ffi.NULL if box is None else box.impl)

   @property
   def getScreenArea(self):
      if hasattr(self, 'fn_Interface_getScreenArea'): return self.fn_Interface_getScreenArea
      else: return self.fn_unset_Interface_getScreenArea
   @getScreenArea.setter
   def getScreenArea(self, value):
      self.fn_Interface_getScreenArea = value
      lib.Instance_setMethod(self.impl, "GetScreenArea".encode('u8'), cb_Interface_getScreenArea)

   def fn_unset_Interface_graphicsDrivers(self, numDrivers):
      if numDrivers is None: numDrivers = ffi.NULL
      return lib.Interface_graphicsDrivers(self.impl, numDrivers)

   @property
   def graphicsDrivers(self):
      if hasattr(self, 'fn_Interface_graphicsDrivers'): return self.fn_Interface_graphicsDrivers
      else: return self.fn_unset_Interface_graphicsDrivers
   @graphicsDrivers.setter
   def graphicsDrivers(self, value):
      self.fn_Interface_graphicsDrivers = value
      lib.Instance_setMethod(self.impl, "GraphicsDrivers".encode('u8'), cb_Interface_graphicsDrivers)

   def fn_unset_Interface_initialize(self):
      return lib.Interface_initialize(self.impl)

   @property
   def initialize(self):
      if hasattr(self, 'fn_Interface_initialize'): return self.fn_Interface_initialize
      else: return self.fn_unset_Interface_initialize
   @initialize.setter
   def initialize(self, value):
      self.fn_Interface_initialize = value
      lib.Instance_setMethod(self.impl, "Initialize".encode('u8'), cb_Interface_initialize)

   def fn_unset_Interface_loadClipboard(self, clipBoard):
      return lib.Interface_loadClipboard(self.impl, ffi.NULL if clipBoard is None else clipBoard.impl)

   @property
   def loadClipboard(self):
      if hasattr(self, 'fn_Interface_loadClipboard'): return self.fn_Interface_loadClipboard
      else: return self.fn_unset_Interface_loadClipboard
   @loadClipboard.setter
   def loadClipboard(self, value):
      self.fn_Interface_loadClipboard = value
      lib.Instance_setMethod(self.impl, "LoadClipboard".encode('u8'), cb_Interface_loadClipboard)

   def fn_unset_Interface_lock(self, window):
      return lib.Interface_lock(self.impl, ffi.NULL if window is None else window.impl)

   @property
   def lock(self):
      if hasattr(self, 'fn_Interface_lock'): return self.fn_Interface_lock
      else: return self.fn_unset_Interface_lock
   @lock.setter
   def lock(self, value):
      self.fn_Interface_lock = value
      lib.Instance_setMethod(self.impl, "Lock".encode('u8'), cb_Interface_lock)

   def fn_unset_Interface_offsetWindow(self, window, x, y):
      if x is None: x = ffi.NULL
      if y is None: y = ffi.NULL
      return lib.Interface_offsetWindow(self.impl, ffi.NULL if window is None else window.impl, x, y)

   @property
   def offsetWindow(self):
      if hasattr(self, 'fn_Interface_offsetWindow'): return self.fn_Interface_offsetWindow
      else: return self.fn_unset_Interface_offsetWindow
   @offsetWindow.setter
   def offsetWindow(self, value):
      self.fn_Interface_offsetWindow = value
      lib.Instance_setMethod(self.impl, "OffsetWindow".encode('u8'), cb_Interface_offsetWindow)

   def fn_unset_Interface_orderRootWindow(self, window, topMost):
      return lib.Interface_orderRootWindow(self.impl, ffi.NULL if window is None else window.impl, topMost)

   @property
   def orderRootWindow(self):
      if hasattr(self, 'fn_Interface_orderRootWindow'): return self.fn_Interface_orderRootWindow
      else: return self.fn_unset_Interface_orderRootWindow
   @orderRootWindow.setter
   def orderRootWindow(self, value):
      self.fn_Interface_orderRootWindow = value
      lib.Instance_setMethod(self.impl, "OrderRootWindow".encode('u8'), cb_Interface_orderRootWindow)

   def fn_unset_Interface_positionRootWindow(self, window, x, y, w, h, move, resize):
      return lib.Interface_positionRootWindow(self.impl, ffi.NULL if window is None else window.impl, x, y, w, h, move, resize)

   @property
   def positionRootWindow(self):
      if hasattr(self, 'fn_Interface_positionRootWindow'): return self.fn_Interface_positionRootWindow
      else: return self.fn_unset_Interface_positionRootWindow
   @positionRootWindow.setter
   def positionRootWindow(self, value):
      self.fn_Interface_positionRootWindow = value
      lib.Instance_setMethod(self.impl, "PositionRootWindow".encode('u8'), cb_Interface_positionRootWindow)

   def fn_unset_Interface_processInput(self, processAll):
      return lib.Interface_processInput(self.impl, processAll)

   @property
   def processInput(self):
      if hasattr(self, 'fn_Interface_processInput'): return self.fn_Interface_processInput
      else: return self.fn_unset_Interface_processInput
   @processInput.setter
   def processInput(self, value):
      self.fn_Interface_processInput = value
      lib.Instance_setMethod(self.impl, "ProcessInput".encode('u8'), cb_Interface_processInput)

   def fn_unset_Interface_saveClipboard(self, clipBoard):
      return lib.Interface_saveClipboard(self.impl, ffi.NULL if clipBoard is None else clipBoard.impl)

   @property
   def saveClipboard(self):
      if hasattr(self, 'fn_Interface_saveClipboard'): return self.fn_Interface_saveClipboard
      else: return self.fn_unset_Interface_saveClipboard
   @saveClipboard.setter
   def saveClipboard(self, value):
      self.fn_Interface_saveClipboard = value
      lib.Instance_setMethod(self.impl, "SaveClipboard".encode('u8'), cb_Interface_saveClipboard)

   def fn_unset_Interface_screenMode(self, fullScreen, resolution, colorDepth, refreshRate, textMode):
      if textMode is None: textMode = ffi.NULL
      return lib.Interface_screenMode(self.impl, fullScreen, resolution, colorDepth, refreshRate, textMode)

   @property
   def screenMode(self):
      if hasattr(self, 'fn_Interface_screenMode'): return self.fn_Interface_screenMode
      else: return self.fn_unset_Interface_screenMode
   @screenMode.setter
   def screenMode(self, value):
      self.fn_Interface_screenMode = value
      lib.Instance_setMethod(self.impl, "ScreenMode".encode('u8'), cb_Interface_screenMode)

   def fn_unset_Interface_setCaret(self, caretX, caretY, size):
      return lib.Interface_setCaret(self.impl, caretX, caretY, size)

   @property
   def setCaret(self):
      if hasattr(self, 'fn_Interface_setCaret'): return self.fn_Interface_setCaret
      else: return self.fn_unset_Interface_setCaret
   @setCaret.setter
   def setCaret(self, value):
      self.fn_Interface_setCaret = value
      lib.Instance_setMethod(self.impl, "SetCaret".encode('u8'), cb_Interface_setCaret)

   def fn_unset_Interface_setIcon(self, window, icon):
      return lib.Interface_setIcon(self.impl, ffi.NULL if window is None else window.impl, ffi.NULL if icon is None else icon.impl)

   @property
   def setIcon(self):
      if hasattr(self, 'fn_Interface_setIcon'): return self.fn_Interface_setIcon
      else: return self.fn_unset_Interface_setIcon
   @setIcon.setter
   def setIcon(self, value):
      self.fn_Interface_setIcon = value
      lib.Instance_setMethod(self.impl, "SetIcon".encode('u8'), cb_Interface_setIcon)

   def fn_unset_Interface_setMouseCapture(self, window):
      return lib.Interface_setMouseCapture(self.impl, ffi.NULL if window is None else window.impl)

   @property
   def setMouseCapture(self):
      if hasattr(self, 'fn_Interface_setMouseCapture'): return self.fn_Interface_setMouseCapture
      else: return self.fn_unset_Interface_setMouseCapture
   @setMouseCapture.setter
   def setMouseCapture(self, value):
      self.fn_Interface_setMouseCapture = value
      lib.Instance_setMethod(self.impl, "SetMouseCapture".encode('u8'), cb_Interface_setMouseCapture)

   def fn_unset_Interface_setMouseCursor(self, window, cursor):
      return lib.Interface_setMouseCursor(self.impl, ffi.NULL if window is None else window.impl, cursor)

   @property
   def setMouseCursor(self):
      if hasattr(self, 'fn_Interface_setMouseCursor'): return self.fn_Interface_setMouseCursor
      else: return self.fn_unset_Interface_setMouseCursor
   @setMouseCursor.setter
   def setMouseCursor(self, value):
      self.fn_Interface_setMouseCursor = value
      lib.Instance_setMethod(self.impl, "SetMouseCursor".encode('u8'), cb_Interface_setMouseCursor)

   def fn_unset_Interface_setMousePosition(self, x, y):
      return lib.Interface_setMousePosition(self.impl, x, y)

   @property
   def setMousePosition(self):
      if hasattr(self, 'fn_Interface_setMousePosition'): return self.fn_Interface_setMousePosition
      else: return self.fn_unset_Interface_setMousePosition
   @setMousePosition.setter
   def setMousePosition(self, value):
      self.fn_Interface_setMousePosition = value
      lib.Instance_setMethod(self.impl, "SetMousePosition".encode('u8'), cb_Interface_setMousePosition)

   def fn_unset_Interface_setMouseRange(self, window, box):
      return lib.Interface_setMouseRange(self.impl, ffi.NULL if window is None else window.impl, ffi.NULL if box is None else box.impl)

   @property
   def setMouseRange(self):
      if hasattr(self, 'fn_Interface_setMouseRange'): return self.fn_Interface_setMouseRange
      else: return self.fn_unset_Interface_setMouseRange
   @setMouseRange.setter
   def setMouseRange(self, value):
      self.fn_Interface_setMouseRange = value
      lib.Instance_setMethod(self.impl, "SetMouseRange".encode('u8'), cb_Interface_setMouseRange)

   def fn_unset_Interface_setRootWindowCaption(self, window, name):
      return lib.Interface_setRootWindowCaption(self.impl, ffi.NULL if window is None else window.impl, name)

   @property
   def setRootWindowCaption(self):
      if hasattr(self, 'fn_Interface_setRootWindowCaption'): return self.fn_Interface_setRootWindowCaption
      else: return self.fn_unset_Interface_setRootWindowCaption
   @setRootWindowCaption.setter
   def setRootWindowCaption(self, value):
      self.fn_Interface_setRootWindowCaption = value
      lib.Instance_setMethod(self.impl, "SetRootWindowCaption".encode('u8'), cb_Interface_setRootWindowCaption)

   def fn_unset_Interface_setRootWindowColor(self, window):
      return lib.Interface_setRootWindowColor(self.impl, ffi.NULL if window is None else window.impl)

   @property
   def setRootWindowColor(self):
      if hasattr(self, 'fn_Interface_setRootWindowColor'): return self.fn_Interface_setRootWindowColor
      else: return self.fn_unset_Interface_setRootWindowColor
   @setRootWindowColor.setter
   def setRootWindowColor(self, value):
      self.fn_Interface_setRootWindowColor = value
      lib.Instance_setMethod(self.impl, "SetRootWindowColor".encode('u8'), cb_Interface_setRootWindowColor)

   def fn_unset_Interface_setRootWindowState(self, window, state, visible):
      return lib.Interface_setRootWindowState(self.impl, ffi.NULL if window is None else window.impl, state, visible)

   @property
   def setRootWindowState(self):
      if hasattr(self, 'fn_Interface_setRootWindowState'): return self.fn_Interface_setRootWindowState
      else: return self.fn_unset_Interface_setRootWindowState
   @setRootWindowState.setter
   def setRootWindowState(self, value):
      self.fn_Interface_setRootWindowState = value
      lib.Instance_setMethod(self.impl, "SetRootWindowState".encode('u8'), cb_Interface_setRootWindowState)

   def fn_unset_Interface_setTimerResolution(self, hertz):
      return lib.Interface_setTimerResolution(self.impl, hertz)

   @property
   def setTimerResolution(self):
      if hasattr(self, 'fn_Interface_setTimerResolution'): return self.fn_Interface_setTimerResolution
      else: return self.fn_unset_Interface_setTimerResolution
   @setTimerResolution.setter
   def setTimerResolution(self, value):
      self.fn_Interface_setTimerResolution = value
      lib.Instance_setMethod(self.impl, "SetTimerResolution".encode('u8'), cb_Interface_setTimerResolution)

   def fn_unset_Interface_startMoving(self, window, x, y, fromKeyBoard):
      return lib.Interface_startMoving(self.impl, ffi.NULL if window is None else window.impl, x, y, fromKeyBoard)

   @property
   def startMoving(self):
      if hasattr(self, 'fn_Interface_startMoving'): return self.fn_Interface_startMoving
      else: return self.fn_unset_Interface_startMoving
   @startMoving.setter
   def startMoving(self, value):
      self.fn_Interface_startMoving = value
      lib.Instance_setMethod(self.impl, "StartMoving".encode('u8'), cb_Interface_startMoving)

   def fn_unset_Interface_stopMoving(self, window):
      return lib.Interface_stopMoving(self.impl, ffi.NULL if window is None else window.impl)

   @property
   def stopMoving(self):
      if hasattr(self, 'fn_Interface_stopMoving'): return self.fn_Interface_stopMoving
      else: return self.fn_unset_Interface_stopMoving
   @stopMoving.setter
   def stopMoving(self, value):
      self.fn_Interface_stopMoving = value
      lib.Instance_setMethod(self.impl, "StopMoving".encode('u8'), cb_Interface_stopMoving)

   def fn_unset_Interface_terminate(self):
      return lib.Interface_terminate(self.impl)

   @property
   def terminate(self):
      if hasattr(self, 'fn_Interface_terminate'): return self.fn_Interface_terminate
      else: return self.fn_unset_Interface_terminate
   @terminate.setter
   def terminate(self, value):
      self.fn_Interface_terminate = value
      lib.Instance_setMethod(self.impl, "Terminate".encode('u8'), cb_Interface_terminate)

   def translateKey(key, shift):
      if key is not None and not isinstance(key, Key): key = Key(key)
      if key is None: key = ffi.NULL
      return lib.Interface_translateKey(key, shift)

   def fn_unset_Interface_unloadClipboard(self, clipBoard):
      return lib.Interface_unloadClipboard(self.impl, ffi.NULL if clipBoard is None else clipBoard.impl)

   @property
   def unloadClipboard(self):
      if hasattr(self, 'fn_Interface_unloadClipboard'): return self.fn_Interface_unloadClipboard
      else: return self.fn_unset_Interface_unloadClipboard
   @unloadClipboard.setter
   def unloadClipboard(self, value):
      self.fn_Interface_unloadClipboard = value
      lib.Instance_setMethod(self.impl, "UnloadClipboard".encode('u8'), cb_Interface_unloadClipboard)

   def fn_unset_Interface_unlock(self, window):
      return lib.Interface_unlock(self.impl, ffi.NULL if window is None else window.impl)

   @property
   def unlock(self):
      if hasattr(self, 'fn_Interface_unlock'): return self.fn_Interface_unlock
      else: return self.fn_unset_Interface_unlock
   @unlock.setter
   def unlock(self, value):
      self.fn_Interface_unlock = value
      lib.Instance_setMethod(self.impl, "Unlock".encode('u8'), cb_Interface_unlock)

   def fn_unset_Interface_updateRootWindow(self, window):
      return lib.Interface_updateRootWindow(self.impl, ffi.NULL if window is None else window.impl)

   @property
   def updateRootWindow(self):
      if hasattr(self, 'fn_Interface_updateRootWindow'): return self.fn_Interface_updateRootWindow
      else: return self.fn_unset_Interface_updateRootWindow
   @updateRootWindow.setter
   def updateRootWindow(self, value):
      self.fn_Interface_updateRootWindow = value
      lib.Instance_setMethod(self.impl, "UpdateRootWindow".encode('u8'), cb_Interface_updateRootWindow)

   def fn_unset_Interface_wait(self):
      return lib.Interface_wait(self.impl)

   @property
   def wait(self):
      if hasattr(self, 'fn_Interface_wait'): return self.fn_Interface_wait
      else: return self.fn_unset_Interface_wait
   @wait.setter
   def wait(self, value):
      self.fn_Interface_wait = value
      lib.Instance_setMethod(self.impl, "Wait".encode('u8'), cb_Interface_wait)

   def writeKeyedText(surface, x, y, text, hotKey):
      if surface is not None and not isinstance(surface, Surface): surface = Surface(surface)
      surface = ffi.NULL if surface is None else surface.impl
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      if hotKey is not None and not isinstance(hotKey, Key): hotKey = Key(hotKey)
      if hotKey is None: hotKey = ffi.NULL
      lib.Interface_writeKeyedText(surface, x, y, text, hotKey)

   def writeKeyedTextDisabled(surface, x, y, text, hotKey, disabled):
      if surface is not None and not isinstance(surface, Surface): surface = Surface(surface)
      surface = ffi.NULL if surface is None else surface.impl
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      if hotKey is not None and not isinstance(hotKey, Key): hotKey = Key(hotKey)
      if hotKey is None: hotKey = ffi.NULL
      lib.Interface_writeKeyedTextDisabled(surface, x, y, text, hotKey, disabled)

class Joystick(Struct):
   def __init__(self, x = 0, y = 0, z = 0, rx = 0, ry = 0, rz = 0, buttons = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_Joystick *", impl)
      else:
         self.impl = ffi.new("eC_Joystick *", {
                                'x' : x,
                                'y' : y,
                                'z' : z,
                                'rx' : rx,
                                'ry' : ry,
                                'rz' : rz,
                                'buttons' : buttons
                             })

   @property
   def x(self): return self.impl.x
   @x.setter
   def x(self, value): self.impl.x = value

   @property
   def y(self): return self.impl.y
   @y.setter
   def y(self, value): self.impl.y = value

   @property
   def z(self): return self.impl.z
   @z.setter
   def z(self, value): self.impl.z = value

   @property
   def rx(self): return self.impl.rx
   @rx.setter
   def rx(self, value): self.impl.rx = value

   @property
   def ry(self): return self.impl.ry
   @ry.setter
   def ry(self, value): self.impl.ry = value

   @property
   def rz(self): return self.impl.rz
   @rz.setter
   def rz(self, value): self.impl.rz = value

   @property
   def buttons(self): return self.impl.buttons
   @buttons.setter
   def buttons(self, value): self.impl.buttons = value

class KeyCode(Key):
   escape            = Key(impl = lib.KeyCode_escape)
   k1                = Key(impl = lib.KeyCode_k1)
   bang              = Key(impl = lib.KeyCode_bang)
   k2                = Key(impl = lib.KeyCode_k2)
   commercial        = Key(impl = lib.KeyCode_commercial)
   k3                = Key(impl = lib.KeyCode_k3)
   pound             = Key(impl = lib.KeyCode_pound)
   k4                = Key(impl = lib.KeyCode_k4)
   dollar            = Key(impl = lib.KeyCode_dollar)
   k5                = Key(impl = lib.KeyCode_k5)
   percent           = Key(impl = lib.KeyCode_percent)
   k6                = Key(impl = lib.KeyCode_k6)
   circumflex        = Key(impl = lib.KeyCode_circumflex)
   k7                = Key(impl = lib.KeyCode_k7)
   ampersand         = Key(impl = lib.KeyCode_ampersand)
   k8                = Key(impl = lib.KeyCode_k8)
   star              = Key(impl = lib.KeyCode_star)
   k9                = Key(impl = lib.KeyCode_k9)
   leftParanthesis   = Key(impl = lib.KeyCode_leftParanthesis)
   k0                = Key(impl = lib.KeyCode_k0)
   rightParanthesis  = Key(impl = lib.KeyCode_rightParanthesis)
   minus             = Key(impl = lib.KeyCode_minus)
   underscore        = Key(impl = lib.KeyCode_underscore)
   equal             = Key(impl = lib.KeyCode_equal)
   plus              = Key(impl = lib.KeyCode_plus)
   backSpace         = Key(impl = lib.KeyCode_backSpace)
   tab               = Key(impl = lib.KeyCode_tab)
   q                 = Key(impl = lib.KeyCode_q)
   w                 = Key(impl = lib.KeyCode_w)
   e                 = Key(impl = lib.KeyCode_e)
   r                 = Key(impl = lib.KeyCode_r)
   t                 = Key(impl = lib.KeyCode_t)
   y                 = Key(impl = lib.KeyCode_y)
   u                 = Key(impl = lib.KeyCode_u)
   i                 = Key(impl = lib.KeyCode_i)
   o                 = Key(impl = lib.KeyCode_o)
   p                 = Key(impl = lib.KeyCode_p)
   leftBracket       = Key(impl = lib.KeyCode_leftBracket)
   rightBracket      = Key(impl = lib.KeyCode_rightBracket)
   enter             = Key(impl = lib.KeyCode_enter)
   leftControl       = Key(impl = lib.KeyCode_leftControl)
   a                 = Key(impl = lib.KeyCode_a)
   s                 = Key(impl = lib.KeyCode_s)
   d                 = Key(impl = lib.KeyCode_d)
   f                 = Key(impl = lib.KeyCode_f)
   g                 = Key(impl = lib.KeyCode_g)
   h                 = Key(impl = lib.KeyCode_h)
   j                 = Key(impl = lib.KeyCode_j)
   k                 = Key(impl = lib.KeyCode_k)
   l                 = Key(impl = lib.KeyCode_l)
   semicolon         = Key(impl = lib.KeyCode_semicolon)
   colon             = Key(impl = lib.KeyCode_colon)
   quote             = Key(impl = lib.KeyCode_quote)
   doubleQuote       = Key(impl = lib.KeyCode_doubleQuote)
   tilde             = Key(impl = lib.KeyCode_tilde)
   backQuote         = Key(impl = lib.KeyCode_backQuote)
   leftShift         = Key(impl = lib.KeyCode_leftShift)
   backSlash         = Key(impl = lib.KeyCode_backSlash)
   pipe              = Key(impl = lib.KeyCode_pipe)
   z                 = Key(impl = lib.KeyCode_z)
   x                 = Key(impl = lib.KeyCode_x)
   c                 = Key(impl = lib.KeyCode_c)
   v                 = Key(impl = lib.KeyCode_v)
   b                 = Key(impl = lib.KeyCode_b)
   n                 = Key(impl = lib.KeyCode_n)
   m                 = Key(impl = lib.KeyCode_m)
   comma             = Key(impl = lib.KeyCode_comma)
   smallerThan       = Key(impl = lib.KeyCode_smallerThan)
   period            = Key(impl = lib.KeyCode_period)
   greaterThan       = Key(impl = lib.KeyCode_greaterThan)
   slash             = Key(impl = lib.KeyCode_slash)
   questionMark      = Key(impl = lib.KeyCode_questionMark)
   rightShift        = Key(impl = lib.KeyCode_rightShift)
   keyPadStar        = Key(impl = lib.KeyCode_keyPadStar)
   leftAlt           = Key(impl = lib.KeyCode_leftAlt)
   space             = Key(impl = lib.KeyCode_space)
   capsLock          = Key(impl = lib.KeyCode_capsLock)
   f1                = Key(impl = lib.KeyCode_f1)
   f2                = Key(impl = lib.KeyCode_f2)
   f3                = Key(impl = lib.KeyCode_f3)
   f4                = Key(impl = lib.KeyCode_f4)
   f5                = Key(impl = lib.KeyCode_f5)
   f6                = Key(impl = lib.KeyCode_f6)
   f7                = Key(impl = lib.KeyCode_f7)
   f8                = Key(impl = lib.KeyCode_f8)
   f9                = Key(impl = lib.KeyCode_f9)
   f10               = Key(impl = lib.KeyCode_f10)
   numLock           = Key(impl = lib.KeyCode_numLock)
   scrollLock        = Key(impl = lib.KeyCode_scrollLock)
   keyPadHome        = Key(impl = lib.KeyCode_keyPadHome)
   keyPad7           = Key(impl = lib.KeyCode_keyPad7)
   keyPadUp          = Key(impl = lib.KeyCode_keyPadUp)
   keyPad8           = Key(impl = lib.KeyCode_keyPad8)
   keyPadPageUp      = Key(impl = lib.KeyCode_keyPadPageUp)
   keyPad9           = Key(impl = lib.KeyCode_keyPad9)
   keyPadMinus       = Key(impl = lib.KeyCode_keyPadMinus)
   keyPadLeft        = Key(impl = lib.KeyCode_keyPadLeft)
   keyPad4           = Key(impl = lib.KeyCode_keyPad4)
   keyPad5           = Key(impl = lib.KeyCode_keyPad5)
   keyPadRight       = Key(impl = lib.KeyCode_keyPadRight)
   keyPad6           = Key(impl = lib.KeyCode_keyPad6)
   keyPadPlus        = Key(impl = lib.KeyCode_keyPadPlus)
   keyPadEnd         = Key(impl = lib.KeyCode_keyPadEnd)
   keyPad1           = Key(impl = lib.KeyCode_keyPad1)
   keyPadDown        = Key(impl = lib.KeyCode_keyPadDown)
   keyPad2           = Key(impl = lib.KeyCode_keyPad2)
   keyPadPageDown    = Key(impl = lib.KeyCode_keyPadPageDown)
   keyPad3           = Key(impl = lib.KeyCode_keyPad3)
   keyPadInsert      = Key(impl = lib.KeyCode_keyPadInsert)
   keyPad0           = Key(impl = lib.KeyCode_keyPad0)
   keyPadDelete      = Key(impl = lib.KeyCode_keyPadDelete)
   f11               = Key(impl = lib.KeyCode_f11)
   f12               = Key(impl = lib.KeyCode_f12)
   keyPadEnter       = Key(impl = lib.KeyCode_keyPadEnter)
   rightControl      = Key(impl = lib.KeyCode_rightControl)
   keyPadSlash       = Key(impl = lib.KeyCode_keyPadSlash)
   printScreen       = Key(impl = lib.KeyCode_printScreen)
   rightAlt          = Key(impl = lib.KeyCode_rightAlt)
   pauseBreak        = Key(impl = lib.KeyCode_pauseBreak)
   home              = Key(impl = lib.KeyCode_home)
   up                = Key(impl = lib.KeyCode_up)
   pageUp            = Key(impl = lib.KeyCode_pageUp)
   left              = Key(impl = lib.KeyCode_left)
   right             = Key(impl = lib.KeyCode_right)
   end               = Key(impl = lib.KeyCode_end)
   down              = Key(impl = lib.KeyCode_down)
   pageDown          = Key(impl = lib.KeyCode_pageDown)
   insert            = Key(impl = lib.KeyCode_insert)
   _del              = Key(impl = lib.KeyCode_del)
   shift             = Key(impl = lib.KeyCode_shift)
   alt               = Key(impl = lib.KeyCode_alt)
   control           = Key(impl = lib.KeyCode_control)
   wheelUp           = Key(impl = lib.KeyCode_wheelUp)
   wheelDown         = Key(impl = lib.KeyCode_wheelDown)
   hotKey            = Key(impl = lib.KeyCode_hotKey)
   defaultKey        = Key(impl = lib.KeyCode_defaultKey)
   capsState         = Key(impl = lib.KeyCode_capsState)
   numState          = Key(impl = lib.KeyCode_numState)
   scrollState       = Key(impl = lib.KeyCode_scrollState)
   play              = Key(impl = lib.KeyCode_play)
   record            = Key(impl = lib.KeyCode_record)
   pause             = Key(impl = lib.KeyCode_pause)
   rewind            = Key(impl = lib.KeyCode_rewind)
   fastForward       = Key(impl = lib.KeyCode_fastForward)
   previousTrack     = Key(impl = lib.KeyCode_previousTrack)
   nextTrack         = Key(impl = lib.KeyCode_nextTrack)
   stop              = Key(impl = lib.KeyCode_stop)
   eject             = Key(impl = lib.KeyCode_eject)
   volumeUp          = Key(impl = lib.KeyCode_volumeUp)
   volumeDown        = Key(impl = lib.KeyCode_volumeDown)
   mute              = Key(impl = lib.KeyCode_mute)
   remoteHome        = Key(impl = lib.KeyCode_remoteHome)
   back              = Key(impl = lib.KeyCode_back)
   menu1             = Key(impl = lib.KeyCode_menu1)
   menu2             = Key(impl = lib.KeyCode_menu2)
   menu3             = Key(impl = lib.KeyCode_menu3)
   menu4             = Key(impl = lib.KeyCode_menu4)
   select            = Key(impl = lib.KeyCode_select)
   bassBoost         = Key(impl = lib.KeyCode_bassBoost)
   bassDown          = Key(impl = lib.KeyCode_bassDown)
   bassUp            = Key(impl = lib.KeyCode_bassUp)
   browserBackward   = Key(impl = lib.KeyCode_browserBackward)
   browserFavorites  = Key(impl = lib.KeyCode_browserFavorites)
   browserForward    = Key(impl = lib.KeyCode_browserForward)
   browserHome       = Key(impl = lib.KeyCode_browserHome)
   browserRefresh    = Key(impl = lib.KeyCode_browserRefresh)
   browserSearch     = Key(impl = lib.KeyCode_browserSearch)
   browserStop       = Key(impl = lib.KeyCode_browserStop)
   launchApp1        = Key(impl = lib.KeyCode_launchApp1)
   launchApp2        = Key(impl = lib.KeyCode_launchApp2)
   launchMail        = Key(impl = lib.KeyCode_launchMail)
   launchMediaSelect = Key(impl = lib.KeyCode_launchMediaSelect)
   micVolumeDown     = Key(impl = lib.KeyCode_micVolumeDown)
   micMute           = Key(impl = lib.KeyCode_micMute)
   micVolumeUp       = Key(impl = lib.KeyCode_micVolumeUp)
   trebleDown        = Key(impl = lib.KeyCode_trebleDown)
   trebleUp          = Key(impl = lib.KeyCode_trebleUp)

class MiddleAnchorValue(Struct):
   def __init__(self, type = None, distance = None, percent = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_MiddleAnchorValue *", impl)
      else:
         if isinstance(type, tuple):
            __tuple = type
            type = 0
            if len(__tuple) > 0: type     = __tuple[0]
            if len(__tuple) > 1: distance = __tuple[1]
         elif isinstance(type, MinMaxValue):
            self.impl = ffi.new("eC_MiddleAnchorValue *")
            lib.MiddleAnchorValue_from_MinMaxValue(self.impl, type.impl)
            return
         elif isinstance(type, int):
            self.impl = ffi.new("eC_MiddleAnchorValue *")
            lib.MiddleAnchorValue_from_int(self.impl, type)
            return
         elif isinstance(type, float):
            self.impl = ffi.new("eC_MiddleAnchorValue *")
            lib.MiddleAnchorValue_from_double(self.impl, type)
            return
         __members = { }
         if type is not None:     __members['type']     = type
         if distance is not None: __members['distance'] = distance
         if percent is not None:  __members['percent']  = percent
         self.impl = ffi.new("eC_MiddleAnchorValue *", __members)

   @property
   def type(self): return self.impl.type
   @type.setter
   def type(self, value): self.impl.type = value

   @property
   def distance(self): return self.impl.distance
   @distance.setter
   def distance(self, value): self.impl.distance = value

   @property
   def percent(self): return self.impl.percent
   @percent.setter
   def percent(self, value): self.impl.percent = value

   # def MiddleAnchorValue_to_MinMaxValue(self): return MinMaxValue(lib.MiddleAnchorValue_to_MinMaxValue(self.impl))

   # here is an unhandled conversion: MiddleAnchorValue::MinMaxValue (StructClass 2 UnitClass)
   # MiddleAnchorValue_to_MinMaxValue
   # MiddleAnchorValue_from_MinMaxValue

   def __int__(self): return lib.MiddleAnchorValue_to_int(self.impl)

   def __float__(self): return lib.MiddleAnchorValue_to_double(self.impl)

class Modifiers(pyBaseClass):
   def __init__(self, shift = False, ctrl = False, alt = False, cmd = False, left = False, middle = False, right = False, isActivate = False, isSideEffect = False, closingDropDown = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(shift, Modifiers):
         self.impl = shift.impl
      else:
         self.impl = (
            (shift           << lib.MODIFIERS_shift_SHIFT)           |
            (ctrl            << lib.MODIFIERS_ctrl_SHIFT)            |
            (alt             << lib.MODIFIERS_alt_SHIFT)             |
            (cmd             << lib.MODIFIERS_cmd_SHIFT)             |
            (left            << lib.MODIFIERS_left_SHIFT)            |
            (middle          << lib.MODIFIERS_middle_SHIFT)          |
            (right           << lib.MODIFIERS_right_SHIFT)           |
            (isActivate      << lib.MODIFIERS_isActivate_SHIFT)      |
            (isSideEffect    << lib.MODIFIERS_isSideEffect_SHIFT)    |
            (closingDropDown << lib.MODIFIERS_closingDropDown_SHIFT) )

   @property
   def shift(self): return ((((self.impl)) & lib.MODIFIERS_shift_MASK) >> lib.MODIFIERS_shift_SHIFT)
   @shift.setter
   def shift(self, value): self.impl = ((self.impl) & ~(lib.MODIFIERS_shift_MASK)) | (((value)) << lib.MODIFIERS_shift_SHIFT)

   @property
   def ctrl(self): return ((((self.impl)) & lib.MODIFIERS_ctrl_MASK) >> lib.MODIFIERS_ctrl_SHIFT)
   @ctrl.setter
   def ctrl(self, value): self.impl = ((self.impl) & ~(lib.MODIFIERS_ctrl_MASK)) | (((value)) << lib.MODIFIERS_ctrl_SHIFT)

   @property
   def alt(self): return ((((self.impl)) & lib.MODIFIERS_alt_MASK) >> lib.MODIFIERS_alt_SHIFT)
   @alt.setter
   def alt(self, value): self.impl = ((self.impl) & ~(lib.MODIFIERS_alt_MASK)) | (((value)) << lib.MODIFIERS_alt_SHIFT)

   @property
   def cmd(self): return ((((self.impl)) & lib.MODIFIERS_cmd_MASK) >> lib.MODIFIERS_cmd_SHIFT)
   @cmd.setter
   def cmd(self, value): self.impl = ((self.impl) & ~(lib.MODIFIERS_cmd_MASK)) | (((value)) << lib.MODIFIERS_cmd_SHIFT)

   @property
   def left(self): return ((((self.impl)) & lib.MODIFIERS_left_MASK) >> lib.MODIFIERS_left_SHIFT)
   @left.setter
   def left(self, value): self.impl = ((self.impl) & ~(lib.MODIFIERS_left_MASK)) | (((value)) << lib.MODIFIERS_left_SHIFT)

   @property
   def middle(self): return ((((self.impl)) & lib.MODIFIERS_middle_MASK) >> lib.MODIFIERS_middle_SHIFT)
   @middle.setter
   def middle(self, value): self.impl = ((self.impl) & ~(lib.MODIFIERS_middle_MASK)) | (((value)) << lib.MODIFIERS_middle_SHIFT)

   @property
   def right(self): return ((((self.impl)) & lib.MODIFIERS_right_MASK) >> lib.MODIFIERS_right_SHIFT)
   @right.setter
   def right(self, value): self.impl = ((self.impl) & ~(lib.MODIFIERS_right_MASK)) | (((value)) << lib.MODIFIERS_right_SHIFT)

   @property
   def isActivate(self): return ((((self.impl)) & lib.MODIFIERS_isActivate_MASK) >> lib.MODIFIERS_isActivate_SHIFT)
   @isActivate.setter
   def isActivate(self, value): self.impl = ((self.impl) & ~(lib.MODIFIERS_isActivate_MASK)) | (((value)) << lib.MODIFIERS_isActivate_SHIFT)

   @property
   def isSideEffect(self): return ((((self.impl)) & lib.MODIFIERS_isSideEffect_MASK) >> lib.MODIFIERS_isSideEffect_SHIFT)
   @isSideEffect.setter
   def isSideEffect(self, value): self.impl = ((self.impl) & ~(lib.MODIFIERS_isSideEffect_MASK)) | (((value)) << lib.MODIFIERS_isSideEffect_SHIFT)

   @property
   def closingDropDown(self): return ((((self.impl)) & lib.MODIFIERS_closingDropDown_MASK) >> lib.MODIFIERS_closingDropDown_SHIFT)
   @closingDropDown.setter
   def closingDropDown(self, value): self.impl = ((self.impl) & ~(lib.MODIFIERS_closingDropDown_MASK)) | (((value)) << lib.MODIFIERS_closingDropDown_SHIFT)

class MouseButtons(pyBaseClass):
   def __init__(self, left = False, right = False, middle = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(left, MouseButtons):
         self.impl = left.impl
      else:
         if isinstance(left, tuple):
            __tuple = left
            left = False
            if len(__tuple) > 0: left = __tuple[0]
            if len(__tuple) > 1: right = __tuple[1]
            if len(__tuple) > 2: middle = __tuple[2]
         self.impl = (
            (left   << lib.MOUSEBUTTONS_left_SHIFT)   |
            (right  << lib.MOUSEBUTTONS_right_SHIFT)  |
            (middle << lib.MOUSEBUTTONS_middle_SHIFT) )

   @property
   def left(self): return ((((self.impl)) & lib.MOUSEBUTTONS_left_MASK) >> lib.MOUSEBUTTONS_left_SHIFT)
   @left.setter
   def left(self, value): self.impl = ((self.impl) & ~(lib.MOUSEBUTTONS_left_MASK)) | (((value)) << lib.MOUSEBUTTONS_left_SHIFT)

   @property
   def right(self): return ((((self.impl)) & lib.MOUSEBUTTONS_right_MASK) >> lib.MOUSEBUTTONS_right_SHIFT)
   @right.setter
   def right(self, value): self.impl = ((self.impl) & ~(lib.MOUSEBUTTONS_right_MASK)) | (((value)) << lib.MOUSEBUTTONS_right_SHIFT)

   @property
   def middle(self): return ((((self.impl)) & lib.MOUSEBUTTONS_middle_MASK) >> lib.MOUSEBUTTONS_middle_SHIFT)
   @middle.setter
   def middle(self, value): self.impl = ((self.impl) & ~(lib.MOUSEBUTTONS_middle_MASK)) | (((value)) << lib.MOUSEBUTTONS_middle_SHIFT)

class MultiLineString:
   def __init__(self, impl = None):
      String.__init__(self, impl = impl)
      if impl is not None: self.impl = impl
      else: self.impl = ffi.NULL

class Percentage(pyBaseClass):
   def __init__(self, impl = 0):
      self.impl = impl

Percentage.buc = Percentage

class PredefinedKey(Key):
   alt0           = Key(impl = lib.PredefinedKey_alt0)
   alt1           = Key(impl = lib.PredefinedKey_alt1)
   alt2           = Key(impl = lib.PredefinedKey_alt2)
   alt3           = Key(impl = lib.PredefinedKey_alt3)
   alt4           = Key(impl = lib.PredefinedKey_alt4)
   alt5           = Key(impl = lib.PredefinedKey_alt5)
   alt6           = Key(impl = lib.PredefinedKey_alt6)
   alt7           = Key(impl = lib.PredefinedKey_alt7)
   alt8           = Key(impl = lib.PredefinedKey_alt8)
   alt9           = Key(impl = lib.PredefinedKey_alt9)
   altA           = Key(impl = lib.PredefinedKey_altA)
   altB           = Key(impl = lib.PredefinedKey_altB)
   altC           = Key(impl = lib.PredefinedKey_altC)
   altD           = Key(impl = lib.PredefinedKey_altD)
   altE           = Key(impl = lib.PredefinedKey_altE)
   altF           = Key(impl = lib.PredefinedKey_altF)
   altG           = Key(impl = lib.PredefinedKey_altG)
   altH           = Key(impl = lib.PredefinedKey_altH)
   altI           = Key(impl = lib.PredefinedKey_altI)
   altJ           = Key(impl = lib.PredefinedKey_altJ)
   altK           = Key(impl = lib.PredefinedKey_altK)
   altL           = Key(impl = lib.PredefinedKey_altL)
   altM           = Key(impl = lib.PredefinedKey_altM)
   altN           = Key(impl = lib.PredefinedKey_altN)
   altO           = Key(impl = lib.PredefinedKey_altO)
   altP           = Key(impl = lib.PredefinedKey_altP)
   altQ           = Key(impl = lib.PredefinedKey_altQ)
   altR           = Key(impl = lib.PredefinedKey_altR)
   altS           = Key(impl = lib.PredefinedKey_altS)
   altT           = Key(impl = lib.PredefinedKey_altT)
   altU           = Key(impl = lib.PredefinedKey_altU)
   altV           = Key(impl = lib.PredefinedKey_altV)
   altW           = Key(impl = lib.PredefinedKey_altW)
   altX           = Key(impl = lib.PredefinedKey_altX)
   altY           = Key(impl = lib.PredefinedKey_altY)
   altZ           = Key(impl = lib.PredefinedKey_altZ)
   altF1          = Key(impl = lib.PredefinedKey_altF1)
   altF2          = Key(impl = lib.PredefinedKey_altF2)
   altF3          = Key(impl = lib.PredefinedKey_altF3)
   altF4          = Key(impl = lib.PredefinedKey_altF4)
   altF5          = Key(impl = lib.PredefinedKey_altF5)
   altF6          = Key(impl = lib.PredefinedKey_altF6)
   altF7          = Key(impl = lib.PredefinedKey_altF7)
   altF8          = Key(impl = lib.PredefinedKey_altF8)
   altF9          = Key(impl = lib.PredefinedKey_altF9)
   altF10         = Key(impl = lib.PredefinedKey_altF10)
   altF11         = Key(impl = lib.PredefinedKey_altF11)
   altF12         = Key(impl = lib.PredefinedKey_altF12)
   altLeft        = Key(impl = lib.PredefinedKey_altLeft)
   altRight       = Key(impl = lib.PredefinedKey_altRight)
   altUp          = Key(impl = lib.PredefinedKey_altUp)
   altDown        = Key(impl = lib.PredefinedKey_altDown)
   altEnter       = Key(impl = lib.PredefinedKey_altEnter)
   altKeyPadEnter = Key(impl = lib.PredefinedKey_altKeyPadEnter)
   altHome        = Key(impl = lib.PredefinedKey_altHome)
   altEnd         = Key(impl = lib.PredefinedKey_altEnd)
   altMinus       = Key(impl = lib.PredefinedKey_altMinus)
   altSpace       = Key(impl = lib.PredefinedKey_altSpace)
   ctrl0          = Key(impl = lib.PredefinedKey_ctrl0)
   ctrl1          = Key(impl = lib.PredefinedKey_ctrl1)
   ctrl2          = Key(impl = lib.PredefinedKey_ctrl2)
   ctrl3          = Key(impl = lib.PredefinedKey_ctrl3)
   ctrl4          = Key(impl = lib.PredefinedKey_ctrl4)
   ctrl5          = Key(impl = lib.PredefinedKey_ctrl5)
   ctrl6          = Key(impl = lib.PredefinedKey_ctrl6)
   ctrl7          = Key(impl = lib.PredefinedKey_ctrl7)
   ctrl8          = Key(impl = lib.PredefinedKey_ctrl8)
   ctrl9          = Key(impl = lib.PredefinedKey_ctrl9)
   ctrlA          = Key(impl = lib.PredefinedKey_ctrlA)
   ctrlB          = Key(impl = lib.PredefinedKey_ctrlB)
   ctrlC          = Key(impl = lib.PredefinedKey_ctrlC)
   ctrlD          = Key(impl = lib.PredefinedKey_ctrlD)
   ctrlE          = Key(impl = lib.PredefinedKey_ctrlE)
   ctrlF          = Key(impl = lib.PredefinedKey_ctrlF)
   ctrlG          = Key(impl = lib.PredefinedKey_ctrlG)
   ctrlH          = Key(impl = lib.PredefinedKey_ctrlH)
   ctrlI          = Key(impl = lib.PredefinedKey_ctrlI)
   ctrlJ          = Key(impl = lib.PredefinedKey_ctrlJ)
   ctrlK          = Key(impl = lib.PredefinedKey_ctrlK)
   ctrlL          = Key(impl = lib.PredefinedKey_ctrlL)
   ctrlM          = Key(impl = lib.PredefinedKey_ctrlM)
   ctrlN          = Key(impl = lib.PredefinedKey_ctrlN)
   ctrlO          = Key(impl = lib.PredefinedKey_ctrlO)
   ctrlP          = Key(impl = lib.PredefinedKey_ctrlP)
   ctrlQ          = Key(impl = lib.PredefinedKey_ctrlQ)
   ctrlR          = Key(impl = lib.PredefinedKey_ctrlR)
   ctrlS          = Key(impl = lib.PredefinedKey_ctrlS)
   ctrlT          = Key(impl = lib.PredefinedKey_ctrlT)
   ctrlU          = Key(impl = lib.PredefinedKey_ctrlU)
   ctrlV          = Key(impl = lib.PredefinedKey_ctrlV)
   ctrlW          = Key(impl = lib.PredefinedKey_ctrlW)
   ctrlX          = Key(impl = lib.PredefinedKey_ctrlX)
   ctrlY          = Key(impl = lib.PredefinedKey_ctrlY)
   ctrlZ          = Key(impl = lib.PredefinedKey_ctrlZ)
   ctrlF1         = Key(impl = lib.PredefinedKey_ctrlF1)
   ctrlF2         = Key(impl = lib.PredefinedKey_ctrlF2)
   ctrlF3         = Key(impl = lib.PredefinedKey_ctrlF3)
   ctrlF4         = Key(impl = lib.PredefinedKey_ctrlF4)
   ctrlF5         = Key(impl = lib.PredefinedKey_ctrlF5)
   ctrlF6         = Key(impl = lib.PredefinedKey_ctrlF6)
   ctrlF7         = Key(impl = lib.PredefinedKey_ctrlF7)
   ctrlF8         = Key(impl = lib.PredefinedKey_ctrlF8)
   ctrlF9         = Key(impl = lib.PredefinedKey_ctrlF9)
   ctrlF10        = Key(impl = lib.PredefinedKey_ctrlF10)
   ctrlF11        = Key(impl = lib.PredefinedKey_ctrlF11)
   ctrlF12        = Key(impl = lib.PredefinedKey_ctrlF12)
   ctrlLeft       = Key(impl = lib.PredefinedKey_ctrlLeft)
   ctrlRight      = Key(impl = lib.PredefinedKey_ctrlRight)
   ctrlUp         = Key(impl = lib.PredefinedKey_ctrlUp)
   ctrlDown       = Key(impl = lib.PredefinedKey_ctrlDown)
   ctrlEnter      = Key(impl = lib.PredefinedKey_ctrlEnter)
   ctrlHome       = Key(impl = lib.PredefinedKey_ctrlHome)
   ctrlEnd        = Key(impl = lib.PredefinedKey_ctrlEnd)
   ctrlPageUp     = Key(impl = lib.PredefinedKey_ctrlPageUp)
   ctrlPageDown   = Key(impl = lib.PredefinedKey_ctrlPageDown)
   ctrlInsert     = Key(impl = lib.PredefinedKey_ctrlInsert)
   ctrlSpace      = Key(impl = lib.PredefinedKey_ctrlSpace)
   shiftTab       = Key(impl = lib.PredefinedKey_shiftTab)
   shiftF1        = Key(impl = lib.PredefinedKey_shiftF1)
   shiftF2        = Key(impl = lib.PredefinedKey_shiftF2)
   shiftF3        = Key(impl = lib.PredefinedKey_shiftF3)
   shiftF4        = Key(impl = lib.PredefinedKey_shiftF4)
   shiftF5        = Key(impl = lib.PredefinedKey_shiftF5)
   shiftF6        = Key(impl = lib.PredefinedKey_shiftF6)
   shiftF7        = Key(impl = lib.PredefinedKey_shiftF7)
   shiftF8        = Key(impl = lib.PredefinedKey_shiftF8)
   shiftF9        = Key(impl = lib.PredefinedKey_shiftF9)
   shiftF10       = Key(impl = lib.PredefinedKey_shiftF10)
   shiftF11       = Key(impl = lib.PredefinedKey_shiftF11)
   shiftF12       = Key(impl = lib.PredefinedKey_shiftF12)
   shiftInsert    = Key(impl = lib.PredefinedKey_shiftInsert)
   shiftDel       = Key(impl = lib.PredefinedKey_shiftDel)

class SizeAnchor(Struct):
   def __init__(self, size = None, isClientW = False, isClientH = False, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_SizeAnchor *", impl)
      else:
         if isinstance(size, tuple):
            __tuple = size
            size = None
            if len(__tuple) > 0: size      = __tuple[0]
            if len(__tuple) > 1: isClientW = __tuple[1]
            if len(__tuple) > 2: isClientH = __tuple[2]
         if size is not None:
            if not isinstance(size, Size): size = Size(size)
            size = size.impl[0]
         else:
            size = Size()
            size = size.impl[0]
         self.impl = ffi.new("eC_SizeAnchor *", { 'size' : size, 'isClientW' : isClientW, 'isClientH' : isClientH })

   @property
   def size(self): return Size(impl = self.impl.size)
   @size.setter
   def size(self, value):
      if not isinstance(value, Size): value = Size(value)
      self.impl.size = value.impl[0]

   @property
   def isClientW(self): return self.impl.isClientW
   @isClientW.setter
   def isClientW(self, value): self.impl.isClientW = value

   @property
   def isClientH(self): return self.impl.isClientH
   @isClientH.setter
   def isClientH(self, value): self.impl.isClientH = value

@ffi.callback("eC_FontResource(eC_Skin)")
def cb_Skin_captionFont(__e):
   skin = pyOrNewObject(Skin, __e)
   return skin.fn_Skin_captionFont(skin)

@ffi.callback("const char * *(eC_Skin, uint, int *, int *, byte **)")
def cb_Skin_cursorsBitmaps(__e, id, hotSpotX, hotSpotY, paletteShades):
   skin = pyOrNewObject(Skin, __e)
   return skin.fn_Skin_cursorsBitmaps(skin, id, hotSpotX, hotSpotY, paletteShades)

@ffi.callback("eC_BitmapResource(eC_Skin, eC_SkinBitmap)")
def cb_Skin_getBitmap(__e, ap1):
   skin = pyOrNewObject(Skin, __e)
   return skin.fn_Skin_getBitmap(skin, SkinBitmap(impl = ap1))

@ffi.callback("void(eC_Skin, eC_Window, eC_MinMaxValue *, eC_MinMaxValue *)")
def cb_Skin_getDecorationsSize(__e, ap1, ap2, ap3):
   skin = pyOrNewObject(Skin, __e)
   skin.fn_Skin_getDecorationsSize(skin, pyOrNewObject(Window, ap1), ap2, ap3)

@ffi.callback("int(eC_Skin)")
def cb_Skin_horizontalSBH(__e):
   skin = pyOrNewObject(Skin, __e)
   return skin.fn_Skin_horizontalSBH(skin)

@ffi.callback("eC_bool(eC_Skin, eC_Window, int, int, int, int)")
def cb_Skin_isMouseMoving(__e, ap1, ap2, ap3, ap4, ap5):
   skin = pyOrNewObject(Skin, __e)
   return skin.fn_Skin_isMouseMoving(skin, pyOrNewObject(Window, ap1), ap2, ap3, ap4, ap5)

@ffi.callback("eC_bool(eC_Skin, eC_Window, int, int, int, int, eC_bool *, eC_bool *, eC_bool *, eC_bool *)")
def cb_Skin_isMouseResizing(__e, ap1, ap2, ap3, ap4, ap5, ap6, ap7, ap8, ap9):
   skin = pyOrNewObject(Skin, __e)
   return skin.fn_Skin_isMouseResizing(skin, pyOrNewObject(Window, ap1), ap2, ap3, ap4, ap5, ap6, ap7, ap8, ap9)

@ffi.callback("void(eC_Skin, eC_Window, int *, int *, eC_MinMaxValue *, eC_MinMaxValue *, eC_MinMaxValue *, eC_MinMaxValue *)")
def cb_Skin_setWindowArea(__e, ap1, ap2, ap3, ap4, ap5, ap6, ap7):
   skin = pyOrNewObject(Skin, __e)
   skin.fn_Skin_setWindowArea(skin, pyOrNewObject(Window, ap1), ap2, ap3, ap4, ap5, ap6, ap7)

@ffi.callback("void(eC_Skin, eC_Window, eC_MinMaxValue *, eC_MinMaxValue *)")
def cb_Skin_setWindowMinimum(__e, ap1, ap2, ap3):
   skin = pyOrNewObject(Skin, __e)
   skin.fn_Skin_setWindowMinimum(skin, pyOrNewObject(Window, ap1), ap2, ap3)

@ffi.callback("void(eC_Skin, void *, eC_Surface, eC_Window, const char *, eC_bool, eC_bool)")
def cb_Skin_showDecorations(__e, ap1, ap2, ap3, ap4, ap5, ap6):
   skin = pyOrNewObject(Skin, __e)
   skin.fn_Skin_showDecorations(skin, ap1, pyOrNewObject(Surface, ap2), pyOrNewObject(Window, ap3), ap4.encode('u8'), ap5, ap6)

@ffi.callback("eC_FontResource(eC_Skin)")
def cb_Skin_systemFont(__e):
   skin = pyOrNewObject(Skin, __e)
   return skin.fn_Skin_systemFont(skin)

@ffi.callback("void(eC_Skin, void *)")
def cb_Skin_updateNonClient(__e, ap1):
   skin = pyOrNewObject(Skin, __e)
   skin.fn_Skin_updateNonClient(skin, ap1)

@ffi.callback("int(eC_Skin)")
def cb_Skin_verticalSBW(__e):
   skin = pyOrNewObject(Skin, __e)
   return skin.fn_Skin_verticalSBW(skin)

class Skin(Instance):
   class_members = [
                      'captionFont',
                      'cursorsBitmaps',
                      'getBitmap',
                      'getDecorationsSize',
                      'horizontalSBH',
                      'isMouseMoving',
                      'isMouseResizing',
                      'setWindowArea',
                      'setWindowMinimum',
                      'showDecorations',
                      'systemFont',
                      'updateNonClient',
                      'verticalSBW',
                   ]

   def init_args(self, args, kwArgs): init_args(Skin, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def fn_unset_Skin_captionFont(self):
      return pyOrNewObject(FontResource, lib.Skin_captionFont(self.impl))

   @property
   def captionFont(self):
      if hasattr(self, 'fn_Skin_captionFont'): return self.fn_Skin_captionFont
      else: return self.fn_unset_Skin_captionFont
   @captionFont.setter
   def captionFont(self, value):
      self.fn_Skin_captionFont = value
      lib.Instance_setMethod(self.impl, "CaptionFont".encode('u8'), cb_Skin_captionFont)

   def fn_unset_Skin_cursorsBitmaps(self, id, hotSpotX, hotSpotY, paletteShades):
      if hotSpotX is None: hotSpotX = ffi.NULL
      if hotSpotY is None: hotSpotY = ffi.NULL
      return lib.Skin_cursorsBitmaps(self.impl, id, hotSpotX, hotSpotY, paletteShades)

   @property
   def cursorsBitmaps(self):
      if hasattr(self, 'fn_Skin_cursorsBitmaps'): return self.fn_Skin_cursorsBitmaps
      else: return self.fn_unset_Skin_cursorsBitmaps
   @cursorsBitmaps.setter
   def cursorsBitmaps(self, value):
      self.fn_Skin_cursorsBitmaps = value
      lib.Instance_setMethod(self.impl, "CursorsBitmaps".encode('u8'), cb_Skin_cursorsBitmaps)

   def fn_unset_Skin_getBitmap(self, ap1):
      return pyOrNewObject(BitmapResource, lib.Skin_getBitmap(self.impl, ap1))

   @property
   def getBitmap(self):
      if hasattr(self, 'fn_Skin_getBitmap'): return self.fn_Skin_getBitmap
      else: return self.fn_unset_Skin_getBitmap
   @getBitmap.setter
   def getBitmap(self, value):
      self.fn_Skin_getBitmap = value
      lib.Instance_setMethod(self.impl, "GetBitmap".encode('u8'), cb_Skin_getBitmap)

   def fn_unset_Skin_getDecorationsSize(self, ap1, ap2, ap3):
      if ap2 is None: ap2 = ffi.NULL
      if ap3 is None: ap3 = ffi.NULL
      return lib.Skin_getDecorationsSize(self.impl, ffi.NULL if ap1 is None else ap1.impl, ap2, ap3)

   @property
   def getDecorationsSize(self):
      if hasattr(self, 'fn_Skin_getDecorationsSize'): return self.fn_Skin_getDecorationsSize
      else: return self.fn_unset_Skin_getDecorationsSize
   @getDecorationsSize.setter
   def getDecorationsSize(self, value):
      self.fn_Skin_getDecorationsSize = value
      lib.Instance_setMethod(self.impl, "GetDecorationsSize".encode('u8'), cb_Skin_getDecorationsSize)

   def fn_unset_Skin_horizontalSBH(self):
      return lib.Skin_horizontalSBH(self.impl)

   @property
   def horizontalSBH(self):
      if hasattr(self, 'fn_Skin_horizontalSBH'): return self.fn_Skin_horizontalSBH
      else: return self.fn_unset_Skin_horizontalSBH
   @horizontalSBH.setter
   def horizontalSBH(self, value):
      self.fn_Skin_horizontalSBH = value
      lib.Instance_setMethod(self.impl, "HorizontalSBH".encode('u8'), cb_Skin_horizontalSBH)

   def fn_unset_Skin_isMouseMoving(self, ap1, ap2, ap3, ap4, ap5):
      return lib.Skin_isMouseMoving(self.impl, ffi.NULL if ap1 is None else ap1.impl, ap2, ap3, ap4, ap5)

   @property
   def isMouseMoving(self):
      if hasattr(self, 'fn_Skin_isMouseMoving'): return self.fn_Skin_isMouseMoving
      else: return self.fn_unset_Skin_isMouseMoving
   @isMouseMoving.setter
   def isMouseMoving(self, value):
      self.fn_Skin_isMouseMoving = value
      lib.Instance_setMethod(self.impl, "IsMouseMoving".encode('u8'), cb_Skin_isMouseMoving)

   def fn_unset_Skin_isMouseResizing(self, ap1, ap2, ap3, ap4, ap5, ap6, ap7, ap8, ap9):
      if ap6 is None: ap6 = ffi.NULL
      if ap7 is None: ap7 = ffi.NULL
      if ap8 is None: ap8 = ffi.NULL
      if ap9 is None: ap9 = ffi.NULL
      return lib.Skin_isMouseResizing(self.impl, ffi.NULL if ap1 is None else ap1.impl, ap2, ap3, ap4, ap5, ap6, ap7, ap8, ap9)

   @property
   def isMouseResizing(self):
      if hasattr(self, 'fn_Skin_isMouseResizing'): return self.fn_Skin_isMouseResizing
      else: return self.fn_unset_Skin_isMouseResizing
   @isMouseResizing.setter
   def isMouseResizing(self, value):
      self.fn_Skin_isMouseResizing = value
      lib.Instance_setMethod(self.impl, "IsMouseResizing".encode('u8'), cb_Skin_isMouseResizing)

   def fn_unset_Skin_setWindowArea(self, ap1, ap2, ap3, ap4, ap5, ap6, ap7):
      if ap2 is None: ap2 = ffi.NULL
      if ap3 is None: ap3 = ffi.NULL
      if ap4 is None: ap4 = ffi.NULL
      if ap5 is None: ap5 = ffi.NULL
      if ap6 is None: ap6 = ffi.NULL
      if ap7 is None: ap7 = ffi.NULL
      return lib.Skin_setWindowArea(self.impl, ffi.NULL if ap1 is None else ap1.impl, ap2, ap3, ap4, ap5, ap6, ap7)

   @property
   def setWindowArea(self):
      if hasattr(self, 'fn_Skin_setWindowArea'): return self.fn_Skin_setWindowArea
      else: return self.fn_unset_Skin_setWindowArea
   @setWindowArea.setter
   def setWindowArea(self, value):
      self.fn_Skin_setWindowArea = value
      lib.Instance_setMethod(self.impl, "SetWindowArea".encode('u8'), cb_Skin_setWindowArea)

   def fn_unset_Skin_setWindowMinimum(self, ap1, ap2, ap3):
      if ap2 is None: ap2 = ffi.NULL
      if ap3 is None: ap3 = ffi.NULL
      return lib.Skin_setWindowMinimum(self.impl, ffi.NULL if ap1 is None else ap1.impl, ap2, ap3)

   @property
   def setWindowMinimum(self):
      if hasattr(self, 'fn_Skin_setWindowMinimum'): return self.fn_Skin_setWindowMinimum
      else: return self.fn_unset_Skin_setWindowMinimum
   @setWindowMinimum.setter
   def setWindowMinimum(self, value):
      self.fn_Skin_setWindowMinimum = value
      lib.Instance_setMethod(self.impl, "SetWindowMinimum".encode('u8'), cb_Skin_setWindowMinimum)

   def fn_unset_Skin_showDecorations(self, ap1, ap2, ap3, ap4, ap5, ap6):
      return lib.Skin_showDecorations(self.impl, ap1, ffi.NULL if ap2 is None else ap2.impl, ffi.NULL if ap3 is None else ap3.impl, ap4, ap5, ap6)

   @property
   def showDecorations(self):
      if hasattr(self, 'fn_Skin_showDecorations'): return self.fn_Skin_showDecorations
      else: return self.fn_unset_Skin_showDecorations
   @showDecorations.setter
   def showDecorations(self, value):
      self.fn_Skin_showDecorations = value
      lib.Instance_setMethod(self.impl, "ShowDecorations".encode('u8'), cb_Skin_showDecorations)

   def fn_unset_Skin_systemFont(self):
      return pyOrNewObject(FontResource, lib.Skin_systemFont(self.impl))

   @property
   def systemFont(self):
      if hasattr(self, 'fn_Skin_systemFont'): return self.fn_Skin_systemFont
      else: return self.fn_unset_Skin_systemFont
   @systemFont.setter
   def systemFont(self, value):
      self.fn_Skin_systemFont = value
      lib.Instance_setMethod(self.impl, "SystemFont".encode('u8'), cb_Skin_systemFont)

   def fn_unset_Skin_updateNonClient(self, ap1):
      return lib.Skin_updateNonClient(self.impl, ap1)

   @property
   def updateNonClient(self):
      if hasattr(self, 'fn_Skin_updateNonClient'): return self.fn_Skin_updateNonClient
      else: return self.fn_unset_Skin_updateNonClient
   @updateNonClient.setter
   def updateNonClient(self, value):
      self.fn_Skin_updateNonClient = value
      lib.Instance_setMethod(self.impl, "UpdateNonClient".encode('u8'), cb_Skin_updateNonClient)

   def fn_unset_Skin_verticalSBW(self):
      return lib.Skin_verticalSBW(self.impl)

   @property
   def verticalSBW(self):
      if hasattr(self, 'fn_Skin_verticalSBW'): return self.fn_Skin_verticalSBW
      else: return self.fn_unset_Skin_verticalSBW
   @verticalSBW.setter
   def verticalSBW(self, value):
      self.fn_Skin_verticalSBW = value
      lib.Instance_setMethod(self.impl, "VerticalSBW".encode('u8'), cb_Skin_verticalSBW)

class SkinBitmap:
   minimize = lib.SkinBitmap_minimize
   maximize = lib.SkinBitmap_maximize
   restore  = lib.SkinBitmap_restore
   close    = lib.SkinBitmap_close

class SystemCursor:
   arrow    = lib.SystemCursor_arrow
   iBeam    = lib.SystemCursor_iBeam
   cross    = lib.SystemCursor_cross
   moving   = lib.SystemCursor_moving
   sizeNESW = lib.SystemCursor_sizeNESW
   sizeNS   = lib.SystemCursor_sizeNS
   sizeNWSE = lib.SystemCursor_sizeNWSE
   sizeWE   = lib.SystemCursor_sizeWE
   hand     = lib.SystemCursor_hand

@ffi.callback("eC_bool(eC_Timer)")
def cb_Timer_delayExpired(__e):
   timer = pyOrNewObject(Timer, __e)
   return timer.fn_Timer_delayExpired(timer.userData)

class Timer(Instance):
   class_members = [
                      'userData',
                      'delay',
                      'started',
                      '_delay',
                      'delayExpired',
                   ]

   def init_args(self, args, kwArgs): init_args(Timer, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)
      if self.impl != ffi.NULL: lib.Timer_set_userData(self.impl, self.impl)

   userData = None

   @property
   def delay(self): return Seconds(impl = lib.Timer_get_delay(self.impl))
   @delay.setter
   def delay(self, value):
      if not isinstance(value, Time): value = Seconds(value)
      lib.Timer_set_delay(self.impl, value.impl)

   @property
   def started(self): return lib.Timer_get_started(self.impl)
   @started.setter
   def started(self, value):
      lib.Timer_set_started(self.impl, value)

   @property
   def _delay(self): return Seconds(impl = IPTR(lib, ffi, self, Timer)._delay)
   @_delay.setter
   def _delay(self, value):
      if not isinstance(value, Time): value = Seconds(value)
      IPTR(lib, ffi, self, Timer)._delay = value.impl

   def fn_unset_Timer_delayExpired(self, _ec_instance):
      return lib.Timer_delayExpired(self.impl, _ec_instance.impl)

   @property
   def delayExpired(self):
      if hasattr(self, 'fn_Timer_delayExpired'): return self.fn_Timer_delayExpired
      else: return self.fn_unset_Timer_delayExpired
   @delayExpired.setter
   def delayExpired(self, value):
      self.fn_Timer_delayExpired = value
      lib.Instance_setMethod(self.impl, "DelayExpired".encode('u8'), cb_Timer_delayExpired)

   def start(self):
      lib.Timer_start(self.impl)

   def stop(self):
      lib.Timer_stop(self.impl)

class TouchPointerEvent:
   move        = lib.TouchPointerEvent_move
   up          = lib.TouchPointerEvent_up
   down        = lib.TouchPointerEvent_down
   pointerUp   = lib.TouchPointerEvent_pointerUp
   pointerDown = lib.TouchPointerEvent_pointerDown

class TouchPointerInfo(Struct):
   def __init__(self, id = 0, point = None, size = 0.0, pressure = 0.0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_TouchPointerInfo *", impl)
      else:
         if isinstance(id, tuple):
            __tuple = id
            id = 0
            if len(__tuple) > 0: id       = __tuple[0]
            if len(__tuple) > 1: point    = __tuple[1]
            if len(__tuple) > 2: size     = __tuple[2]
            if len(__tuple) > 3: pressure = __tuple[3]
         if point is not None:
            if not isinstance(point, Point): point = Point(point)
            point = point.impl[0]
         else:
            point = Point()
            point = point.impl[0]
         self.impl = ffi.new("eC_TouchPointerInfo *", { 'id' : id, 'point' : point, 'size' : size, 'pressure' : pressure })

   @property
   def id(self): return self.impl.id
   @id.setter
   def id(self, value): self.impl.id = value

   @property
   def point(self): return Point(impl = self.impl.point)
   @point.setter
   def point(self, value):
      if not isinstance(value, Point): value = Point(value)
      self.impl.point = value.impl[0]

   @property
   def size(self): return self.impl.size
   @size.setter
   def size(self, value): self.impl.size = value

   @property
   def pressure(self): return self.impl.pressure
   @pressure.setter
   def pressure(self, value): self.impl.pressure = value

@ffi.callback("eC_bool(uint64, eC_WindowController)")
def cb_WindowController_onCreate(__u, controller):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onCreate(pyObject(lib.oTAInstance(__u)), windowcontroller)

@ffi.callback("eC_bool(uint64, eC_WindowController, eC_Key, unichar)")
def cb_WindowController_onKeyDown(__u, controller, key, ch):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onKeyDown(pyObject(lib.oTAInstance(__u)), windowcontroller, Key(impl = key), ch)

@ffi.callback("eC_bool(uint64, eC_WindowController, eC_Key, unichar)")
def cb_WindowController_onKeyHit(__u, controller, key, ch):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onKeyHit(pyObject(lib.oTAInstance(__u)), windowcontroller, Key(impl = key), ch)

@ffi.callback("eC_bool(uint64, eC_WindowController, eC_Key, unichar)")
def cb_WindowController_onKeyUp(__u, controller, key, ch):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onKeyUp(pyObject(lib.oTAInstance(__u)), windowcontroller, Key(impl = key), ch)

@ffi.callback("eC_bool(uint64, eC_WindowController, int, int, eC_Modifiers)")
def cb_WindowController_onLeftButtonDown(__u, controller, x, y, mods):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onLeftButtonDown(pyObject(lib.oTAInstance(__u)), windowcontroller, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(uint64, eC_WindowController, int, int, eC_Modifiers)")
def cb_WindowController_onLeftButtonUp(__u, controller, x, y, mods):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onLeftButtonUp(pyObject(lib.oTAInstance(__u)), windowcontroller, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(uint64, eC_WindowController, int, int, eC_Modifiers)")
def cb_WindowController_onLeftDoubleClick(__u, controller, x, y, mods):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onLeftDoubleClick(pyObject(lib.oTAInstance(__u)), windowcontroller, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(uint64, eC_WindowController)")
def cb_WindowController_onLoadGraphics(__u, controller):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onLoadGraphics(pyObject(lib.oTAInstance(__u)), windowcontroller)

@ffi.callback("eC_bool(uint64, eC_WindowController, int, int, eC_Modifiers)")
def cb_WindowController_onMiddleButtonDown(__u, controller, x, y, mods):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onMiddleButtonDown(pyObject(lib.oTAInstance(__u)), windowcontroller, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(uint64, eC_WindowController, int, int, eC_Modifiers)")
def cb_WindowController_onMiddleButtonUp(__u, controller, x, y, mods):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onMiddleButtonUp(pyObject(lib.oTAInstance(__u)), windowcontroller, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(uint64, eC_WindowController, int, int, eC_Modifiers)")
def cb_WindowController_onMiddleDoubleClick(__u, controller, x, y, mods):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onMiddleDoubleClick(pyObject(lib.oTAInstance(__u)), windowcontroller, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(uint64, eC_WindowController, int, int, eC_Modifiers)")
def cb_WindowController_onMouseMove(__u, controller, x, y, mods):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onMouseMove(pyObject(lib.oTAInstance(__u)), windowcontroller, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(uint64, eC_WindowController, eC_TouchPointerEvent, eC_Array, eC_Modifiers)")
def cb_WindowController_onMultiTouch(__u, controller, event, infos, mods):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onMultiTouch(pyObject(lib.oTAInstance(__u)), windowcontroller, TouchPointerEvent(impl = event), Array("<TouchPointerInfo>", impl = infos), Modifiers(impl = mods))

@ffi.callback("void(uint64, eC_WindowController, eC_Surface)")
def cb_WindowController_onRedraw(__u, controller, surface):
   windowcontroller = pyOrNewObject(WindowController, controller)
   windowcontroller.fn_WindowController_onRedraw(pyObject(lib.oTAInstance(__u)), windowcontroller, pyOrNewObject(Surface, surface))

@ffi.callback("void(uint64, eC_WindowController, int, int)")
def cb_WindowController_onResize(__u, controller, width, height):
   windowcontroller = pyOrNewObject(WindowController, controller)
   windowcontroller.fn_WindowController_onResize(pyObject(lib.oTAInstance(__u)), windowcontroller, width, height)

@ffi.callback("eC_bool(uint64, eC_WindowController, int, int, eC_Modifiers)")
def cb_WindowController_onRightButtonDown(__u, controller, x, y, mods):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onRightButtonDown(pyObject(lib.oTAInstance(__u)), windowcontroller, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(uint64, eC_WindowController, int, int, eC_Modifiers)")
def cb_WindowController_onRightButtonUp(__u, controller, x, y, mods):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onRightButtonUp(pyObject(lib.oTAInstance(__u)), windowcontroller, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(uint64, eC_WindowController, int, int, eC_Modifiers)")
def cb_WindowController_onRightDoubleClick(__u, controller, x, y, mods):
   windowcontroller = pyOrNewObject(WindowController, controller)
   return windowcontroller.fn_WindowController_onRightDoubleClick(pyObject(lib.oTAInstance(__u)), windowcontroller, x, y, Modifiers(impl = mods))

@ffi.callback("void(uint64, eC_WindowController)")
def cb_WindowController_onUnloadGraphics(__u, controller):
   windowcontroller = pyOrNewObject(WindowController, controller)
   windowcontroller.fn_WindowController_onUnloadGraphics(pyObject(lib.oTAInstance(__u)), windowcontroller)

class WindowController(Instance):
   class_members = [
                      'window',
                      'controlled',
                      'windowVTbl',
                      'onCreate',
                      'onKeyDown',
                      'onKeyHit',
                      'onKeyUp',
                      'onLeftButtonDown',
                      'onLeftButtonUp',
                      'onLeftDoubleClick',
                      'onLoadGraphics',
                      'onMiddleButtonDown',
                      'onMiddleButtonUp',
                      'onMiddleDoubleClick',
                      'onMouseMove',
                      'onMultiTouch',
                      'onRedraw',
                      'onResize',
                      'onRightButtonDown',
                      'onRightButtonUp',
                      'onRightDoubleClick',
                      'onUnloadGraphics',
                   ]

   def init_args(self, args, kwArgs): init_args(WindowController, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def window(self): return pyOrNewObject(Window, lib.WindowController_get_window(self.impl))

   @property
   def controlled(self): value = lib.WindowController_get_controlled(self.impl); return pyOrNewObject(Instance, lib.oTAInstance(value))
   @controlled.setter
   def controlled(self, value):
      lib.WindowController_set_controlled(self.impl, TA(value))

   @property
   def windowVTbl(self): return IPTR(lib, ffi, self, WindowController).windowVTbl
   @windowVTbl.setter
   def windowVTbl(self, value): IPTR(lib, ffi, self, WindowController).windowVTbl = value

   def fn_unset_WindowController_onCreate(self, controller):
      return lib.WindowController_onCreate(self.impl, ffi.NULL if controller is None else controller.impl)

   @property
   def onCreate(self):
      if hasattr(self, 'fn_WindowController_onCreate'): return self.fn_WindowController_onCreate
      else: return self.fn_unset_WindowController_onCreate
   @onCreate.setter
   def onCreate(self, value):
      self.fn_WindowController_onCreate = value
      lib.Instance_setMethod(self.impl, "OnCreate".encode('u8'), cb_WindowController_onCreate)

   def fn_unset_WindowController_onKeyDown(self, controller, key, ch):
      return lib.WindowController_onKeyDown(self.impl, ffi.NULL if controller is None else controller.impl, key, ch)

   @property
   def onKeyDown(self):
      if hasattr(self, 'fn_WindowController_onKeyDown'): return self.fn_WindowController_onKeyDown
      else: return self.fn_unset_WindowController_onKeyDown
   @onKeyDown.setter
   def onKeyDown(self, value):
      self.fn_WindowController_onKeyDown = value
      lib.Instance_setMethod(self.impl, "OnKeyDown".encode('u8'), cb_WindowController_onKeyDown)

   def fn_unset_WindowController_onKeyHit(self, controller, key, ch):
      return lib.WindowController_onKeyHit(self.impl, ffi.NULL if controller is None else controller.impl, key, ch)

   @property
   def onKeyHit(self):
      if hasattr(self, 'fn_WindowController_onKeyHit'): return self.fn_WindowController_onKeyHit
      else: return self.fn_unset_WindowController_onKeyHit
   @onKeyHit.setter
   def onKeyHit(self, value):
      self.fn_WindowController_onKeyHit = value
      lib.Instance_setMethod(self.impl, "OnKeyHit".encode('u8'), cb_WindowController_onKeyHit)

   def fn_unset_WindowController_onKeyUp(self, controller, key, ch):
      return lib.WindowController_onKeyUp(self.impl, ffi.NULL if controller is None else controller.impl, key, ch)

   @property
   def onKeyUp(self):
      if hasattr(self, 'fn_WindowController_onKeyUp'): return self.fn_WindowController_onKeyUp
      else: return self.fn_unset_WindowController_onKeyUp
   @onKeyUp.setter
   def onKeyUp(self, value):
      self.fn_WindowController_onKeyUp = value
      lib.Instance_setMethod(self.impl, "OnKeyUp".encode('u8'), cb_WindowController_onKeyUp)

   def fn_unset_WindowController_onLeftButtonDown(self, controller, x, y, mods):
      return lib.WindowController_onLeftButtonDown(self.impl, ffi.NULL if controller is None else controller.impl, x, y, mods)

   @property
   def onLeftButtonDown(self):
      if hasattr(self, 'fn_WindowController_onLeftButtonDown'): return self.fn_WindowController_onLeftButtonDown
      else: return self.fn_unset_WindowController_onLeftButtonDown
   @onLeftButtonDown.setter
   def onLeftButtonDown(self, value):
      self.fn_WindowController_onLeftButtonDown = value
      lib.Instance_setMethod(self.impl, "OnLeftButtonDown".encode('u8'), cb_WindowController_onLeftButtonDown)

   def fn_unset_WindowController_onLeftButtonUp(self, controller, x, y, mods):
      return lib.WindowController_onLeftButtonUp(self.impl, ffi.NULL if controller is None else controller.impl, x, y, mods)

   @property
   def onLeftButtonUp(self):
      if hasattr(self, 'fn_WindowController_onLeftButtonUp'): return self.fn_WindowController_onLeftButtonUp
      else: return self.fn_unset_WindowController_onLeftButtonUp
   @onLeftButtonUp.setter
   def onLeftButtonUp(self, value):
      self.fn_WindowController_onLeftButtonUp = value
      lib.Instance_setMethod(self.impl, "OnLeftButtonUp".encode('u8'), cb_WindowController_onLeftButtonUp)

   def fn_unset_WindowController_onLeftDoubleClick(self, controller, x, y, mods):
      return lib.WindowController_onLeftDoubleClick(self.impl, ffi.NULL if controller is None else controller.impl, x, y, mods)

   @property
   def onLeftDoubleClick(self):
      if hasattr(self, 'fn_WindowController_onLeftDoubleClick'): return self.fn_WindowController_onLeftDoubleClick
      else: return self.fn_unset_WindowController_onLeftDoubleClick
   @onLeftDoubleClick.setter
   def onLeftDoubleClick(self, value):
      self.fn_WindowController_onLeftDoubleClick = value
      lib.Instance_setMethod(self.impl, "OnLeftDoubleClick".encode('u8'), cb_WindowController_onLeftDoubleClick)

   def fn_unset_WindowController_onLoadGraphics(self, controller):
      return lib.WindowController_onLoadGraphics(self.impl, ffi.NULL if controller is None else controller.impl)

   @property
   def onLoadGraphics(self):
      if hasattr(self, 'fn_WindowController_onLoadGraphics'): return self.fn_WindowController_onLoadGraphics
      else: return self.fn_unset_WindowController_onLoadGraphics
   @onLoadGraphics.setter
   def onLoadGraphics(self, value):
      self.fn_WindowController_onLoadGraphics = value
      lib.Instance_setMethod(self.impl, "OnLoadGraphics".encode('u8'), cb_WindowController_onLoadGraphics)

   def fn_unset_WindowController_onMiddleButtonDown(self, controller, x, y, mods):
      return lib.WindowController_onMiddleButtonDown(self.impl, ffi.NULL if controller is None else controller.impl, x, y, mods)

   @property
   def onMiddleButtonDown(self):
      if hasattr(self, 'fn_WindowController_onMiddleButtonDown'): return self.fn_WindowController_onMiddleButtonDown
      else: return self.fn_unset_WindowController_onMiddleButtonDown
   @onMiddleButtonDown.setter
   def onMiddleButtonDown(self, value):
      self.fn_WindowController_onMiddleButtonDown = value
      lib.Instance_setMethod(self.impl, "OnMiddleButtonDown".encode('u8'), cb_WindowController_onMiddleButtonDown)

   def fn_unset_WindowController_onMiddleButtonUp(self, controller, x, y, mods):
      return lib.WindowController_onMiddleButtonUp(self.impl, ffi.NULL if controller is None else controller.impl, x, y, mods)

   @property
   def onMiddleButtonUp(self):
      if hasattr(self, 'fn_WindowController_onMiddleButtonUp'): return self.fn_WindowController_onMiddleButtonUp
      else: return self.fn_unset_WindowController_onMiddleButtonUp
   @onMiddleButtonUp.setter
   def onMiddleButtonUp(self, value):
      self.fn_WindowController_onMiddleButtonUp = value
      lib.Instance_setMethod(self.impl, "OnMiddleButtonUp".encode('u8'), cb_WindowController_onMiddleButtonUp)

   def fn_unset_WindowController_onMiddleDoubleClick(self, controller, x, y, mods):
      return lib.WindowController_onMiddleDoubleClick(self.impl, ffi.NULL if controller is None else controller.impl, x, y, mods)

   @property
   def onMiddleDoubleClick(self):
      if hasattr(self, 'fn_WindowController_onMiddleDoubleClick'): return self.fn_WindowController_onMiddleDoubleClick
      else: return self.fn_unset_WindowController_onMiddleDoubleClick
   @onMiddleDoubleClick.setter
   def onMiddleDoubleClick(self, value):
      self.fn_WindowController_onMiddleDoubleClick = value
      lib.Instance_setMethod(self.impl, "OnMiddleDoubleClick".encode('u8'), cb_WindowController_onMiddleDoubleClick)

   def fn_unset_WindowController_onMouseMove(self, controller, x, y, mods):
      return lib.WindowController_onMouseMove(self.impl, ffi.NULL if controller is None else controller.impl, x, y, mods)

   @property
   def onMouseMove(self):
      if hasattr(self, 'fn_WindowController_onMouseMove'): return self.fn_WindowController_onMouseMove
      else: return self.fn_unset_WindowController_onMouseMove
   @onMouseMove.setter
   def onMouseMove(self, value):
      self.fn_WindowController_onMouseMove = value
      lib.Instance_setMethod(self.impl, "OnMouseMove".encode('u8'), cb_WindowController_onMouseMove)

   def fn_unset_WindowController_onMultiTouch(self, controller, event, infos, mods):
      return lib.WindowController_onMultiTouch(self.impl, ffi.NULL if controller is None else controller.impl, event, ffi.NULL if infos is None else infos.impl, mods)

   @property
   def onMultiTouch(self):
      if hasattr(self, 'fn_WindowController_onMultiTouch'): return self.fn_WindowController_onMultiTouch
      else: return self.fn_unset_WindowController_onMultiTouch
   @onMultiTouch.setter
   def onMultiTouch(self, value):
      self.fn_WindowController_onMultiTouch = value
      lib.Instance_setMethod(self.impl, "OnMultiTouch".encode('u8'), cb_WindowController_onMultiTouch)

   def fn_unset_WindowController_onRedraw(self, controller, surface):
      return lib.WindowController_onRedraw(self.impl, ffi.NULL if controller is None else controller.impl, ffi.NULL if surface is None else surface.impl)

   @property
   def onRedraw(self):
      if hasattr(self, 'fn_WindowController_onRedraw'): return self.fn_WindowController_onRedraw
      else: return self.fn_unset_WindowController_onRedraw
   @onRedraw.setter
   def onRedraw(self, value):
      self.fn_WindowController_onRedraw = value
      lib.Instance_setMethod(self.impl, "OnRedraw".encode('u8'), cb_WindowController_onRedraw)

   def fn_unset_WindowController_onResize(self, controller, width, height):
      return lib.WindowController_onResize(self.impl, ffi.NULL if controller is None else controller.impl, width, height)

   @property
   def onResize(self):
      if hasattr(self, 'fn_WindowController_onResize'): return self.fn_WindowController_onResize
      else: return self.fn_unset_WindowController_onResize
   @onResize.setter
   def onResize(self, value):
      self.fn_WindowController_onResize = value
      lib.Instance_setMethod(self.impl, "OnResize".encode('u8'), cb_WindowController_onResize)

   def fn_unset_WindowController_onRightButtonDown(self, controller, x, y, mods):
      return lib.WindowController_onRightButtonDown(self.impl, ffi.NULL if controller is None else controller.impl, x, y, mods)

   @property
   def onRightButtonDown(self):
      if hasattr(self, 'fn_WindowController_onRightButtonDown'): return self.fn_WindowController_onRightButtonDown
      else: return self.fn_unset_WindowController_onRightButtonDown
   @onRightButtonDown.setter
   def onRightButtonDown(self, value):
      self.fn_WindowController_onRightButtonDown = value
      lib.Instance_setMethod(self.impl, "OnRightButtonDown".encode('u8'), cb_WindowController_onRightButtonDown)

   def fn_unset_WindowController_onRightButtonUp(self, controller, x, y, mods):
      return lib.WindowController_onRightButtonUp(self.impl, ffi.NULL if controller is None else controller.impl, x, y, mods)

   @property
   def onRightButtonUp(self):
      if hasattr(self, 'fn_WindowController_onRightButtonUp'): return self.fn_WindowController_onRightButtonUp
      else: return self.fn_unset_WindowController_onRightButtonUp
   @onRightButtonUp.setter
   def onRightButtonUp(self, value):
      self.fn_WindowController_onRightButtonUp = value
      lib.Instance_setMethod(self.impl, "OnRightButtonUp".encode('u8'), cb_WindowController_onRightButtonUp)

   def fn_unset_WindowController_onRightDoubleClick(self, controller, x, y, mods):
      return lib.WindowController_onRightDoubleClick(self.impl, ffi.NULL if controller is None else controller.impl, x, y, mods)

   @property
   def onRightDoubleClick(self):
      if hasattr(self, 'fn_WindowController_onRightDoubleClick'): return self.fn_WindowController_onRightDoubleClick
      else: return self.fn_unset_WindowController_onRightDoubleClick
   @onRightDoubleClick.setter
   def onRightDoubleClick(self, value):
      self.fn_WindowController_onRightDoubleClick = value
      lib.Instance_setMethod(self.impl, "OnRightDoubleClick".encode('u8'), cb_WindowController_onRightDoubleClick)

   def fn_unset_WindowController_onUnloadGraphics(self, controller):
      return lib.WindowController_onUnloadGraphics(self.impl, ffi.NULL if controller is None else controller.impl)

   @property
   def onUnloadGraphics(self):
      if hasattr(self, 'fn_WindowController_onUnloadGraphics'): return self.fn_WindowController_onUnloadGraphics
      else: return self.fn_unset_WindowController_onUnloadGraphics
   @onUnloadGraphics.setter
   def onUnloadGraphics(self, value):
      self.fn_WindowController_onUnloadGraphics = value
      lib.Instance_setMethod(self.impl, "OnUnloadGraphics".encode('u8'), cb_WindowController_onUnloadGraphics)

class WindowState:
   normal    = lib.WindowState_normal
   minimized = lib.WindowState_minimized
   maximized = lib.WindowState_maximized

def applySkin(c, name):
   if c is not None and not isinstance(c, Class): c = Class(c)
   c = ffi.NULL if c is None else c.impl
   if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
   elif name is None: name = ffi.NULL
   vTbl = ffi.new("void * *")
   lib.eC_applySkin(ffi.cast("struct eC_Class *", c), name, vTbl)
   if vTbl[0] == ffi.NULL: _vTbl = None
   else: _vTbl = vTbl[0]
   return _vTbl

def desktop3DFullScreen(window = None):
   if window is not None and not isinstance(window, Window): window = Window(window)
   window = ffi.NULL if window is None else window.impl
   return lib.eC_desktop3DFullScreen(window)

def desktop3DGetClipBox(box = None):
   if box is not None and not isinstance(box, Box): box = Box(box)
   box = ffi.NULL if box is None else box.impl
   lib.eC_desktop3DGetClipBox(ffi.cast("eC_Box *", box))

def desktop3DGetClippedWindow():
   return pyOrNewObject(Window, lib.eC_desktop3DGetClippedWindow())

def desktop3DGetWindowHandle(window = None):
   if window is not None and not isinstance(window, Window): window = Window(window)
   window = ffi.NULL if window is None else window.impl
   return lib.eC_desktop3DGetWindowHandle(window)

def desktop3DInitialize(window, setup, update):
   if window is not None and not isinstance(window, Window): window = Window(window)
   window = ffi.NULL if window is None else window.impl
   lib.eC_desktop3DInitialize(window)

def desktop3DMouseMessage(window, method, x, y, consequential, activate):
   if window is not None and not isinstance(window, Window): window = Window(window)
   window = ffi.NULL if window is None else window.impl
   mods = ffi.new("eC_Modifiers *")
   r = lib.eC_desktop3DMouseMessage(window, method, x, y, mods, consequential, activate)
   return r, Modifiers(impl = mods[0])

def desktop3DSetDesktopDirty():
   lib.eC_desktop3DSetDesktopDirty()

def desktop3DTitleBarClicked(clickedWindow, x, y):
   if clickedWindow is not None and not isinstance(clickedWindow, Window): clickedWindow = Window(clickedWindow)
   clickedWindow = ffi.NULL if clickedWindow is None else clickedWindow.impl
   return lib.eC_desktop3DTitleBarClicked(clickedWindow, x, y)

def desktop3DUpdateDisplay():
   return lib.eC_desktop3DUpdateDisplay()

def queryCompass(value = None):
   if value is not None and not isinstance(value, Euler): value = Euler(value)
   value = ffi.NULL if value is None else value.impl
   lib.eC_queryCompass(ffi.cast("eC_Euler *", value))

def unapplySkin(c = None):
   if c is not None and not isinstance(c, Class): c = Class(c)
   c = ffi.NULL if c is None else c.impl
   lib.eC_unapplySkin(ffi.cast("struct eC_Class *", c))

class TVisionSkin_Window(Window):
   class_members = []

   def init_args(self, args, kwArgs): init_args(TVisionSkin_Window, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class WindowsSkin_Button(Button):
   class_members = []

   def init_args(self, args, kwArgs): init_args(WindowsSkin_Button, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class WindowsSkin_Window(Window):
   class_members = []

   def init_args(self, args, kwArgs): init_args(WindowsSkin_Window, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

@ffi.callback("eC_bool(eC_Window, eC_DataBox, eC_bool)")
def cb_DataBox_notifyChanged(__e, dataBox, closingDropDown):
   databox = pyOrNewObject(DataBox, databox)
   return databox.fn_DataBox_notifyChanged(pyOrNewObject(DataBox, __e), dataBox, closingDropDown)

@ffi.callback("eC_bool(eC_Window)")
def cb_DataBox_notifyModified(__e):
   databox = pyOrNewObject(DataBox, databox)
   return databox.fn_DataBox_notifyModified(pyOrNewObject(DataBox, __e))

@ffi.callback("void(eC_DataBox, eC_Window)")
def cb_DataBox_onConfigure(__e, editor):
   databox = pyOrNewObject(DataBox, __e)
   databox.fn_DataBox_onConfigure(databox, pyOrNewObject(Window, editor))

@ffi.callback("void(eC_DataBox, any_object, eC_bool)")
def cb_DataBox_setData(__e, newData, closingDropDown):
   databox = pyOrNewObject(DataBox, __e)
   databox.fn_DataBox_setData(databox, any_object(impl = newData), closingDropDown)

class DataBox(CommonControl):
   class_members = [
                      'type',
                      'data',
                      'fieldData',
                      'editor',
                      'readOnly',
                      'keepEditor',
                      'autoSize',
                      'needUpdate',
                      'stringValue',
                      'notifyChanged',
                      'notifyModified',
                      'onConfigure',
                      'setData',
                   ]

   def init_args(self, args, kwArgs): init_args(DataBox, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def type(self): return Class(impl = IPTR(lib, ffi, self, DataBox).type)
   @type.setter
   def type(self, value):
      if not isinstance(value, Class): value = Class(value)
      IPTR(lib, ffi, self, DataBox).type = value.impl

   @property
   def data(self): return IPTR(lib, ffi, self, DataBox).data
   @data.setter
   def data(self, value): IPTR(lib, ffi, self, DataBox).data = value

   @property
   def fieldData(self): return IPTR(lib, ffi, self, DataBox).fieldData
   @fieldData.setter
   def fieldData(self, value): IPTR(lib, ffi, self, DataBox).fieldData = value

   @property
   def editor(self): return pyOrNewObject(Window, IPTR(lib, ffi, self, DataBox).editor)
   @editor.setter
   def editor(self, value):
      if not isinstance(value, Window): value = Window(value)
      IPTR(lib, ffi, self, DataBox).editor = value.impl

   @property
   def readOnly(self): return IPTR(lib, ffi, self, DataBox).readOnly
   @readOnly.setter
   def readOnly(self, value): IPTR(lib, ffi, self, DataBox).readOnly = value

   @property
   def keepEditor(self): return IPTR(lib, ffi, self, DataBox).keepEditor
   @keepEditor.setter
   def keepEditor(self, value): IPTR(lib, ffi, self, DataBox).keepEditor = value

   @property
   def autoSize(self): return IPTR(lib, ffi, self, DataBox).autoSize
   @autoSize.setter
   def autoSize(self, value): IPTR(lib, ffi, self, DataBox).autoSize = value

   @property
   def needUpdate(self): return IPTR(lib, ffi, self, DataBox).needUpdate
   @needUpdate.setter
   def needUpdate(self, value): IPTR(lib, ffi, self, DataBox).needUpdate = value

   @property
   def stringValue(self): return pyOrNewObject(String, IPTR(lib, ffi, self, DataBox).stringValue)
   @stringValue.setter
   def stringValue(self, value):
      if isinstance(value, str): value = ffi.new("char[]", value.encode('u8'))
      elif value is None: value = ffi.NULL
      IPTR(lib, ffi, self, DataBox).stringValue = value

   def modified(self):
      lib.DataBox_modified(self.impl)

   def fn_unset_DataBox_notifyChanged(self, _ec_window, dataBox, closingDropDown):
      return lib.DataBox_notifyChanged(self.impl, _ec_window.impl, ffi.NULL if dataBox is None else dataBox.impl, closingDropDown)

   @property
   def notifyChanged(self):
      if hasattr(self, 'fn_DataBox_notifyChanged'): return self.fn_DataBox_notifyChanged
      else: return self.fn_unset_DataBox_notifyChanged
   @notifyChanged.setter
   def notifyChanged(self, value):
      self.fn_DataBox_notifyChanged = value
      lib.Instance_setMethod(self.impl, "NotifyChanged".encode('u8'), cb_DataBox_notifyChanged)

   def fn_unset_DataBox_notifyModified(self, _ec_window):
      return lib.DataBox_notifyModified(self.impl, _ec_window.impl)

   @property
   def notifyModified(self):
      if hasattr(self, 'fn_DataBox_notifyModified'): return self.fn_DataBox_notifyModified
      else: return self.fn_unset_DataBox_notifyModified
   @notifyModified.setter
   def notifyModified(self, value):
      self.fn_DataBox_notifyModified = value
      lib.Instance_setMethod(self.impl, "NotifyModified".encode('u8'), cb_DataBox_notifyModified)

   def fn_unset_DataBox_onConfigure(self, editor):
      return lib.DataBox_onConfigure(self.impl, ffi.NULL if editor is None else editor.impl)

   @property
   def onConfigure(self):
      if hasattr(self, 'fn_DataBox_onConfigure'): return self.fn_DataBox_onConfigure
      else: return self.fn_unset_DataBox_onConfigure
   @onConfigure.setter
   def onConfigure(self, value):
      self.fn_DataBox_onConfigure = value
      lib.Instance_setMethod(self.impl, "OnConfigure".encode('u8'), cb_DataBox_onConfigure)

   def refresh(self):
      lib.DataBox_refresh(self.impl)

   def saveData(self):
      return lib.DataBox_saveData(self.impl)

   def fn_unset_DataBox_setData(self, newData, closingDropDown):
      return lib.DataBox_setData(self.impl, newData, closingDropDown)

   @property
   def setData(self):
      if hasattr(self, 'fn_DataBox_setData'): return self.fn_DataBox_setData
      else: return self.fn_unset_DataBox_setData
   @setData.setter
   def setData(self, value):
      self.fn_DataBox_setData = value
      lib.Instance_setMethod(self.impl, "SetData".encode('u8'), cb_DataBox_setData)

@ffi.callback("eC_bool(eC_Window, eC_MenuItem, eC_Modifiers)")
def cb_MenuItem_notifySelect(__e, selection, mods):
   menuitem = pyOrNewObject(MenuItem, menuitem)
   return menuitem.fn_MenuItem_notifySelect(pyOrNewObject(MenuItem, __e), selection, Modifiers(impl = mods))

class MenuItem(Instance):
   class_members = [
                      'parent',
                      'text',
                      'hotKey',
                      'accelerator',
                      'checked',
                      'disabled',
                      'checkable',
                      'isRadio',
                      'id',
                      'bitmap',
                      'copyText',
                      'bold',
                      'notifySelect',
                   ]

   def init_args(self, args, kwArgs): init_args(MenuItem, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def parent(self): return None
   @parent.setter
   def parent(self, value):
      if not isinstance(value, Menu): value = Menu(value)
      lib.MenuItem_set_parent(self.impl, value.impl)

   @property
   def text(self): return None
   @text.setter
   def text(self, value):
      lib.MenuItem_set_text(self.impl, value.encode('u8'))

   @property
   def hotKey(self): return None
   @hotKey.setter
   def hotKey(self, value):
      if not isinstance(value, Key): value = Key(value)
      lib.MenuItem_set_hotKey(self.impl, value.impl)

   @property
   def accelerator(self): return None
   @accelerator.setter
   def accelerator(self, value):
      if not isinstance(value, Key): value = Key(value)
      lib.MenuItem_set_accelerator(self.impl, value.impl)

   @property
   def checked(self): return lib.MenuItem_get_checked(self.impl)
   @checked.setter
   def checked(self, value):
      lib.MenuItem_set_checked(self.impl, value)

   @property
   def disabled(self): return None
   @disabled.setter
   def disabled(self, value):
      lib.MenuItem_set_disabled(self.impl, value)

   @property
   def checkable(self): return None
   @checkable.setter
   def checkable(self, value):
      lib.MenuItem_set_checkable(self.impl, value)

   @property
   def isRadio(self): return None
   @isRadio.setter
   def isRadio(self, value):
      lib.MenuItem_set_isRadio(self.impl, value)

   @property
   def id(self): return lib.MenuItem_get_id(self.impl)
   @id.setter
   def id(self, value):
      lib.MenuItem_set_id(self.impl, value)

   @property
   def bitmap(self): return pyOrNewObject(BitmapResource, lib.MenuItem_get_bitmap(self.impl))
   @bitmap.setter
   def bitmap(self, value):
      if not isinstance(value, BitmapResource): value = BitmapResource(value)
      lib.MenuItem_set_bitmap(self.impl, value.impl)

   @property
   def copyText(self): return None
   @copyText.setter
   def copyText(self, value):
      lib.MenuItem_set_copyText(self.impl, value)

   @property
   def bold(self): return lib.MenuItem_get_bold(self.impl)
   @bold.setter
   def bold(self, value):
      lib.MenuItem_set_bold(self.impl, value)

   def fn_unset_MenuItem_notifySelect(self, _ec_window, selection, mods):
      return lib.MenuItem_notifySelect(self.impl, _ec_window.impl, ffi.NULL if selection is None else selection.impl, mods)

   @property
   def notifySelect(self):
      if hasattr(self, 'fn_MenuItem_notifySelect'): return self.fn_MenuItem_notifySelect
      else: return self.fn_unset_MenuItem_notifySelect
   @notifySelect.setter
   def notifySelect(self, value):
      self.fn_MenuItem_notifySelect = value
      lib.Instance_setMethod(self.impl, "NotifySelect".encode('u8'), cb_MenuItem_notifySelect)

class SelectorButton(Button):
   class_members = [
                      'focusHolder',
                   ]

   def init_args(self, args, kwArgs): init_args(SelectorButton, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def focusHolder(self): return pyOrNewObject(Window, IPTR(lib, ffi, self, SelectorButton).focusHolder)
   @focusHolder.setter
   def focusHolder(self, value):
      if not isinstance(value, Window): value = Window(value)
      IPTR(lib, ffi, self, SelectorButton).focusHolder = value.impl

class Stacker(Window):
   class_members = [
                      'direction',
                      'gap',
                      'reverse',
                      'scrollable',
                      'controls',
                      'flipper',
                      'flipSpring',
                      'autoSize',
                      'margin',
                      'endButtons',
                      'hoverScroll',
                   ]

   def init_args(self, args, kwArgs): init_args(Stacker, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def direction(self): return lib.Stacker_get_direction(self.impl)
   @direction.setter
   def direction(self, value):
      lib.Stacker_set_direction(self.impl, value)

   @property
   def gap(self): return lib.Stacker_get_gap(self.impl)
   @gap.setter
   def gap(self, value):
      lib.Stacker_set_gap(self.impl, value)

   @property
   def reverse(self): return lib.Stacker_get_reverse(self.impl)
   @reverse.setter
   def reverse(self, value):
      lib.Stacker_set_reverse(self.impl, value)

   @property
   def scrollable(self): return lib.Stacker_get_scrollable(self.impl)
   @scrollable.setter
   def scrollable(self, value):
      lib.Stacker_set_scrollable(self.impl, value)

   @property
   def controls(self): return pyOrNewObject(Array, lib.Stacker_get_controls(self.impl))

   @property
   def flipper(self): return pyOrNewObject(Window, lib.Stacker_get_flipper(self.impl))
   @flipper.setter
   def flipper(self, value):
      if not isinstance(value, Window): value = Window(value)
      lib.Stacker_set_flipper(self.impl, value.impl)

   @property
   def flipSpring(self): return lib.Stacker_get_flipSpring(self.impl)
   @flipSpring.setter
   def flipSpring(self, value):
      lib.Stacker_set_flipSpring(self.impl, value)

   @property
   def autoSize(self): return lib.Stacker_get_autoSize(self.impl)
   @autoSize.setter
   def autoSize(self, value):
      lib.Stacker_set_autoSize(self.impl, value)

   @property
   def margin(self): return lib.Stacker_get_margin(self.impl)
   @margin.setter
   def margin(self, value):
      lib.Stacker_set_margin(self.impl, value)

   @property
   def endButtons(self): return lib.Stacker_get_endButtons(self.impl)
   @endButtons.setter
   def endButtons(self, value):
      lib.Stacker_set_endButtons(self.impl, value)

   @property
   def hoverScroll(self): return lib.Stacker_get_hoverScroll(self.impl)
   @hoverScroll.setter
   def hoverScroll(self, value):
      lib.Stacker_set_hoverScroll(self.impl, value)

   def destroyChildren(self):
      lib.Stacker_destroyChildren(self.impl)

   def getNextStackedItem(self, current, previous, filter = None):
      if current is not None and not isinstance(current, Window): current = Window(current)
      current = ffi.NULL if current is None else current.impl
      if filter is not None and not isinstance(filter, Class): filter = Class(filter)
      filter = ffi.NULL if filter is None else filter.impl
      return pyOrNewObject(Window, lib.Stacker_getNextStackedItem(self.impl, current, previous, ffi.cast("struct eC_Class *", filter)))

   def makeControlVisible(self, control = None):
      if control is not None and not isinstance(control, Window): control = Window(control)
      control = ffi.NULL if control is None else control.impl
      lib.Stacker_makeControlVisible(self.impl, control)

   def moveControl(self, ctrl, after, fixCycle):
      if ctrl is not None and not isinstance(ctrl, IteratorPointer): ctrl = IteratorPointer(ctrl)
      ctrl = ffi.NULL if ctrl is None else ctrl.impl
      if after is not None and not isinstance(after, IteratorPointer): after = IteratorPointer(after)
      after = ffi.NULL if after is None else after.impl
      lib.Stacker_moveControl(self.impl, ffi.cast("struct eC_IteratorPointer *", ctrl), ffi.cast("struct eC_IteratorPointer *", after), fixCycle)

class BoxAlignment:
   center = lib.BoxAlignment_center
   left   = lib.BoxAlignment_left
   right  = lib.BoxAlignment_right
   top    = lib.BoxAlignment_top
   bottom = lib.BoxAlignment_bottom

class BufferLocation(Struct):
   def __init__(self, line = None, y = 0, x = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_BufferLocation *", impl)
      else:
         if isinstance(line, tuple):
            __tuple = line
            line = None
            if len(__tuple) > 0: line = __tuple[0]
            if len(__tuple) > 1: y    = __tuple[1]
            if len(__tuple) > 2: x    = __tuple[2]
         if line is not None:
            if not isinstance(line, EditLine): line = EditLine(line)
            line = line.impl
         else:
            line = ffi.NULL
         self.impl = ffi.new("eC_BufferLocation *", { 'line' : line, 'y' : y, 'x' : x })

   @property
   def line(self): return self.impl.line
   @line.setter
   def line(self, value):
      if not isinstance(value, EditLine): value = EditLine(value)
      self.impl.line = value.impl

   @property
   def y(self): return self.impl.y
   @y.setter
   def y(self, value): self.impl.y = value

   @property
   def x(self): return self.impl.x
   @x.setter
   def x(self, value): self.impl.x = value

   def adjustAdd(self, start = None, end = None):
      if start is not None and not isinstance(start, BufferLocation): start = BufferLocation(start)
      start = ffi.NULL if start is None else start.impl
      if end is not None and not isinstance(end, BufferLocation): end = BufferLocation(end)
      end = ffi.NULL if end is None else end.impl
      lib.BufferLocation_adjustAdd(ffi.cast("eC_BufferLocation *", self.impl), ffi.cast("eC_BufferLocation *", start), ffi.cast("eC_BufferLocation *", end))

   def adjustDelete(self, start = None, end = None):
      if start is not None and not isinstance(start, BufferLocation): start = BufferLocation(start)
      start = ffi.NULL if start is None else start.impl
      if end is not None and not isinstance(end, BufferLocation): end = BufferLocation(end)
      end = ffi.NULL if end is None else end.impl
      lib.BufferLocation_adjustDelete(ffi.cast("eC_BufferLocation *", self.impl), ffi.cast("eC_BufferLocation *", start), ffi.cast("eC_BufferLocation *", end))

class ButtonState:
   up              = lib.ButtonState_up
   down            = lib.ButtonState_down
   over            = lib.ButtonState_over
   disabled        = lib.ButtonState_disabled
   upChecked       = lib.ButtonState_upChecked
   downChecked     = lib.ButtonState_downChecked
   overChecked     = lib.ButtonState_overChecked
   disabledChecked = lib.ButtonState_disabledChecked

@ffi.callback("void(eC_Window, eC_CalendarControl, eC_bool)")
def cb_CalendarControl_notifyChanged(__e, calendarControl, close):
   calendarcontrol = pyOrNewObject(CalendarControl, calendarcontrol)
   calendarcontrol.fn_CalendarControl_notifyChanged(pyOrNewObject(CalendarControl, __e), calendarControl, close)

class CalendarControl(CommonControl):
   class_members = [
                      'dateValue',
                      'shownMonth',
                      'shownYear',
                      'notifyChanged',
                   ]

   def init_args(self, args, kwArgs): init_args(CalendarControl, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def dateValue(self): return Date(impl = IPTR(lib, ffi, self, CalendarControl).dateValue)
   @dateValue.setter
   def dateValue(self, value):
      if not isinstance(value, Date): value = Date(value)
      IPTR(lib, ffi, self, CalendarControl).dateValue = value.impl

   @property
   def shownMonth(self): return Month(impl = IPTR(lib, ffi, self, CalendarControl).shownMonth)
   @shownMonth.setter
   def shownMonth(self, value): IPTR(lib, ffi, self, CalendarControl).shownMonth = value.impl

   @property
   def shownYear(self): return IPTR(lib, ffi, self, CalendarControl).shownYear
   @shownYear.setter
   def shownYear(self, value): IPTR(lib, ffi, self, CalendarControl).shownYear = value

   def fn_unset_CalendarControl_notifyChanged(self, _ec_window, calendarControl, close):
      return lib.CalendarControl_notifyChanged(self.impl, _ec_window.impl, ffi.NULL if calendarControl is None else calendarControl.impl, close)

   @property
   def notifyChanged(self):
      if hasattr(self, 'fn_CalendarControl_notifyChanged'): return self.fn_CalendarControl_notifyChanged
      else: return self.fn_unset_CalendarControl_notifyChanged
   @notifyChanged.setter
   def notifyChanged(self, value):
      self.fn_CalendarControl_notifyChanged = value
      lib.Instance_setMethod(self.impl, "NotifyChanged".encode('u8'), cb_CalendarControl_notifyChanged)

class DataDisplayFlags(pyBaseClass):
   def __init__(self, selected = False, fullRow = False, current = False, active = False, dropBox = False, header = False, firstField = False, impl = None):
      if impl is not None:
         self.impl = impl
      elif isinstance(selected, DataDisplayFlags):
         self.impl = selected.impl
      else:
         self.impl = (
            (selected   << lib.DATADISPLAYFLAGS_selected_SHIFT)   |
            (fullRow    << lib.DATADISPLAYFLAGS_fullRow_SHIFT)    |
            (current    << lib.DATADISPLAYFLAGS_current_SHIFT)    |
            (active     << lib.DATADISPLAYFLAGS_active_SHIFT)     |
            (dropBox    << lib.DATADISPLAYFLAGS_dropBox_SHIFT)    |
            (header     << lib.DATADISPLAYFLAGS_header_SHIFT)     |
            (firstField << lib.DATADISPLAYFLAGS_firstField_SHIFT) )

   @property
   def selected(self): return ((((self.impl)) & lib.DATADISPLAYFLAGS_selected_MASK) >> lib.DATADISPLAYFLAGS_selected_SHIFT)
   @selected.setter
   def selected(self, value): self.impl = ((self.impl) & ~(lib.DATADISPLAYFLAGS_selected_MASK)) | (((value)) << lib.DATADISPLAYFLAGS_selected_SHIFT)

   @property
   def fullRow(self): return ((((self.impl)) & lib.DATADISPLAYFLAGS_fullRow_MASK) >> lib.DATADISPLAYFLAGS_fullRow_SHIFT)
   @fullRow.setter
   def fullRow(self, value): self.impl = ((self.impl) & ~(lib.DATADISPLAYFLAGS_fullRow_MASK)) | (((value)) << lib.DATADISPLAYFLAGS_fullRow_SHIFT)

   @property
   def current(self): return ((((self.impl)) & lib.DATADISPLAYFLAGS_current_MASK) >> lib.DATADISPLAYFLAGS_current_SHIFT)
   @current.setter
   def current(self, value): self.impl = ((self.impl) & ~(lib.DATADISPLAYFLAGS_current_MASK)) | (((value)) << lib.DATADISPLAYFLAGS_current_SHIFT)

   @property
   def active(self): return ((((self.impl)) & lib.DATADISPLAYFLAGS_active_MASK) >> lib.DATADISPLAYFLAGS_active_SHIFT)
   @active.setter
   def active(self, value): self.impl = ((self.impl) & ~(lib.DATADISPLAYFLAGS_active_MASK)) | (((value)) << lib.DATADISPLAYFLAGS_active_SHIFT)

   @property
   def dropBox(self): return ((((self.impl)) & lib.DATADISPLAYFLAGS_dropBox_MASK) >> lib.DATADISPLAYFLAGS_dropBox_SHIFT)
   @dropBox.setter
   def dropBox(self, value): self.impl = ((self.impl) & ~(lib.DATADISPLAYFLAGS_dropBox_MASK)) | (((value)) << lib.DATADISPLAYFLAGS_dropBox_SHIFT)

   @property
   def header(self): return ((((self.impl)) & lib.DATADISPLAYFLAGS_header_MASK) >> lib.DATADISPLAYFLAGS_header_SHIFT)
   @header.setter
   def header(self, value): self.impl = ((self.impl) & ~(lib.DATADISPLAYFLAGS_header_MASK)) | (((value)) << lib.DATADISPLAYFLAGS_header_SHIFT)

   @property
   def firstField(self): return ((((self.impl)) & lib.DATADISPLAYFLAGS_firstField_MASK) >> lib.DATADISPLAYFLAGS_firstField_SHIFT)
   @firstField.setter
   def firstField(self, value): self.impl = ((self.impl) & ~(lib.DATADISPLAYFLAGS_firstField_MASK)) | (((value)) << lib.DATADISPLAYFLAGS_firstField_SHIFT)

class DataField(Instance):
   class_members = [
                      'dataType',
                      'editable',
                      'fixed',
                      'alignment',
                      'width',
                      'index',
                      'position',
                      'sortOrder',
                      'header',
                      'userData',
                      'freeData',
                      'prev',
                      'next',
                   ]

   def init_args(self, args, kwArgs): init_args(DataField, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def dataType(self): return Class(impl = lib.DataField_get_dataType(self.impl))
   @dataType.setter
   def dataType(self, value):
      if not isinstance(value, Class): value = Class(value)
      lib.DataField_set_dataType(self.impl, value.impl)

   @property
   def editable(self): return None
   @editable.setter
   def editable(self, value):
      lib.DataField_set_editable(self.impl, value)

   @property
   def fixed(self): return lib.DataField_get_fixed(self.impl)
   @fixed.setter
   def fixed(self, value):
      lib.DataField_set_fixed(self.impl, value)

   @property
   def alignment(self): return lib.DataField_get_alignment(self.impl)
   @alignment.setter
   def alignment(self, value):
      lib.DataField_set_alignment(self.impl, value)

   @property
   def width(self): return lib.DataField_get_width(self.impl)
   @width.setter
   def width(self, value):
      lib.DataField_set_width(self.impl, value)

   @property
   def index(self): return lib.DataField_get_index(self.impl)

   @property
   def position(self): return lib.DataField_get_position(self.impl)
   @position.setter
   def position(self, value):
      lib.DataField_set_position(self.impl, value)

   @property
   def sortOrder(self): return lib.DataField_get_sortOrder(self.impl)

   @property
   def header(self): return None
   @header.setter
   def header(self, value):
      lib.DataField_set_header(self.impl, value.encode('u8'))

   @property
   def userData(self): return lib.DataField_get_userData(self.impl)
   @userData.setter
   def userData(self, value):
      lib.DataField_set_userData(self.impl, value)

   @property
   def freeData(self): return lib.DataField_get_freeData(self.impl)
   @freeData.setter
   def freeData(self, value):
      lib.DataField_set_freeData(self.impl, value)

   @property
   def prev(self): return pyOrNewObject(DataField, lib.DataField_get_prev(self.impl))

   @property
   def next(self): return pyOrNewObject(DataField, lib.DataField_get_next(self.impl))

   def autoSize(self):
      lib.DataField_autoSize(self.impl)

   def move(self, after = None):
      if after is not None and not isinstance(after, DataField): after = DataField(after)
      after = ffi.NULL if after is None else after.impl
      lib.DataField_move(self.impl, after)

class DataFieldSort(Struct):
   def __init__(self, field = None, order = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_DataFieldSort *", impl)
      else:
         if isinstance(field, tuple):
            __tuple = field
            field = None
            if len(__tuple) > 0: field = __tuple[0]
            if len(__tuple) > 1: order = __tuple[1]
         if field is not None:
            if not isinstance(field, DataField): field = DataField(field)
            field = field.impl
         else:
            field = ffi.NULL
         self.impl = ffi.new("eC_DataFieldSort *", { 'field' : field, 'order' : order })

   @property
   def field(self): return pyOrNewObject(DataField, self.impl.field)
   @field.setter
   def field(self, value):
      if not isinstance(value, DataField): value = DataField(value)
      self.impl.field = value.impl

   @property
   def order(self): return self.impl.order
   @order.setter
   def order(self, value): self.impl.order = value

class DataRow(Instance):
   class_members = [
                      'tag',
                      'previous',
                      'next',
                      'index',
                      'string',
                      'isHeader',
                      'icon',
                      'collapsed',
                      'selected',
                      'parent',
                      'lastRow',
                      'firstRow',
                   ]

   def init_args(self, args, kwArgs): init_args(DataRow, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def tag(self): return lib.DataRow_get_tag(self.impl)
   @tag.setter
   def tag(self, value):
      lib.DataRow_set_tag(self.impl, value)

   @property
   def previous(self): return pyOrNewObject(DataRow, lib.DataRow_get_previous(self.impl))

   @property
   def next(self): return pyOrNewObject(DataRow, lib.DataRow_get_next(self.impl))

   @property
   def index(self): return lib.DataRow_get_index(self.impl)

   @property
   def string(self): value = lib.DataRow_get_string(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @string.setter
   def string(self, value):
      lib.DataRow_set_string(self.impl, value.encode('u8'))

   @property
   def isHeader(self): return lib.DataRow_get_isHeader(self.impl)
   @isHeader.setter
   def isHeader(self, value):
      lib.DataRow_set_isHeader(self.impl, value)

   @property
   def icon(self): return pyOrNewObject(BitmapResource, lib.DataRow_get_icon(self.impl))
   @icon.setter
   def icon(self, value):
      if not isinstance(value, BitmapResource): value = BitmapResource(value)
      lib.DataRow_set_icon(self.impl, value.impl)

   @property
   def collapsed(self): return lib.DataRow_get_collapsed(self.impl)
   @collapsed.setter
   def collapsed(self, value):
      lib.DataRow_set_collapsed(self.impl, value)

   @property
   def selected(self): return lib.DataRow_get_selected(self.impl)
   @selected.setter
   def selected(self, value):
      lib.DataRow_set_selected(self.impl, value)

   @property
   def parent(self): return pyOrNewObject(DataRow, lib.DataRow_get_parent(self.impl))
   @parent.setter
   def parent(self, value):
      if not isinstance(value, DataRow): value = DataRow(value)
      lib.DataRow_set_parent(self.impl, value.impl)

   @property
   def lastRow(self): return pyOrNewObject(DataRow, lib.DataRow_get_lastRow(self.impl))

   @property
   def firstRow(self): return pyOrNewObject(DataRow, lib.DataRow_get_firstRow(self.impl))

   def addRow(self):
      return pyOrNewObject(DataRow, lib.DataRow_addRow(self.impl))

   def addRowAfter(self, after = None):
      if after is not None and not isinstance(after, DataRow): after = DataRow(after)
      after = ffi.NULL if after is None else after.impl
      return pyOrNewObject(DataRow, lib.DataRow_addRowAfter(self.impl, after))

   def addString(self, string):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      return pyOrNewObject(DataRow, lib.DataRow_addString(self.impl, string))

   def addStringf(self, format, *args):
      if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
      elif format is None: format = ffi.NULL
      return pyOrNewObject(DataRow, lib.DataRow_addStringf(self.impl, format, *ellipsisArgs(args)))

   def edit(self, field = None):
      if field is not None and not isinstance(field, DataField): field = DataField(field)
      field = ffi.NULL if field is None else field.impl
      lib.DataRow_edit(self.impl, field)

   def findRow(self, tag):
      return pyOrNewObject(DataRow, lib.DataRow_findRow(self.impl, tag))

   def findSubRow(self, tag):
      return pyOrNewObject(DataRow, lib.DataRow_findSubRow(self.impl, tag))

   def getData(self, field = None):
      if field is not None and not isinstance(field, DataField): field = DataField(field)
      field = ffi.NULL if field is None else field.impl
      return lib.DataRow_getData(self.impl, field)

   def getNextRow(self):
      return pyOrNewObject(DataRow, lib.DataRow_getNextRow(self.impl))

   def getPrevRow(self):
      return pyOrNewObject(DataRow, lib.DataRow_getPrevRow(self.impl))

   def move(self, after = None):
      if after is not None and not isinstance(after, DataRow): after = DataRow(after)
      after = ffi.NULL if after is None else after.impl
      lib.DataRow_move(self.impl, after)

   def setData(self, field, newData):
      if field is not None and not isinstance(field, DataField): field = DataField(field)
      field = ffi.NULL if field is None else field.impl
      return lib.DataRow_setData(self.impl, field, newData)

   def sortSubRows(self, scrollToCurrent):
      lib.DataRow_sortSubRows(self.impl, scrollToCurrent)

   def unsetData(self, field = None):
      if field is not None and not isinstance(field, DataField): field = DataField(field)
      field = ffi.NULL if field is None else field.impl
      lib.DataRow_unsetData(self.impl, field)

class DirPath:
   def __init__(self, impl = None):
      FilePath.__init__(self, impl = impl)
      if impl is not None: self.impl = impl
      else: self.impl = ffi.NULL

@ffi.callback("eC_bool(eC_Window, eC_DirectoriesBox)")
def cb_DirectoriesBox_notifyModified(__e, dirsBox):
   directoriesbox = pyOrNewObject(DirectoriesBox, directoriesbox)
   return directoriesbox.fn_DirectoriesBox_notifyModified(pyOrNewObject(DirectoriesBox, __e), dirsBox)

@ffi.callback("eC_bool(eC_Window, eC_DirectoriesBox, eC_PathBox)")
def cb_DirectoriesBox_notifyPathBoxModified(__e, dirsBox, pathBox):
   directoriesbox = pyOrNewObject(DirectoriesBox, directoriesbox)
   return directoriesbox.fn_DirectoriesBox_notifyPathBoxModified(pyOrNewObject(DirectoriesBox, __e), dirsBox, pyOrNewObject(PathBox, pathBox))

@ffi.callback("eC_bool(eC_DirectoriesBox, char **)")
def cb_DirectoriesBox_onBrowsedDir(__e, directory):
   directoriesbox = pyOrNewObject(DirectoriesBox, __e)
   return directoriesbox.fn_DirectoriesBox_onBrowsedDir(directoriesbox, directory)

@ffi.callback("eC_bool(eC_DirectoriesBox, char **)")
def cb_DirectoriesBox_onChangedDir(__e, directory):
   directoriesbox = pyOrNewObject(DirectoriesBox, __e)
   return directoriesbox.fn_DirectoriesBox_onChangedDir(directoriesbox, directory)

@ffi.callback("eC_bool(eC_DirectoriesBox, char **)")
def cb_DirectoriesBox_onPrepareBrowseDir(__e, directory):
   directoriesbox = pyOrNewObject(DirectoriesBox, __e)
   return directoriesbox.fn_DirectoriesBox_onPrepareBrowseDir(directoriesbox, directory)

class DirectoriesBox(CommonControl):
   class_members = [
                      'browsing',
                      'strings',
                      'browseDialog',
                      'baseBrowsePath',
                      'add',
                      'remove',
                      'up',
                      'down',
                      'list',
                      'dirField',
                      'notifyModified',
                      'notifyPathBoxModified',
                      'onBrowsedDir',
                      'onChangedDir',
                      'onPrepareBrowseDir',
                   ]

   def init_args(self, args, kwArgs): init_args(DirectoriesBox, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def browsing(self): return IPTR(lib, ffi, self, DirectoriesBox).browsing
   @browsing.setter
   def browsing(self, value): IPTR(lib, ffi, self, DirectoriesBox).browsing = value

   @property
   def strings(self): return pyOrNewObject(Array, lib.DirectoriesBox_get_strings(self.impl))
   @strings.setter
   def strings(self, value):
      lib.DirectoriesBox_set_strings(self.impl, value.impl)

   @property
   def browseDialog(self): return pyOrNewObject(FileDialog, lib.DirectoriesBox_get_browseDialog(self.impl))
   @browseDialog.setter
   def browseDialog(self, value):
      if not isinstance(value, FileDialog): value = FileDialog(value)
      lib.DirectoriesBox_set_browseDialog(self.impl, value.impl)

   @property
   def baseBrowsePath(self): value = lib.DirectoriesBox_get_baseBrowsePath(self.impl) if self is not None and self.impl != ffi.NULL else ffi.NULL; return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @baseBrowsePath.setter
   def baseBrowsePath(self, value):
      if not isinstance(value, String): value = String(value)
      lib.DirectoriesBox_set_baseBrowsePath(self.impl, value.impl.encode('u8'))

   @property
   def add(self): return pyOrNewObject(Button, IPTR(lib, ffi, self, DirectoriesBox).add)
   @add.setter
   def add(self, value):
      if not isinstance(value, Button): value = Button(value)
      IPTR(lib, ffi, self, DirectoriesBox).add = value.impl

   @property
   def remove(self): return pyOrNewObject(Button, IPTR(lib, ffi, self, DirectoriesBox).remove)
   @remove.setter
   def remove(self, value):
      if not isinstance(value, Button): value = Button(value)
      IPTR(lib, ffi, self, DirectoriesBox).remove = value.impl

   @property
   def up(self): return pyOrNewObject(RepButton, IPTR(lib, ffi, self, DirectoriesBox).up)
   @up.setter
   def up(self, value):
      if not isinstance(value, RepButton): value = RepButton(value)
      IPTR(lib, ffi, self, DirectoriesBox).up = value.impl

   @property
   def down(self): return pyOrNewObject(RepButton, IPTR(lib, ffi, self, DirectoriesBox).down)
   @down.setter
   def down(self, value):
      if not isinstance(value, RepButton): value = RepButton(value)
      IPTR(lib, ffi, self, DirectoriesBox).down = value.impl

   @property
   def list(self): return pyOrNewObject(ListBox, IPTR(lib, ffi, self, DirectoriesBox).list)
   @list.setter
   def list(self, value):
      if not isinstance(value, ListBox): value = ListBox(value)
      IPTR(lib, ffi, self, DirectoriesBox).list = value.impl

   @property
   def dirField(self): return pyOrNewObject(DataField, IPTR(lib, ffi, self, DirectoriesBox).dirField)
   @dirField.setter
   def dirField(self, value):
      if not isinstance(value, DataField): value = DataField(value)
      IPTR(lib, ffi, self, DirectoriesBox).dirField = value.impl

   def fn_unset_DirectoriesBox_notifyModified(self, _ec_window, dirsBox):
      return lib.DirectoriesBox_notifyModified(self.impl, _ec_window.impl, ffi.NULL if dirsBox is None else dirsBox.impl)

   @property
   def notifyModified(self):
      if hasattr(self, 'fn_DirectoriesBox_notifyModified'): return self.fn_DirectoriesBox_notifyModified
      else: return self.fn_unset_DirectoriesBox_notifyModified
   @notifyModified.setter
   def notifyModified(self, value):
      self.fn_DirectoriesBox_notifyModified = value
      lib.Instance_setMethod(self.impl, "NotifyModified".encode('u8'), cb_DirectoriesBox_notifyModified)

   def fn_unset_DirectoriesBox_notifyPathBoxModified(self, _ec_window, dirsBox, pathBox):
      return lib.DirectoriesBox_notifyPathBoxModified(self.impl, _ec_window.impl, ffi.NULL if dirsBox is None else dirsBox.impl, ffi.NULL if pathBox is None else pathBox.impl)

   @property
   def notifyPathBoxModified(self):
      if hasattr(self, 'fn_DirectoriesBox_notifyPathBoxModified'): return self.fn_DirectoriesBox_notifyPathBoxModified
      else: return self.fn_unset_DirectoriesBox_notifyPathBoxModified
   @notifyPathBoxModified.setter
   def notifyPathBoxModified(self, value):
      self.fn_DirectoriesBox_notifyPathBoxModified = value
      lib.Instance_setMethod(self.impl, "NotifyPathBoxModified".encode('u8'), cb_DirectoriesBox_notifyPathBoxModified)

   def fn_unset_DirectoriesBox_onBrowsedDir(self, directory):
      return lib.DirectoriesBox_onBrowsedDir(self.impl, directory)

   @property
   def onBrowsedDir(self):
      if hasattr(self, 'fn_DirectoriesBox_onBrowsedDir'): return self.fn_DirectoriesBox_onBrowsedDir
      else: return self.fn_unset_DirectoriesBox_onBrowsedDir
   @onBrowsedDir.setter
   def onBrowsedDir(self, value):
      self.fn_DirectoriesBox_onBrowsedDir = value
      lib.Instance_setMethod(self.impl, "OnBrowsedDir".encode('u8'), cb_DirectoriesBox_onBrowsedDir)

   def fn_unset_DirectoriesBox_onChangedDir(self, directory):
      return lib.DirectoriesBox_onChangedDir(self.impl, directory)

   @property
   def onChangedDir(self):
      if hasattr(self, 'fn_DirectoriesBox_onChangedDir'): return self.fn_DirectoriesBox_onChangedDir
      else: return self.fn_unset_DirectoriesBox_onChangedDir
   @onChangedDir.setter
   def onChangedDir(self, value):
      self.fn_DirectoriesBox_onChangedDir = value
      lib.Instance_setMethod(self.impl, "OnChangedDir".encode('u8'), cb_DirectoriesBox_onChangedDir)

   def fn_unset_DirectoriesBox_onPrepareBrowseDir(self, directory):
      return lib.DirectoriesBox_onPrepareBrowseDir(self.impl, directory)

   @property
   def onPrepareBrowseDir(self):
      if hasattr(self, 'fn_DirectoriesBox_onPrepareBrowseDir'): return self.fn_DirectoriesBox_onPrepareBrowseDir
      else: return self.fn_unset_DirectoriesBox_onPrepareBrowseDir
   @onPrepareBrowseDir.setter
   def onPrepareBrowseDir(self, value):
      self.fn_DirectoriesBox_onPrepareBrowseDir = value
      lib.Instance_setMethod(self.impl, "OnPrepareBrowseDir".encode('u8'), cb_DirectoriesBox_onPrepareBrowseDir)

@ffi.callback("eC_bool(eC_Window, eC_DropBox)")
def cb_DropBox_notifyClose(__e, dropBox):
   dropbox = pyOrNewObject(DropBox, dropbox)
   return dropbox.fn_DropBox_notifyClose(pyOrNewObject(DropBox, __e), dropBox)

@ffi.callback("eC_bool(eC_Window, eC_DropBox, eC_DataRow, eC_Modifiers)")
def cb_DropBox_notifyHighlight(__e, dropBox, row, mods):
   dropbox = pyOrNewObject(DropBox, dropbox)
   return dropbox.fn_DropBox_notifyHighlight(pyOrNewObject(DropBox, __e), dropBox, pyOrNewObject(DataRow, row), Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_DropBox, eC_DataRow, eC_Modifiers)")
def cb_DropBox_notifySelect(__e, dropBox, row, mods):
   dropbox = pyOrNewObject(DropBox, dropbox)
   return dropbox.fn_DropBox_notifySelect(pyOrNewObject(DropBox, __e), dropBox, pyOrNewObject(DataRow, row), Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_DropBox, const char *, eC_bool)")
def cb_DropBox_notifyTextEntry(__e, dropBox, string, confirmed):
   dropbox = pyOrNewObject(DropBox, dropbox)
   return dropbox.fn_DropBox_notifyTextEntry(pyOrNewObject(DropBox, __e), dropBox, string.encode('u8'), confirmed)

@ffi.callback("void(eC_DropBox, eC_Window)")
def cb_DropBox_onCloseDropDown(__e, pullDown):
   dropbox = pyOrNewObject(DropBox, __e)
   dropbox.fn_DropBox_onCloseDropDown(dropbox, pyOrNewObject(Window, pullDown))

@ffi.callback("eC_Window(eC_DropBox)")
def cb_DropBox_onDropDown(__e):
   dropbox = pyOrNewObject(DropBox, __e)
   return dropbox.fn_DropBox_onDropDown(dropbox)

class DropBox(CommonControl):
   class_members = [
                      'activeStipple',
                      'showButton',
                      'alignment',
                      'noHighlight',
                      'activeColor',
                      'currentRow',
                      'firstRow',
                      'lastRow',
                      'contents',
                      'editText',
                      'editBox',
                      'typingTimeout',
                      'rowHeight',
                      'maxShown',
                      'pullDown',
                      'showNone',
                      'selectionColor',
                      'selectionText',
                      'changeContents',
                      'listBox',
                      'rowCount',
                      'button',
                      'notifyClose',
                      'notifyHighlight',
                      'notifySelect',
                      'notifyTextEntry',
                      'onCloseDropDown',
                      'onDropDown',
                   ]

   def init_args(self, args, kwArgs): init_args(DropBox, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def activeStipple(self): return lib.DropBox_get_activeStipple(self.impl)
   @activeStipple.setter
   def activeStipple(self, value):
      lib.DropBox_set_activeStipple(self.impl, value)

   @property
   def showButton(self): return lib.DropBox_get_showButton(self.impl)
   @showButton.setter
   def showButton(self, value):
      lib.DropBox_set_showButton(self.impl, value)

   @property
   def alignment(self): return lib.DropBox_get_alignment(self.impl)
   @alignment.setter
   def alignment(self, value):
      lib.DropBox_set_alignment(self.impl, value)

   @property
   def noHighlight(self): return lib.DropBox_get_noHighlight(self.impl)
   @noHighlight.setter
   def noHighlight(self, value):
      lib.DropBox_set_noHighlight(self.impl, value)

   @property
   def activeColor(self): return lib.DropBox_get_activeColor(self.impl)
   @activeColor.setter
   def activeColor(self, value):
      lib.DropBox_set_activeColor(self.impl, value)

   @property
   def currentRow(self): return pyOrNewObject(DataRow, lib.DropBox_get_currentRow(self.impl))
   @currentRow.setter
   def currentRow(self, value):
      if not isinstance(value, DataRow): value = DataRow(value)
      lib.DropBox_set_currentRow(self.impl, value.impl)

   @property
   def firstRow(self): return pyOrNewObject(DataRow, lib.DropBox_get_firstRow(self.impl))

   @property
   def lastRow(self): return pyOrNewObject(DataRow, lib.DropBox_get_lastRow(self.impl))

   @property
   def contents(self): value = lib.DropBox_get_contents(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @contents.setter
   def contents(self, value):
      lib.DropBox_set_contents(self.impl, value.encode('u8'))

   @property
   def editText(self): return lib.DropBox_get_editText(self.impl)
   @editText.setter
   def editText(self, value):
      lib.DropBox_set_editText(self.impl, value)

   @property
   def editBox(self): return pyOrNewObject(EditBox, lib.DropBox_get_editBox(self.impl))

   @property
   def typingTimeout(self): return Seconds(impl = lib.DropBox_get_typingTimeout(self.impl))
   @typingTimeout.setter
   def typingTimeout(self, value):
      if not isinstance(value, Time): value = Seconds(value)
      lib.DropBox_set_typingTimeout(self.impl, value.impl)

   @property
   def rowHeight(self): return lib.DropBox_get_rowHeight(self.impl)
   @rowHeight.setter
   def rowHeight(self, value):
      lib.DropBox_set_rowHeight(self.impl, value)

   @property
   def maxShown(self): return lib.DropBox_get_maxShown(self.impl)
   @maxShown.setter
   def maxShown(self, value):
      lib.DropBox_set_maxShown(self.impl, value)

   @property
   def pullDown(self): return pyOrNewObject(Window, lib.DropBox_get_pullDown(self.impl))

   @property
   def showNone(self): return lib.DropBox_get_showNone(self.impl)
   @showNone.setter
   def showNone(self, value):
      lib.DropBox_set_showNone(self.impl, value)

   @property
   def selectionColor(self): return Color(impl = lib.DropBox_get_selectionColor(self.impl))
   @selectionColor.setter
   def selectionColor(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.DropBox_set_selectionColor(self.impl, value.impl)
   # @selectionColor.isset # tofix: how do we get isset?
   # def selectionColor(self): lib.DropBox_isSet_selectionColor(self.impl)

   @property
   def selectionText(self): return Color(impl = lib.DropBox_get_selectionText(self.impl))
   @selectionText.setter
   def selectionText(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.DropBox_set_selectionText(self.impl, value.impl)
   # @selectionText.isset # tofix: how do we get isset?
   # def selectionText(self): lib.DropBox_isSet_selectionText(self.impl)

   @property
   def changeContents(self): return lib.DropBox_get_changeContents(self.impl)
   @changeContents.setter
   def changeContents(self, value):
      lib.DropBox_set_changeContents(self.impl, value)

   @property
   def listBox(self): return pyOrNewObject(ListBox, lib.DropBox_get_listBox(self.impl))

   @property
   def rowCount(self): return lib.DropBox_get_rowCount(self.impl)

   @property
   def button(self): return pyOrNewObject(Button, IPTR(lib, ffi, self, DropBox).button)
   @button.setter
   def button(self, value):
      if not isinstance(value, Button): value = Button(value)
      IPTR(lib, ffi, self, DropBox).button = value.impl

   def addField(self, field = None):
      if field is not None and not isinstance(field, DataField): field = DataField(field)
      field = ffi.NULL if field is None else field.impl
      lib.DropBox_addField(self.impl, field)

   def addRow(self):
      return pyOrNewObject(DataRow, lib.DropBox_addRow(self.impl))

   def addRowAfter(self, after = None):
      if after is not None and not isinstance(after, DataRow): after = DataRow(after)
      after = ffi.NULL if after is None else after.impl
      return pyOrNewObject(DataRow, lib.DropBox_addRowAfter(self.impl, after))

   def addString(self, string):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      return pyOrNewObject(DataRow, lib.DropBox_addString(self.impl, string))

   def addStringf(self, format, *args):
      if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
      elif format is None: format = ffi.NULL
      return pyOrNewObject(DataRow, lib.DropBox_addStringf(self.impl, format, *ellipsisArgs(args)))

   def clear(self):
      lib.DropBox_clear(self.impl)

   def deleteRow(self, row = None):
      if row is not None and not isinstance(row, DataRow): row = DataRow(row)
      row = ffi.NULL if row is None else row.impl
      lib.DropBox_deleteRow(self.impl, row)

   def findRow(self, tag):
      return pyOrNewObject(DataRow, lib.DropBox_findRow(self.impl, tag))

   def findSubRow(self, tag):
      return pyOrNewObject(DataRow, lib.DropBox_findSubRow(self.impl, tag))

   def getData(self, field = None):
      if field is not None and not isinstance(field, DataField): field = DataField(field)
      field = ffi.NULL if field is None else field.impl
      return lib.DropBox_getData(self.impl, field)

   def getRowCount(self):
      return lib.DropBox_getRowCount(self.impl)

   def getTag(self):
      return lib.DropBox_getTag(self.impl)

   def fn_unset_DropBox_notifyClose(self, _ec_window, dropBox):
      return lib.DropBox_notifyClose(self.impl, _ec_window.impl, ffi.NULL if dropBox is None else dropBox.impl)

   @property
   def notifyClose(self):
      if hasattr(self, 'fn_DropBox_notifyClose'): return self.fn_DropBox_notifyClose
      else: return self.fn_unset_DropBox_notifyClose
   @notifyClose.setter
   def notifyClose(self, value):
      self.fn_DropBox_notifyClose = value
      lib.Instance_setMethod(self.impl, "NotifyClose".encode('u8'), cb_DropBox_notifyClose)

   def fn_unset_DropBox_notifyHighlight(self, _ec_window, dropBox, row, mods):
      return lib.DropBox_notifyHighlight(self.impl, _ec_window.impl, ffi.NULL if dropBox is None else dropBox.impl, ffi.NULL if row is None else row.impl, mods)

   @property
   def notifyHighlight(self):
      if hasattr(self, 'fn_DropBox_notifyHighlight'): return self.fn_DropBox_notifyHighlight
      else: return self.fn_unset_DropBox_notifyHighlight
   @notifyHighlight.setter
   def notifyHighlight(self, value):
      self.fn_DropBox_notifyHighlight = value
      lib.Instance_setMethod(self.impl, "NotifyHighlight".encode('u8'), cb_DropBox_notifyHighlight)

   def fn_unset_DropBox_notifySelect(self, _ec_window, dropBox, row, mods):
      return lib.DropBox_notifySelect(self.impl, _ec_window.impl, ffi.NULL if dropBox is None else dropBox.impl, ffi.NULL if row is None else row.impl, mods)

   @property
   def notifySelect(self):
      if hasattr(self, 'fn_DropBox_notifySelect'): return self.fn_DropBox_notifySelect
      else: return self.fn_unset_DropBox_notifySelect
   @notifySelect.setter
   def notifySelect(self, value):
      self.fn_DropBox_notifySelect = value
      lib.Instance_setMethod(self.impl, "NotifySelect".encode('u8'), cb_DropBox_notifySelect)

   def fn_unset_DropBox_notifyTextEntry(self, _ec_window, dropBox, string, confirmed):
      return lib.DropBox_notifyTextEntry(self.impl, _ec_window.impl, ffi.NULL if dropBox is None else dropBox.impl, string, confirmed)

   @property
   def notifyTextEntry(self):
      if hasattr(self, 'fn_DropBox_notifyTextEntry'): return self.fn_DropBox_notifyTextEntry
      else: return self.fn_unset_DropBox_notifyTextEntry
   @notifyTextEntry.setter
   def notifyTextEntry(self, value):
      self.fn_DropBox_notifyTextEntry = value
      lib.Instance_setMethod(self.impl, "NotifyTextEntry".encode('u8'), cb_DropBox_notifyTextEntry)

   def fn_unset_DropBox_onCloseDropDown(self, pullDown):
      return lib.DropBox_onCloseDropDown(self.impl, ffi.NULL if pullDown is None else pullDown.impl)

   @property
   def onCloseDropDown(self):
      if hasattr(self, 'fn_DropBox_onCloseDropDown'): return self.fn_DropBox_onCloseDropDown
      else: return self.fn_unset_DropBox_onCloseDropDown
   @onCloseDropDown.setter
   def onCloseDropDown(self, value):
      self.fn_DropBox_onCloseDropDown = value
      lib.Instance_setMethod(self.impl, "OnCloseDropDown".encode('u8'), cb_DropBox_onCloseDropDown)

   def fn_unset_DropBox_onDropDown(self):
      return pyOrNewObject(Window, lib.DropBox_onDropDown(self.impl))

   @property
   def onDropDown(self):
      if hasattr(self, 'fn_DropBox_onDropDown'): return self.fn_DropBox_onDropDown
      else: return self.fn_unset_DropBox_onDropDown
   @onDropDown.setter
   def onDropDown(self, value):
      self.fn_DropBox_onDropDown = value
      lib.Instance_setMethod(self.impl, "OnDropDown".encode('u8'), cb_DropBox_onDropDown)

   def save(self):
      return lib.DropBox_save(self.impl)

   def selectRow(self, row = None):
      if row is not None and not isinstance(row, DataRow): row = DataRow(row)
      row = ffi.NULL if row is None else row.impl
      lib.DropBox_selectRow(self.impl, row)

   def setData(self, field, data):
      if field is not None and not isinstance(field, DataField): field = DataField(field)
      field = ffi.NULL if field is None else field.impl
      return lib.DropBox_setData(self.impl, field, data)

   def sort(self, field, order):
      if field is not None and not isinstance(field, DataField): field = DataField(field)
      field = ffi.NULL if field is None else field.impl
      lib.DropBox_sort(self.impl, field, order)

@ffi.callback("void(eC_Window, eC_EditBox, int, int)")
def cb_EditBox_notifyCaretMove(__e, editBox, line, charPos):
   editbox = pyOrNewObject(EditBox, editbox)
   editbox.fn_EditBox_notifyCaretMove(pyOrNewObject(EditBox, __e), editBox, line, charPos)

@ffi.callback("eC_bool(eC_Window, eC_EditBox, eC_BufferLocation *, eC_BufferLocation *, eC_bool)")
def cb_EditBox_notifyCharsAdded(__e, editBox, before, after, pasteOperation):
   editbox = pyOrNewObject(EditBox, editbox)
   return editbox.fn_EditBox_notifyCharsAdded(pyOrNewObject(EditBox, __e), editBox, BufferLocation(impl = before), BufferLocation(impl = after), pasteOperation)

@ffi.callback("eC_bool(eC_Window, eC_EditBox, eC_BufferLocation *, eC_BufferLocation *, eC_bool)")
def cb_EditBox_notifyCharsDeleted(__e, editBox, beforeLoc, after, pasteOperation):
   editbox = pyOrNewObject(EditBox, editbox)
   return editbox.fn_EditBox_notifyCharsDeleted(pyOrNewObject(EditBox, __e), editBox, BufferLocation(impl = beforeLoc), BufferLocation(impl = after), pasteOperation)

@ffi.callback("eC_bool(eC_Window, eC_EditBox, eC_EditLine *, eC_Modifiers)")
def cb_EditBox_notifyDoubleClick(__e, editBox, line, mods):
   editbox = pyOrNewObject(EditBox, editbox)
   return editbox.fn_EditBox_notifyDoubleClick(pyOrNewObject(EditBox, __e), editBox, EditLine(impl = line), Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_EditBox, int, int)")
def cb_EditBox_notifyDropped(__e, editBox, x, y):
   editbox = pyOrNewObject(EditBox, editbox)
   return editbox.fn_EditBox_notifyDropped(pyOrNewObject(EditBox, __e), editBox, x, y)

@ffi.callback("eC_bool(eC_Window, eC_EditBox, eC_Key, unichar)")
def cb_EditBox_notifyKeyDown(__e, editBox, key, ch):
   editbox = pyOrNewObject(EditBox, editbox)
   return editbox.fn_EditBox_notifyKeyDown(pyOrNewObject(EditBox, __e), editBox, Key(impl = key), ch)

@ffi.callback("eC_bool(eC_Window, eC_EditBox)")
def cb_EditBox_notifyModified(__e, editBox):
   editbox = pyOrNewObject(EditBox, editbox)
   return editbox.fn_EditBox_notifyModified(pyOrNewObject(EditBox, __e), editBox)

@ffi.callback("void(eC_Window, eC_EditBox, eC_bool)")
def cb_EditBox_notifyOvrToggle(__e, editBox, overwrite):
   editbox = pyOrNewObject(EditBox, editbox)
   editbox.fn_EditBox_notifyOvrToggle(pyOrNewObject(EditBox, __e), editBox, overwrite)

@ffi.callback("eC_bool(eC_Window, eC_EditBox)")
def cb_EditBox_notifyUnsetModified(__e, editBox):
   editbox = pyOrNewObject(EditBox, editbox)
   return editbox.fn_EditBox_notifyUnsetModified(pyOrNewObject(EditBox, __e), editBox)

@ffi.callback("void(eC_Window, eC_EditBox)")
def cb_EditBox_notifyUpdate(__e, editBox):
   editbox = pyOrNewObject(EditBox, editbox)
   editbox.fn_EditBox_notifyUpdate(pyOrNewObject(EditBox, __e), editBox)

class EditBox(CommonControl):
   class_members = [
                      'textHorzScroll',
                      'textVertScroll',
                      'readOnly',
                      'multiLine',
                      'freeCaret',
                      'tabKey',
                      'tabSize',
                      'tabSelection',
                      'smartHome',
                      'autoEmpty',
                      'noCaret',
                      'maxLineSize',
                      'maxNumLines',
                      'useTab',
                      'syntaxHighlighting',
                      'noSelect',
                      'allCaps',
                      'autoSize',
                      'wrap',
                      'numLines',
                      'lineNumber',
                      'column',
                      'charPos',
                      'firstLine',
                      'lastLine',
                      'line',
                      'contents',
                      'overwrite',
                      'caretFollowsScrolling',
                      'multiLineContents',
                      'selectionColor',
                      'selectionText',
                      'recordUndoEvent',
                      'notifyCaretMove',
                      'notifyCharsAdded',
                      'notifyCharsDeleted',
                      'notifyDoubleClick',
                      'notifyDropped',
                      'notifyKeyDown',
                      'notifyModified',
                      'notifyOvrToggle',
                      'notifyUnsetModified',
                      'notifyUpdate',
                   ]

   def init_args(self, args, kwArgs): init_args(EditBox, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def textHorzScroll(self): return lib.EditBox_get_textHorzScroll(self.impl)
   @textHorzScroll.setter
   def textHorzScroll(self, value):
      lib.EditBox_set_textHorzScroll(self.impl, value)

   @property
   def textVertScroll(self): return lib.EditBox_get_textVertScroll(self.impl)
   @textVertScroll.setter
   def textVertScroll(self, value):
      lib.EditBox_set_textVertScroll(self.impl, value)

   @property
   def readOnly(self): return lib.EditBox_get_readOnly(self.impl)
   @readOnly.setter
   def readOnly(self, value):
      lib.EditBox_set_readOnly(self.impl, value)

   @property
   def multiLine(self): return lib.EditBox_get_multiLine(self.impl)
   @multiLine.setter
   def multiLine(self, value):
      lib.EditBox_set_multiLine(self.impl, value)

   @property
   def freeCaret(self): return lib.EditBox_get_freeCaret(self.impl)
   @freeCaret.setter
   def freeCaret(self, value):
      lib.EditBox_set_freeCaret(self.impl, value)

   @property
   def tabKey(self): return lib.EditBox_get_tabKey(self.impl)
   @tabKey.setter
   def tabKey(self, value):
      lib.EditBox_set_tabKey(self.impl, value)

   @property
   def tabSize(self): return lib.EditBox_get_tabSize(self.impl)
   @tabSize.setter
   def tabSize(self, value):
      lib.EditBox_set_tabSize(self.impl, value)

   @property
   def tabSelection(self): return lib.EditBox_get_tabSelection(self.impl)
   @tabSelection.setter
   def tabSelection(self, value):
      lib.EditBox_set_tabSelection(self.impl, value)

   @property
   def smartHome(self): return lib.EditBox_get_smartHome(self.impl)
   @smartHome.setter
   def smartHome(self, value):
      lib.EditBox_set_smartHome(self.impl, value)

   @property
   def autoEmpty(self): return lib.EditBox_get_autoEmpty(self.impl)
   @autoEmpty.setter
   def autoEmpty(self, value):
      lib.EditBox_set_autoEmpty(self.impl, value)

   @property
   def noCaret(self): return lib.EditBox_get_noCaret(self.impl)
   @noCaret.setter
   def noCaret(self, value):
      lib.EditBox_set_noCaret(self.impl, value)

   @property
   def maxLineSize(self): return lib.EditBox_get_maxLineSize(self.impl)
   @maxLineSize.setter
   def maxLineSize(self, value):
      lib.EditBox_set_maxLineSize(self.impl, value)

   @property
   def maxNumLines(self): return lib.EditBox_get_maxNumLines(self.impl)
   @maxNumLines.setter
   def maxNumLines(self, value):
      lib.EditBox_set_maxNumLines(self.impl, value)

   @property
   def useTab(self): return lib.EditBox_get_useTab(self.impl)
   @useTab.setter
   def useTab(self, value):
      lib.EditBox_set_useTab(self.impl, value)

   @property
   def syntaxHighlighting(self): return pyOrNewObject(EditSyntaxHL, lib.EditBox_get_syntaxHighlighting(self.impl))
   @syntaxHighlighting.setter
   def syntaxHighlighting(self, value):
      if not isinstance(value, EditSyntaxHL): value = EditSyntaxHL(value)
      lib.EditBox_set_syntaxHighlighting(self.impl, value.impl)

   @property
   def noSelect(self): return lib.EditBox_get_noSelect(self.impl)
   @noSelect.setter
   def noSelect(self, value):
      lib.EditBox_set_noSelect(self.impl, value)

   @property
   def allCaps(self): return lib.EditBox_get_allCaps(self.impl)
   @allCaps.setter
   def allCaps(self, value):
      lib.EditBox_set_allCaps(self.impl, value)

   @property
   def autoSize(self): return lib.EditBox_get_autoSize(self.impl)
   @autoSize.setter
   def autoSize(self, value):
      lib.EditBox_set_autoSize(self.impl, value)

   @property
   def wrap(self): return lib.EditBox_get_wrap(self.impl)
   @wrap.setter
   def wrap(self, value):
      lib.EditBox_set_wrap(self.impl, value)

   @property
   def numLines(self): return lib.EditBox_get_numLines(self.impl)

   @property
   def lineNumber(self): return lib.EditBox_get_lineNumber(self.impl)

   @property
   def column(self): return lib.EditBox_get_column(self.impl)

   @property
   def charPos(self): return lib.EditBox_get_charPos(self.impl)

   @property
   def firstLine(self): return EditLine(impl = lib.EditBox_get_firstLine(self.impl))

   @property
   def lastLine(self): return EditLine(impl = lib.EditBox_get_lastLine(self.impl))

   @property
   def line(self): return EditLine(impl = lib.EditBox_get_line(self.impl))

   @property
   def contents(self): value = lib.EditBox_get_contents(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @contents.setter
   def contents(self, value):
      lib.EditBox_set_contents(self.impl, value.encode('u8'))

   @property
   def overwrite(self): return lib.EditBox_get_overwrite(self.impl)

   @property
   def caretFollowsScrolling(self): return lib.EditBox_get_caretFollowsScrolling(self.impl)
   @caretFollowsScrolling.setter
   def caretFollowsScrolling(self, value):
      lib.EditBox_set_caretFollowsScrolling(self.impl, value)

   @property
   def multiLineContents(self): value = lib.EditBox_get_multiLineContents(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')

   @property
   def selectionColor(self): return Color(impl = lib.EditBox_get_selectionColor(self.impl))
   @selectionColor.setter
   def selectionColor(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.EditBox_set_selectionColor(self.impl, value.impl)
   # @selectionColor.isset # tofix: how do we get isset?
   # def selectionColor(self): lib.EditBox_isSet_selectionColor(self.impl)

   @property
   def selectionText(self): return Color(impl = lib.EditBox_get_selectionText(self.impl))
   @selectionText.setter
   def selectionText(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.EditBox_set_selectionText(self.impl, value.impl)
   # @selectionText.isset # tofix: how do we get isset?
   # def selectionText(self): lib.EditBox_isSet_selectionText(self.impl)

   @property
   def recordUndoEvent(self): return lib.EditBox_get_recordUndoEvent(self.impl)
   @recordUndoEvent.setter
   def recordUndoEvent(self, value):
      lib.EditBox_set_recordUndoEvent(self.impl, value)

   def addCh(self, ch):
      if ch is not None and not isinstance(ch, unichar): ch = unichar(ch)
      if ch is None: ch = ffi.NULL
      return lib.EditBox_addCh(self.impl, ch)

   def addS(self, string):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      return lib.EditBox_addS(self.impl, string)

   def backSpace(self):
      lib.EditBox_backSpace(self.impl)

   def centerOnCursor(self):
      lib.EditBox_centerOnCursor(self.impl)

   def clear(self):
      lib.EditBox_clear(self.impl)

   def clearLine(self):
      lib.EditBox_clearLine(self.impl)

   def copy(self):
      lib.EditBox_copy(self.impl)

   def cut(self):
      lib.EditBox_cut(self.impl)

   def delete(self, line1, y1, x1, line2, y2, x2):
      if line1 is not None and not isinstance(line1, EditLine): line1 = EditLine(line1)
      line1 = ffi.NULL if line1 is None else line1.impl
      if line2 is not None and not isinstance(line2, EditLine): line2 = EditLine(line2)
      line2 = ffi.NULL if line2 is None else line2.impl
      lib.EditBox_delete(self.impl, ffi.cast("struct eC_EditLine *", line1), y1, x1, ffi.cast("struct eC_EditLine *", line2), y2, x2)

   def deleteSelection(self):
      lib.EditBox_deleteSelection(self.impl)

   def deselect(self):
      lib.EditBox_deselect(self.impl)

   def end(self):
      lib.EditBox_end(self.impl)

   def find(self, text, matchWord, matchCase, isSearchDown):
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      return lib.EditBox_find(self.impl, text, matchWord, matchCase, isSearchDown)

   def findInSelection(self, text, matchWord, matchCase, l2, y2, x2):
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      if l2 is not None and not isinstance(l2, EditLine): l2 = EditLine(l2)
      l2 = ffi.NULL if l2 is None else l2.impl
      return lib.EditBox_findInSelection(self.impl, text, matchWord, matchCase, ffi.cast("struct eC_EditLine *", l2), y2, x2)

   def getSel(self, text, addCr):
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      lib.EditBox_getSel(self.impl, text, addCr)

   def getSelPos(self, l1, l2, reorder):
      y1 = ffi.new("int *")
      x1 = ffi.new("int *")
      y2 = ffi.new("int *")
      x2 = ffi.new("int *")
      lib.EditBox_getSelPos(self.impl, l1, y1, x1, l2, y2, x2, reorder)
      return y1[0], x1[0], y2[0], x2[0]

   def getText(self, text, _l1, _y1, _x1, _l2, _y2, _x2, addCr, addSpaces):
      if isinstance(text, str): text = ffi.new("char[]", text.encode('u8'))
      elif text is None: text = ffi.NULL
      if _l1 is not None and not isinstance(_l1, EditLine): _l1 = EditLine(_l1)
      _l1 = ffi.NULL if _l1 is None else _l1.impl
      if _l2 is not None and not isinstance(_l2, EditLine): _l2 = EditLine(_l2)
      _l2 = ffi.NULL if _l2 is None else _l2.impl
      return lib.EditBox_getText(self.impl, text, ffi.cast("struct eC_EditLine *", _l1), _y1, _x1, ffi.cast("struct eC_EditLine *", _l2), _y2, _x2, addCr, addSpaces)

   def goToLineNum(self, lineNum):
      return lib.EditBox_goToLineNum(self.impl, lineNum)

   def goToPosition(self, line, y, x):
      if line is not None and not isinstance(line, EditLine): line = EditLine(line)
      line = ffi.NULL if line is None else line.impl
      return lib.EditBox_goToPosition(self.impl, ffi.cast("struct eC_EditLine *", line), y, x)

   def home(self):
      lib.EditBox_home(self.impl)

   def lineDown(self):
      lib.EditBox_lineDown(self.impl)

   def lineUp(self):
      lib.EditBox_lineUp(self.impl)

   def load(self, f = None):
      if f is not None and not isinstance(f, File): f = File(f)
      f = ffi.NULL if f is None else f.impl
      lib.EditBox_load(self.impl, f)

   def modified(self):
      lib.EditBox_modified(self.impl)

   def fn_unset_EditBox_notifyCaretMove(self, _ec_window, editBox, line, charPos):
      return lib.EditBox_notifyCaretMove(self.impl, _ec_window.impl, ffi.NULL if editBox is None else editBox.impl, line, charPos)

   @property
   def notifyCaretMove(self):
      if hasattr(self, 'fn_EditBox_notifyCaretMove'): return self.fn_EditBox_notifyCaretMove
      else: return self.fn_unset_EditBox_notifyCaretMove
   @notifyCaretMove.setter
   def notifyCaretMove(self, value):
      self.fn_EditBox_notifyCaretMove = value
      lib.Instance_setMethod(self.impl, "NotifyCaretMove".encode('u8'), cb_EditBox_notifyCaretMove)

   def fn_unset_EditBox_notifyCharsAdded(self, _ec_window, editBox, before, after, pasteOperation):
      return lib.EditBox_notifyCharsAdded(self.impl, _ec_window.impl, ffi.NULL if editBox is None else editBox.impl, ffi.NULL if before is None else before.impl, ffi.NULL if after is None else after.impl, pasteOperation)

   @property
   def notifyCharsAdded(self):
      if hasattr(self, 'fn_EditBox_notifyCharsAdded'): return self.fn_EditBox_notifyCharsAdded
      else: return self.fn_unset_EditBox_notifyCharsAdded
   @notifyCharsAdded.setter
   def notifyCharsAdded(self, value):
      self.fn_EditBox_notifyCharsAdded = value
      lib.Instance_setMethod(self.impl, "NotifyCharsAdded".encode('u8'), cb_EditBox_notifyCharsAdded)

   def fn_unset_EditBox_notifyCharsDeleted(self, _ec_window, editBox, beforeLoc, after, pasteOperation):
      return lib.EditBox_notifyCharsDeleted(self.impl, _ec_window.impl, ffi.NULL if editBox is None else editBox.impl, ffi.NULL if beforeLoc is None else beforeLoc.impl, ffi.NULL if after is None else after.impl, pasteOperation)

   @property
   def notifyCharsDeleted(self):
      if hasattr(self, 'fn_EditBox_notifyCharsDeleted'): return self.fn_EditBox_notifyCharsDeleted
      else: return self.fn_unset_EditBox_notifyCharsDeleted
   @notifyCharsDeleted.setter
   def notifyCharsDeleted(self, value):
      self.fn_EditBox_notifyCharsDeleted = value
      lib.Instance_setMethod(self.impl, "NotifyCharsDeleted".encode('u8'), cb_EditBox_notifyCharsDeleted)

   def fn_unset_EditBox_notifyDoubleClick(self, _ec_window, editBox, line, mods):
      return lib.EditBox_notifyDoubleClick(self.impl, _ec_window.impl, ffi.NULL if editBox is None else editBox.impl, ffi.NULL if line is None else line.impl, mods)

   @property
   def notifyDoubleClick(self):
      if hasattr(self, 'fn_EditBox_notifyDoubleClick'): return self.fn_EditBox_notifyDoubleClick
      else: return self.fn_unset_EditBox_notifyDoubleClick
   @notifyDoubleClick.setter
   def notifyDoubleClick(self, value):
      self.fn_EditBox_notifyDoubleClick = value
      lib.Instance_setMethod(self.impl, "NotifyDoubleClick".encode('u8'), cb_EditBox_notifyDoubleClick)

   def fn_unset_EditBox_notifyDropped(self, _ec_window, editBox, x, y):
      return lib.EditBox_notifyDropped(self.impl, _ec_window.impl, ffi.NULL if editBox is None else editBox.impl, x, y)

   @property
   def notifyDropped(self):
      if hasattr(self, 'fn_EditBox_notifyDropped'): return self.fn_EditBox_notifyDropped
      else: return self.fn_unset_EditBox_notifyDropped
   @notifyDropped.setter
   def notifyDropped(self, value):
      self.fn_EditBox_notifyDropped = value
      lib.Instance_setMethod(self.impl, "NotifyDropped".encode('u8'), cb_EditBox_notifyDropped)

   def fn_unset_EditBox_notifyKeyDown(self, _ec_window, editBox, key, ch):
      return lib.EditBox_notifyKeyDown(self.impl, _ec_window.impl, ffi.NULL if editBox is None else editBox.impl, key, ch)

   @property
   def notifyKeyDown(self):
      if hasattr(self, 'fn_EditBox_notifyKeyDown'): return self.fn_EditBox_notifyKeyDown
      else: return self.fn_unset_EditBox_notifyKeyDown
   @notifyKeyDown.setter
   def notifyKeyDown(self, value):
      self.fn_EditBox_notifyKeyDown = value
      lib.Instance_setMethod(self.impl, "NotifyKeyDown".encode('u8'), cb_EditBox_notifyKeyDown)

   def fn_unset_EditBox_notifyModified(self, _ec_window, editBox):
      return lib.EditBox_notifyModified(self.impl, _ec_window.impl, ffi.NULL if editBox is None else editBox.impl)

   @property
   def notifyModified(self):
      if hasattr(self, 'fn_EditBox_notifyModified'): return self.fn_EditBox_notifyModified
      else: return self.fn_unset_EditBox_notifyModified
   @notifyModified.setter
   def notifyModified(self, value):
      self.fn_EditBox_notifyModified = value
      lib.Instance_setMethod(self.impl, "NotifyModified".encode('u8'), cb_EditBox_notifyModified)

   def fn_unset_EditBox_notifyOvrToggle(self, _ec_window, editBox, overwrite):
      return lib.EditBox_notifyOvrToggle(self.impl, _ec_window.impl, ffi.NULL if editBox is None else editBox.impl, overwrite)

   @property
   def notifyOvrToggle(self):
      if hasattr(self, 'fn_EditBox_notifyOvrToggle'): return self.fn_EditBox_notifyOvrToggle
      else: return self.fn_unset_EditBox_notifyOvrToggle
   @notifyOvrToggle.setter
   def notifyOvrToggle(self, value):
      self.fn_EditBox_notifyOvrToggle = value
      lib.Instance_setMethod(self.impl, "NotifyOvrToggle".encode('u8'), cb_EditBox_notifyOvrToggle)

   def fn_unset_EditBox_notifyUnsetModified(self, _ec_window, editBox):
      return lib.EditBox_notifyUnsetModified(self.impl, _ec_window.impl, ffi.NULL if editBox is None else editBox.impl)

   @property
   def notifyUnsetModified(self):
      if hasattr(self, 'fn_EditBox_notifyUnsetModified'): return self.fn_EditBox_notifyUnsetModified
      else: return self.fn_unset_EditBox_notifyUnsetModified
   @notifyUnsetModified.setter
   def notifyUnsetModified(self, value):
      self.fn_EditBox_notifyUnsetModified = value
      lib.Instance_setMethod(self.impl, "NotifyUnsetModified".encode('u8'), cb_EditBox_notifyUnsetModified)

   def fn_unset_EditBox_notifyUpdate(self, _ec_window, editBox):
      return lib.EditBox_notifyUpdate(self.impl, _ec_window.impl, ffi.NULL if editBox is None else editBox.impl)

   @property
   def notifyUpdate(self):
      if hasattr(self, 'fn_EditBox_notifyUpdate'): return self.fn_EditBox_notifyUpdate
      else: return self.fn_unset_EditBox_notifyUpdate
   @notifyUpdate.setter
   def notifyUpdate(self, value):
      self.fn_EditBox_notifyUpdate = value
      lib.Instance_setMethod(self.impl, "NotifyUpdate".encode('u8'), cb_EditBox_notifyUpdate)

   def pageDown(self):
      lib.EditBox_pageDown(self.impl)

   def pageUp(self):
      lib.EditBox_pageUp(self.impl)

   def paste(self):
      lib.EditBox_paste(self.impl)

   def printf(self, format, *args):
      if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
      elif format is None: format = ffi.NULL
      lib.EditBox_printf(self.impl, format, *ellipsisArgs(args))

   def putCh(self, ch):
      if ch is not None and not isinstance(ch, unichar): ch = unichar(ch)
      if ch is None: ch = ffi.NULL
      lib.EditBox_putCh(self.impl, ch)

   def putS(self, string):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      lib.EditBox_putS(self.impl, string)

   def record(self, action = None):
      if action is not None and not isinstance(action, UndoAction): action = UndoAction(action)
      action = ffi.NULL if action is None else action.impl
      lib.EditBox_record(self.impl, ffi.cast("struct eC_UndoAction *", action))

   def redo(self):
      lib.EditBox_redo(self.impl)

   def save(self, f, cr):
      if f is not None and not isinstance(f, File): f = File(f)
      f = ffi.NULL if f is None else f.impl
      lib.EditBox_save(self.impl, f, cr)

   def selSize(self):
      return lib.EditBox_selSize(self.impl)

   def select(self, line1, y1, x1, line2, y2, x2):
      if line1 is not None and not isinstance(line1, EditLine): line1 = EditLine(line1)
      line1 = ffi.NULL if line1 is None else line1.impl
      if line2 is not None and not isinstance(line2, EditLine): line2 = EditLine(line2)
      line2 = ffi.NULL if line2 is None else line2.impl
      lib.EditBox_select(self.impl, ffi.cast("struct eC_EditLine *", line1), y1, x1, ffi.cast("struct eC_EditLine *", line2), y2, x2)

   def selectAll(self):
      lib.EditBox_selectAll(self.impl)

   def setContents(self, format, *args):
      if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
      elif format is None: format = ffi.NULL
      lib.EditBox_setContents(self.impl, format, *ellipsisArgs(args))

   def setCursorToView(self):
      lib.EditBox_setCursorToView(self.impl)

   def setModified(self, flag):
      lib.EditBox_setModified(self.impl, flag)

   def setSelPos(self, l1, y1, x1, l2, y2, x2):
      if l1 is not None and not isinstance(l1, EditLine): l1 = EditLine(l1)
      l1 = ffi.NULL if l1 is None else l1.impl
      if l2 is not None and not isinstance(l2, EditLine): l2 = EditLine(l2)
      l2 = ffi.NULL if l2 is None else l2.impl
      lib.EditBox_setSelPos(self.impl, ffi.cast("struct eC_EditLine *", l1), y1, x1, ffi.cast("struct eC_EditLine *", l2), y2, x2)

   def setViewToCursor(self, setCaret):
      lib.EditBox_setViewToCursor(self.impl, setCaret)

   def undo(self):
      lib.EditBox_undo(self.impl)

class EditBoxFindResult:
   notFound = lib.EditBoxFindResult_notFound
   found    = lib.EditBoxFindResult_found
   wrapped  = lib.EditBoxFindResult_wrapped

class EditBoxStream(File):
   class_members = [
                      'editBox',
                   ]

   def init_args(self, args, kwArgs): init_args(EditBoxStream, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def editBox(self): return pyOrNewObject(EditBox, lib.EditBoxStream_get_editBox(self.impl))
   @editBox.setter
   def editBox(self, value):
      if not isinstance(value, EditBox): value = EditBox(value)
      lib.EditBoxStream_set_editBox(self.impl, value.impl)

   def deleteBytes(self, count):
      lib.EditBoxStream_deleteBytes(self.impl, count)

class EditLine:
   def __init__(self, text = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_EditLine *", lib.Instance_new(lib.class_EditLine))
         if text is not None: self.text      = text
         if text is not None: self.text = text

   @property
   def text(self): value = lib.EditLine_get_text(ffi.cast("struct eC_EditLine *", self.impl)); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @text.setter
   def text(self, value):
      lib.EditLine_set_text(ffi.cast("struct eC_EditLine *", self.impl), value.encode('u8'))

   @property
   def prev(self): return EditLine(impl = lib.EditLine_get_prev(ffi.cast("struct eC_EditLine *", self.impl)))

   @property
   def next(self): return EditLine(impl = lib.EditLine_get_next(ffi.cast("struct eC_EditLine *", self.impl)))

   @property
   def count(self): return lib.EditLine_get_count(ffi.cast("struct eC_EditLine *", self.impl))

@ffi.callback("eC_bool(eC_EditSyntaxHL, eC_EditLine *)")
def cb_EditSyntaxHL_canImpactOtherLines(__e, line):
   editsyntaxhl = pyOrNewObject(EditSyntaxHL, __e)
   return editsyntaxhl.fn_EditSyntaxHL_canImpactOtherLines(editsyntaxhl, EditLine(impl = line))

@ffi.callback("void(eC_EditSyntaxHL, eC_EditLine *, eC_bool, eC_EditLine *)")
def cb_EditSyntaxHL_figureStartSyntaxStates(__e, firstLine, reset, viewLine):
   editsyntaxhl = pyOrNewObject(EditSyntaxHL, __e)
   editsyntaxhl.fn_EditSyntaxHL_figureStartSyntaxStates(editsyntaxhl, EditLine(impl = firstLine), reset, EditLine(impl = viewLine))

@ffi.callback("void(eC_EditSyntaxHL, eC_bool)")
def cb_EditSyntaxHL_gotSpace(__e, beforeEnd):
   editsyntaxhl = pyOrNewObject(EditSyntaxHL, __e)
   editsyntaxhl.fn_EditSyntaxHL_gotSpace(editsyntaxhl, beforeEnd)

@ffi.callback("void(eC_EditSyntaxHL)")
def cb_EditSyntaxHL_initDraw(__e):
   editsyntaxhl = pyOrNewObject(EditSyntaxHL, __e)
   editsyntaxhl.fn_EditSyntaxHL_initDraw(editsyntaxhl)

@ffi.callback("void(eC_EditSyntaxHL, char *, int)")
def cb_EditSyntaxHL_nextLine(__e, buffer, count):
   editsyntaxhl = pyOrNewObject(EditSyntaxHL, __e)
   editsyntaxhl.fn_EditSyntaxHL_nextLine(editsyntaxhl, buffer.encode('u8'), count)

@ffi.callback("int(eC_EditSyntaxHL, char *, int, int)")
def cb_EditSyntaxHL_parseWord(__e, buffer, count, wordLen):
   editsyntaxhl = pyOrNewObject(EditSyntaxHL, __e)
   return editsyntaxhl.fn_EditSyntaxHL_parseWord(editsyntaxhl, buffer.encode('u8'), count, wordLen)

@ffi.callback("eC_Color(eC_EditSyntaxHL, char *, int *, eC_bool, eC_Color, const char *, int *)")
def cb_EditSyntaxHL_process(__e, word, wordLen, beforeEndOfLine, defaultTextColor, buffer, c):
   editsyntaxhl = pyOrNewObject(EditSyntaxHL, __e)
   return editsyntaxhl.fn_EditSyntaxHL_process(editsyntaxhl, word.encode('u8'), wordLen, beforeEndOfLine, Color(impl = defaultTextColor), buffer.encode('u8'), c)

@ffi.callback("void(eC_EditSyntaxHL)")
def cb_EditSyntaxHL_resetState(__e):
   editsyntaxhl = pyOrNewObject(EditSyntaxHL, __e)
   editsyntaxhl.fn_EditSyntaxHL_resetState(editsyntaxhl)

@ffi.callback("void(eC_EditSyntaxHL)")
def cb_EditSyntaxHL_startLine(__e):
   editsyntaxhl = pyOrNewObject(EditSyntaxHL, __e)
   editsyntaxhl.fn_EditSyntaxHL_startLine(editsyntaxhl)

class EditSyntaxHL(Instance):
   class_members = [
                      'canImpactOtherLines',
                      'figureStartSyntaxStates',
                      'gotSpace',
                      'initDraw',
                      'nextLine',
                      'parseWord',
                      'process',
                      'resetState',
                      'startLine',
                   ]

   def init_args(self, args, kwArgs): init_args(EditSyntaxHL, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def fn_unset_EditSyntaxHL_canImpactOtherLines(self, line):
      return lib.EditSyntaxHL_canImpactOtherLines(self.impl, ffi.NULL if line is None else line.impl)

   @property
   def canImpactOtherLines(self):
      if hasattr(self, 'fn_EditSyntaxHL_canImpactOtherLines'): return self.fn_EditSyntaxHL_canImpactOtherLines
      else: return self.fn_unset_EditSyntaxHL_canImpactOtherLines
   @canImpactOtherLines.setter
   def canImpactOtherLines(self, value):
      self.fn_EditSyntaxHL_canImpactOtherLines = value
      lib.Instance_setMethod(self.impl, "CanImpactOtherLines".encode('u8'), cb_EditSyntaxHL_canImpactOtherLines)

   def fn_unset_EditSyntaxHL_figureStartSyntaxStates(self, firstLine, reset, viewLine):
      return lib.EditSyntaxHL_figureStartSyntaxStates(self.impl, ffi.NULL if firstLine is None else firstLine.impl, reset, ffi.NULL if viewLine is None else viewLine.impl)

   @property
   def figureStartSyntaxStates(self):
      if hasattr(self, 'fn_EditSyntaxHL_figureStartSyntaxStates'): return self.fn_EditSyntaxHL_figureStartSyntaxStates
      else: return self.fn_unset_EditSyntaxHL_figureStartSyntaxStates
   @figureStartSyntaxStates.setter
   def figureStartSyntaxStates(self, value):
      self.fn_EditSyntaxHL_figureStartSyntaxStates = value
      lib.Instance_setMethod(self.impl, "FigureStartSyntaxStates".encode('u8'), cb_EditSyntaxHL_figureStartSyntaxStates)

   def fn_unset_EditSyntaxHL_gotSpace(self, beforeEnd):
      return lib.EditSyntaxHL_gotSpace(self.impl, beforeEnd)

   @property
   def gotSpace(self):
      if hasattr(self, 'fn_EditSyntaxHL_gotSpace'): return self.fn_EditSyntaxHL_gotSpace
      else: return self.fn_unset_EditSyntaxHL_gotSpace
   @gotSpace.setter
   def gotSpace(self, value):
      self.fn_EditSyntaxHL_gotSpace = value
      lib.Instance_setMethod(self.impl, "GotSpace".encode('u8'), cb_EditSyntaxHL_gotSpace)

   def fn_unset_EditSyntaxHL_initDraw(self):
      return lib.EditSyntaxHL_initDraw(self.impl)

   @property
   def initDraw(self):
      if hasattr(self, 'fn_EditSyntaxHL_initDraw'): return self.fn_EditSyntaxHL_initDraw
      else: return self.fn_unset_EditSyntaxHL_initDraw
   @initDraw.setter
   def initDraw(self, value):
      self.fn_EditSyntaxHL_initDraw = value
      lib.Instance_setMethod(self.impl, "InitDraw".encode('u8'), cb_EditSyntaxHL_initDraw)

   def fn_unset_EditSyntaxHL_nextLine(self, buffer, count):
      return lib.EditSyntaxHL_nextLine(self.impl, buffer, count)

   @property
   def nextLine(self):
      if hasattr(self, 'fn_EditSyntaxHL_nextLine'): return self.fn_EditSyntaxHL_nextLine
      else: return self.fn_unset_EditSyntaxHL_nextLine
   @nextLine.setter
   def nextLine(self, value):
      self.fn_EditSyntaxHL_nextLine = value
      lib.Instance_setMethod(self.impl, "NextLine".encode('u8'), cb_EditSyntaxHL_nextLine)

   def fn_unset_EditSyntaxHL_parseWord(self, buffer, count, wordLen):
      return lib.EditSyntaxHL_parseWord(self.impl, buffer, count, wordLen)

   @property
   def parseWord(self):
      if hasattr(self, 'fn_EditSyntaxHL_parseWord'): return self.fn_EditSyntaxHL_parseWord
      else: return self.fn_unset_EditSyntaxHL_parseWord
   @parseWord.setter
   def parseWord(self, value):
      self.fn_EditSyntaxHL_parseWord = value
      lib.Instance_setMethod(self.impl, "ParseWord".encode('u8'), cb_EditSyntaxHL_parseWord)

   def fn_unset_EditSyntaxHL_process(self, word, wordLen, beforeEndOfLine, defaultTextColor, buffer, c):
      if wordLen is None: wordLen = ffi.NULL
      if c is None: c = ffi.NULL
      return lib.EditSyntaxHL_process(self.impl, word, wordLen, beforeEndOfLine, defaultTextColor, buffer, c)

   @property
   def process(self):
      if hasattr(self, 'fn_EditSyntaxHL_process'): return self.fn_EditSyntaxHL_process
      else: return self.fn_unset_EditSyntaxHL_process
   @process.setter
   def process(self, value):
      self.fn_EditSyntaxHL_process = value
      lib.Instance_setMethod(self.impl, "Process".encode('u8'), cb_EditSyntaxHL_process)

   def fn_unset_EditSyntaxHL_resetState(self):
      return lib.EditSyntaxHL_resetState(self.impl)

   @property
   def resetState(self):
      if hasattr(self, 'fn_EditSyntaxHL_resetState'): return self.fn_EditSyntaxHL_resetState
      else: return self.fn_unset_EditSyntaxHL_resetState
   @resetState.setter
   def resetState(self, value):
      self.fn_EditSyntaxHL_resetState = value
      lib.Instance_setMethod(self.impl, "ResetState".encode('u8'), cb_EditSyntaxHL_resetState)

   def fn_unset_EditSyntaxHL_startLine(self):
      return lib.EditSyntaxHL_startLine(self.impl)

   @property
   def startLine(self):
      if hasattr(self, 'fn_EditSyntaxHL_startLine'): return self.fn_EditSyntaxHL_startLine
      else: return self.fn_unset_EditSyntaxHL_startLine
   @startLine.setter
   def startLine(self, value):
      self.fn_EditSyntaxHL_startLine = value
      lib.Instance_setMethod(self.impl, "StartLine".encode('u8'), cb_EditSyntaxHL_startLine)

@ffi.callback("eC_bool(eC_Window, eC_EditableSelectorButton, char **, char **)")
def cb_EditableSelectorButton_onRename(__e, button, oldName, newName):
   editableselectorbutton = pyOrNewObject(EditableSelectorButton, editableselectorbutton)
   return editableselectorbutton.fn_EditableSelectorButton_onRename(pyOrNewObject(EditableSelectorButton, __e), button, oldName, newName)

class EditableSelectorButton(SelectorButton):
   class_members = [
                      'renameable',
                      'editBox',
                      'onRename',
                   ]

   def init_args(self, args, kwArgs): init_args(EditableSelectorButton, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def renameable(self): return lib.EditableSelectorButton_get_renameable(self.impl)
   @renameable.setter
   def renameable(self, value):
      lib.EditableSelectorButton_set_renameable(self.impl, value)

   @property
   def editBox(self): return pyOrNewObject(EditBox, lib.EditableSelectorButton_get_editBox(self.impl))

   def fn_unset_EditableSelectorButton_onRename(self, _ec_window, button, oldName, newName):
      return lib.EditableSelectorButton_onRename(self.impl, _ec_window.impl, ffi.NULL if button is None else button.impl, oldName, newName)

   @property
   def onRename(self):
      if hasattr(self, 'fn_EditableSelectorButton_onRename'): return self.fn_EditableSelectorButton_onRename
      else: return self.fn_unset_EditableSelectorButton_onRename
   @onRename.setter
   def onRename(self, value):
      self.fn_EditableSelectorButton_onRename = value
      lib.Instance_setMethod(self.impl, "OnRename".encode('u8'), cb_EditableSelectorButton_onRename)

class FilePath:
   def __init__(self, impl = None):
      String.__init__(self, impl = impl)
      if impl is not None: self.impl = impl
      else: self.impl = ffi.NULL

class Label(CommonControl):
   class_members = [
                      'labeledWindow',
                      'isGroupBox',
                   ]

   def init_args(self, args, kwArgs): init_args(Label, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def labeledWindow(self): return pyOrNewObject(Window, lib.Label_get_labeledWindow(self.impl))
   @labeledWindow.setter
   def labeledWindow(self, value):
      if not isinstance(value, Window): value = Window(value)
      lib.Label_set_labeledWindow(self.impl, value.impl)

   @property
   def isGroupBox(self): return lib.Label_get_isGroupBox(self.impl)
   @isGroupBox.setter
   def isGroupBox(self, value):
      lib.Label_set_isGroupBox(self.impl, value)

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataRow)")
def cb_ListBox_notifyChanged(__e, listBox, row):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyChanged(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataRow, row))

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataRow, eC_bool)")
def cb_ListBox_notifyCollapse(__e, listBox, row, collapsed):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyCollapse(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataRow, row), collapsed)

@ffi.callback("eC_bool(eC_Window, eC_ListBox, int, int, eC_Modifiers)")
def cb_ListBox_notifyDoubleClick(__e, listBox, x, y, mods):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyDoubleClick(pyOrNewObject(ListBox, __e), listBox, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataRow)")
def cb_ListBox_notifyEditDone(__e, listBox, row):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyEditDone(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataRow, row))

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataRow)")
def cb_ListBox_notifyEdited(__e, listBox, row):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyEdited(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataRow, row))

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataRow)")
def cb_ListBox_notifyEditing(__e, listBox, row):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyEditing(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataRow, row))

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataRow, eC_Modifiers)")
def cb_ListBox_notifyHighlight(__e, listBox, row, mods):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyHighlight(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataRow, row), Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataRow, eC_Key, unichar)")
def cb_ListBox_notifyKeyDown(__e, listBox, row, key, ch):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyKeyDown(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataRow, row), Key(impl = key), ch)

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataRow, eC_Key, unichar)")
def cb_ListBox_notifyKeyHit(__e, listBox, row, key, ch):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyKeyHit(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataRow, row), Key(impl = key), ch)

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataRow)")
def cb_ListBox_notifyModified(__e, listBox, row):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyModified(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataRow, row))

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataRow, eC_Modifiers)")
def cb_ListBox_notifyMove(__e, listBox, row, mods):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyMove(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataRow, row), Modifiers(impl = mods))

@ffi.callback("void(eC_Window, eC_ListBox, eC_DataRow, eC_Modifiers)")
def cb_ListBox_notifyMoved(__e, listBox, row, mods):
   listbox = pyOrNewObject(ListBox, listbox)
   listbox.fn_ListBox_notifyMoved(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataRow, row), Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataField, eC_Modifiers)")
def cb_ListBox_notifyMovedField(__e, listBox, field, mods):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyMovedField(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataField, field), Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataRow, eC_Modifiers)")
def cb_ListBox_notifyReclick(__e, listBox, row, mods):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyReclick(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataRow, row), Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataField, eC_Modifiers)")
def cb_ListBox_notifyResized(__e, listBox, field, mods):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyResized(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataField, field), Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_ListBox, int, int, eC_Modifiers)")
def cb_ListBox_notifyRightClick(__e, listBox, x, y, mods):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifyRightClick(pyOrNewObject(ListBox, __e), listBox, x, y, Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataRow, eC_Modifiers)")
def cb_ListBox_notifySelect(__e, listBox, row, mods):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifySelect(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataRow, row), Modifiers(impl = mods))

@ffi.callback("eC_bool(eC_Window, eC_ListBox, eC_DataField, eC_Modifiers)")
def cb_ListBox_notifySort(__e, listBox, field, mods):
   listbox = pyOrNewObject(ListBox, listbox)
   return listbox.fn_ListBox_notifySort(pyOrNewObject(ListBox, __e), listBox, pyOrNewObject(DataField, field), Modifiers(impl = mods))

class ListBox(CommonControl):
   class_members = [
                      'freeSelect',
                      'currentRow',
                      'currentField',
                      'rowHeight',
                      'typingTimeout',
                      'moveRows',
                      'moveFields',
                      'resizable',
                      'autoScroll',
                      'alwaysHighLight',
                      'hasClearHeader',
                      'hasHeader',
                      'multiSelect',
                      'alwaysEdit',
                      'fullRowSelect',
                      'collapseControl',
                      'treeBranches',
                      'rootCollapseButton',
                      'sortable',
                      'noDragging',
                      'fillLastField',
                      'numSelections',
                      'currentIndex',
                      'lastRow',
                      'firstRow',
                      'rowCount',
                      'firstField',
                      'selectionColor',
                      'selectionText',
                      'stippleColor',
                      'expandOnAdd',
                      'typingTimeOut',
                      'notifyChanged',
                      'notifyCollapse',
                      'notifyDoubleClick',
                      'notifyEditDone',
                      'notifyEdited',
                      'notifyEditing',
                      'notifyHighlight',
                      'notifyKeyDown',
                      'notifyKeyHit',
                      'notifyModified',
                      'notifyMove',
                      'notifyMoved',
                      'notifyMovedField',
                      'notifyReclick',
                      'notifyResized',
                      'notifyRightClick',
                      'notifySelect',
                      'notifySort',
                   ]

   def init_args(self, args, kwArgs): init_args(ListBox, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def freeSelect(self): return lib.ListBox_get_freeSelect(self.impl)
   @freeSelect.setter
   def freeSelect(self, value):
      lib.ListBox_set_freeSelect(self.impl, value)

   @property
   def currentRow(self): return pyOrNewObject(DataRow, lib.ListBox_get_currentRow(self.impl))
   @currentRow.setter
   def currentRow(self, value):
      if not isinstance(value, DataRow): value = DataRow(value)
      lib.ListBox_set_currentRow(self.impl, value.impl)

   @property
   def currentField(self): return pyOrNewObject(DataField, lib.ListBox_get_currentField(self.impl))
   @currentField.setter
   def currentField(self, value):
      if not isinstance(value, DataField): value = DataField(value)
      lib.ListBox_set_currentField(self.impl, value.impl)

   @property
   def rowHeight(self): return lib.ListBox_get_rowHeight(self.impl)
   @rowHeight.setter
   def rowHeight(self, value):
      lib.ListBox_set_rowHeight(self.impl, value)
   # @rowHeight.isset # tofix: how do we get isset?
   # def rowHeight(self): lib.ListBox_isSet_rowHeight(self.impl)

   @property
   def typingTimeout(self): return Seconds(impl = lib.ListBox_get_typingTimeout(self.impl))
   @typingTimeout.setter
   def typingTimeout(self, value):
      if not isinstance(value, Time): value = Seconds(value)
      lib.ListBox_set_typingTimeout(self.impl, value.impl)

   @property
   def moveRows(self): return lib.ListBox_get_moveRows(self.impl)
   @moveRows.setter
   def moveRows(self, value):
      lib.ListBox_set_moveRows(self.impl, value)

   @property
   def moveFields(self): return lib.ListBox_get_moveFields(self.impl)
   @moveFields.setter
   def moveFields(self, value):
      lib.ListBox_set_moveFields(self.impl, value)

   @property
   def resizable(self): return lib.ListBox_get_resizable(self.impl)
   @resizable.setter
   def resizable(self, value):
      lib.ListBox_set_resizable(self.impl, value)

   @property
   def autoScroll(self): return lib.ListBox_get_autoScroll(self.impl)
   @autoScroll.setter
   def autoScroll(self, value):
      lib.ListBox_set_autoScroll(self.impl, value)

   @property
   def alwaysHighLight(self): return lib.ListBox_get_alwaysHighLight(self.impl)
   @alwaysHighLight.setter
   def alwaysHighLight(self, value):
      lib.ListBox_set_alwaysHighLight(self.impl, value)

   @property
   def hasClearHeader(self): return lib.ListBox_get_hasClearHeader(self.impl)
   @hasClearHeader.setter
   def hasClearHeader(self, value):
      lib.ListBox_set_hasClearHeader(self.impl, value)

   @property
   def hasHeader(self): return lib.ListBox_get_hasHeader(self.impl)
   @hasHeader.setter
   def hasHeader(self, value):
      lib.ListBox_set_hasHeader(self.impl, value)

   @property
   def multiSelect(self): return lib.ListBox_get_multiSelect(self.impl)
   @multiSelect.setter
   def multiSelect(self, value):
      lib.ListBox_set_multiSelect(self.impl, value)

   @property
   def alwaysEdit(self): return lib.ListBox_get_alwaysEdit(self.impl)
   @alwaysEdit.setter
   def alwaysEdit(self, value):
      lib.ListBox_set_alwaysEdit(self.impl, value)

   @property
   def fullRowSelect(self): return lib.ListBox_get_fullRowSelect(self.impl)
   @fullRowSelect.setter
   def fullRowSelect(self, value):
      lib.ListBox_set_fullRowSelect(self.impl, value)

   @property
   def collapseControl(self): return lib.ListBox_get_collapseControl(self.impl)
   @collapseControl.setter
   def collapseControl(self, value):
      lib.ListBox_set_collapseControl(self.impl, value)

   @property
   def treeBranches(self): return lib.ListBox_get_treeBranches(self.impl)
   @treeBranches.setter
   def treeBranches(self, value):
      lib.ListBox_set_treeBranches(self.impl, value)

   @property
   def rootCollapseButton(self): return lib.ListBox_get_rootCollapseButton(self.impl)
   @rootCollapseButton.setter
   def rootCollapseButton(self, value):
      lib.ListBox_set_rootCollapseButton(self.impl, value)

   @property
   def sortable(self): return lib.ListBox_get_sortable(self.impl)
   @sortable.setter
   def sortable(self, value):
      lib.ListBox_set_sortable(self.impl, value)

   @property
   def noDragging(self): return lib.ListBox_get_noDragging(self.impl)
   @noDragging.setter
   def noDragging(self, value):
      lib.ListBox_set_noDragging(self.impl, value)

   @property
   def fillLastField(self): return lib.ListBox_get_fillLastField(self.impl)
   @fillLastField.setter
   def fillLastField(self, value):
      lib.ListBox_set_fillLastField(self.impl, value)

   @property
   def numSelections(self): return lib.ListBox_get_numSelections(self.impl)

   @property
   def currentIndex(self): return lib.ListBox_get_currentIndex(self.impl)

   @property
   def lastRow(self): return pyOrNewObject(DataRow, lib.ListBox_get_lastRow(self.impl))

   @property
   def firstRow(self): return pyOrNewObject(DataRow, lib.ListBox_get_firstRow(self.impl))

   @property
   def rowCount(self): return lib.ListBox_get_rowCount(self.impl)

   @property
   def firstField(self): return pyOrNewObject(DataField, lib.ListBox_get_firstField(self.impl))

   @property
   def selectionColor(self): return Color(impl = lib.ListBox_get_selectionColor(self.impl))
   @selectionColor.setter
   def selectionColor(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.ListBox_set_selectionColor(self.impl, value.impl)
   # @selectionColor.isset # tofix: how do we get isset?
   # def selectionColor(self): lib.ListBox_isSet_selectionColor(self.impl)

   @property
   def selectionText(self): return Color(impl = lib.ListBox_get_selectionText(self.impl))
   @selectionText.setter
   def selectionText(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.ListBox_set_selectionText(self.impl, value.impl)
   # @selectionText.isset # tofix: how do we get isset?
   # def selectionText(self): lib.ListBox_isSet_selectionText(self.impl)

   @property
   def stippleColor(self): return Color(impl = lib.ListBox_get_stippleColor(self.impl))
   @stippleColor.setter
   def stippleColor(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.ListBox_set_stippleColor(self.impl, value.impl)

   @property
   def expandOnAdd(self): return lib.ListBox_get_expandOnAdd(self.impl)
   @expandOnAdd.setter
   def expandOnAdd(self, value):
      lib.ListBox_set_expandOnAdd(self.impl, value)

   @property
   def typingTimeOut(self): return IPTR(lib, ffi, self, ListBox).typingTimeOut
   @typingTimeOut.setter
   def typingTimeOut(self, value): IPTR(lib, ffi, self, ListBox).typingTimeOut = value

   def addField(self, addedField = None):
      if addedField is not None and not isinstance(addedField, DataField): addedField = DataField(addedField)
      addedField = ffi.NULL if addedField is None else addedField.impl
      lib.ListBox_addField(self.impl, addedField)

   def addRow(self):
      return pyOrNewObject(DataRow, lib.ListBox_addRow(self.impl))

   def addRowAfter(self, after = None):
      if after is not None and not isinstance(after, DataRow): after = DataRow(after)
      after = ffi.NULL if after is None else after.impl
      return pyOrNewObject(DataRow, lib.ListBox_addRowAfter(self.impl, after))

   def addRowNone(self):
      return pyOrNewObject(DataRow, lib.ListBox_addRowNone(self.impl))

   def addString(self, string):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      return pyOrNewObject(DataRow, lib.ListBox_addString(self.impl, string))

   def addStringf(self, format, *args):
      if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
      elif format is None: format = ffi.NULL
      return pyOrNewObject(DataRow, lib.ListBox_addStringf(self.impl, format, *ellipsisArgs(args)))

   def clear(self):
      lib.ListBox_clear(self.impl)

   def clearFields(self):
      lib.ListBox_clearFields(self.impl)

   def deleteRow(self, row = None):
      if row is not None and not isinstance(row, DataRow): row = DataRow(row)
      row = ffi.NULL if row is None else row.impl
      lib.ListBox_deleteRow(self.impl, row)

   def findRow(self, tag):
      return pyOrNewObject(DataRow, lib.ListBox_findRow(self.impl, tag))

   def findString(self, searchedString):
      if isinstance(searchedString, str): searchedString = ffi.new("char[]", searchedString.encode('u8'))
      elif searchedString is None: searchedString = ffi.NULL
      return pyOrNewObject(DataRow, lib.ListBox_findString(self.impl, searchedString))

   def findSubRow(self, tag):
      return pyOrNewObject(DataRow, lib.ListBox_findSubRow(self.impl, tag))

   def findSubString(self, subString):
      if isinstance(subString, str): subString = ffi.new("char[]", subString.encode('u8'))
      elif subString is None: subString = ffi.NULL
      return pyOrNewObject(DataRow, lib.ListBox_findSubString(self.impl, subString))

   def findSubStringAfter(self, after, subString):
      if after is not None and not isinstance(after, DataRow): after = DataRow(after)
      after = ffi.NULL if after is None else after.impl
      if isinstance(subString, str): subString = ffi.new("char[]", subString.encode('u8'))
      elif subString is None: subString = ffi.NULL
      return pyOrNewObject(DataRow, lib.ListBox_findSubStringAfter(self.impl, after, subString))

   def findSubStringi(self, subString):
      if isinstance(subString, str): subString = ffi.new("char[]", subString.encode('u8'))
      elif subString is None: subString = ffi.NULL
      return pyOrNewObject(DataRow, lib.ListBox_findSubStringi(self.impl, subString))

   def getData(self, field = None):
      if field is not None and not isinstance(field, DataField): field = DataField(field)
      field = ffi.NULL if field is None else field.impl
      return lib.ListBox_getData(self.impl, field)

   def getMultiSelection(self, list = None):
      if list is not None and not isinstance(list, OldList): list = OldList(list)
      list = ffi.NULL if list is None else list.impl
      lib.ListBox_getMultiSelection(self.impl, ffi.cast("eC_OldList *", list))

   def getTag(self):
      return lib.ListBox_getTag(self.impl)

   def multiSort(self, fields = None):
      lib.ListBox_multiSort(self.impl, Array.impl)

   def fn_unset_ListBox_notifyChanged(self, _ec_window, listBox, row):
      return lib.ListBox_notifyChanged(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if row is None else row.impl)

   @property
   def notifyChanged(self):
      if hasattr(self, 'fn_ListBox_notifyChanged'): return self.fn_ListBox_notifyChanged
      else: return self.fn_unset_ListBox_notifyChanged
   @notifyChanged.setter
   def notifyChanged(self, value):
      self.fn_ListBox_notifyChanged = value
      lib.Instance_setMethod(self.impl, "NotifyChanged".encode('u8'), cb_ListBox_notifyChanged)

   def fn_unset_ListBox_notifyCollapse(self, _ec_window, listBox, row, collapsed):
      return lib.ListBox_notifyCollapse(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if row is None else row.impl, collapsed)

   @property
   def notifyCollapse(self):
      if hasattr(self, 'fn_ListBox_notifyCollapse'): return self.fn_ListBox_notifyCollapse
      else: return self.fn_unset_ListBox_notifyCollapse
   @notifyCollapse.setter
   def notifyCollapse(self, value):
      self.fn_ListBox_notifyCollapse = value
      lib.Instance_setMethod(self.impl, "NotifyCollapse".encode('u8'), cb_ListBox_notifyCollapse)

   def fn_unset_ListBox_notifyDoubleClick(self, _ec_window, listBox, x, y, mods):
      return lib.ListBox_notifyDoubleClick(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, x, y, mods)

   @property
   def notifyDoubleClick(self):
      if hasattr(self, 'fn_ListBox_notifyDoubleClick'): return self.fn_ListBox_notifyDoubleClick
      else: return self.fn_unset_ListBox_notifyDoubleClick
   @notifyDoubleClick.setter
   def notifyDoubleClick(self, value):
      self.fn_ListBox_notifyDoubleClick = value
      lib.Instance_setMethod(self.impl, "NotifyDoubleClick".encode('u8'), cb_ListBox_notifyDoubleClick)

   def fn_unset_ListBox_notifyEditDone(self, _ec_window, listBox, row):
      return lib.ListBox_notifyEditDone(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if row is None else row.impl)

   @property
   def notifyEditDone(self):
      if hasattr(self, 'fn_ListBox_notifyEditDone'): return self.fn_ListBox_notifyEditDone
      else: return self.fn_unset_ListBox_notifyEditDone
   @notifyEditDone.setter
   def notifyEditDone(self, value):
      self.fn_ListBox_notifyEditDone = value
      lib.Instance_setMethod(self.impl, "NotifyEditDone".encode('u8'), cb_ListBox_notifyEditDone)

   def fn_unset_ListBox_notifyEdited(self, _ec_window, listBox, row):
      return lib.ListBox_notifyEdited(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if row is None else row.impl)

   @property
   def notifyEdited(self):
      if hasattr(self, 'fn_ListBox_notifyEdited'): return self.fn_ListBox_notifyEdited
      else: return self.fn_unset_ListBox_notifyEdited
   @notifyEdited.setter
   def notifyEdited(self, value):
      self.fn_ListBox_notifyEdited = value
      lib.Instance_setMethod(self.impl, "NotifyEdited".encode('u8'), cb_ListBox_notifyEdited)

   def fn_unset_ListBox_notifyEditing(self, _ec_window, listBox, row):
      return lib.ListBox_notifyEditing(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if row is None else row.impl)

   @property
   def notifyEditing(self):
      if hasattr(self, 'fn_ListBox_notifyEditing'): return self.fn_ListBox_notifyEditing
      else: return self.fn_unset_ListBox_notifyEditing
   @notifyEditing.setter
   def notifyEditing(self, value):
      self.fn_ListBox_notifyEditing = value
      lib.Instance_setMethod(self.impl, "NotifyEditing".encode('u8'), cb_ListBox_notifyEditing)

   def fn_unset_ListBox_notifyHighlight(self, _ec_window, listBox, row, mods):
      return lib.ListBox_notifyHighlight(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if row is None else row.impl, mods)

   @property
   def notifyHighlight(self):
      if hasattr(self, 'fn_ListBox_notifyHighlight'): return self.fn_ListBox_notifyHighlight
      else: return self.fn_unset_ListBox_notifyHighlight
   @notifyHighlight.setter
   def notifyHighlight(self, value):
      self.fn_ListBox_notifyHighlight = value
      lib.Instance_setMethod(self.impl, "NotifyHighlight".encode('u8'), cb_ListBox_notifyHighlight)

   def fn_unset_ListBox_notifyKeyDown(self, _ec_window, listBox, row, key, ch):
      return lib.ListBox_notifyKeyDown(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if row is None else row.impl, key, ch)

   @property
   def notifyKeyDown(self):
      if hasattr(self, 'fn_ListBox_notifyKeyDown'): return self.fn_ListBox_notifyKeyDown
      else: return self.fn_unset_ListBox_notifyKeyDown
   @notifyKeyDown.setter
   def notifyKeyDown(self, value):
      self.fn_ListBox_notifyKeyDown = value
      lib.Instance_setMethod(self.impl, "NotifyKeyDown".encode('u8'), cb_ListBox_notifyKeyDown)

   def fn_unset_ListBox_notifyKeyHit(self, _ec_window, listBox, row, key, ch):
      return lib.ListBox_notifyKeyHit(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if row is None else row.impl, key, ch)

   @property
   def notifyKeyHit(self):
      if hasattr(self, 'fn_ListBox_notifyKeyHit'): return self.fn_ListBox_notifyKeyHit
      else: return self.fn_unset_ListBox_notifyKeyHit
   @notifyKeyHit.setter
   def notifyKeyHit(self, value):
      self.fn_ListBox_notifyKeyHit = value
      lib.Instance_setMethod(self.impl, "NotifyKeyHit".encode('u8'), cb_ListBox_notifyKeyHit)

   def fn_unset_ListBox_notifyModified(self, _ec_window, listBox, row):
      return lib.ListBox_notifyModified(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if row is None else row.impl)

   @property
   def notifyModified(self):
      if hasattr(self, 'fn_ListBox_notifyModified'): return self.fn_ListBox_notifyModified
      else: return self.fn_unset_ListBox_notifyModified
   @notifyModified.setter
   def notifyModified(self, value):
      self.fn_ListBox_notifyModified = value
      lib.Instance_setMethod(self.impl, "NotifyModified".encode('u8'), cb_ListBox_notifyModified)

   def fn_unset_ListBox_notifyMove(self, _ec_window, listBox, row, mods):
      return lib.ListBox_notifyMove(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if row is None else row.impl, mods)

   @property
   def notifyMove(self):
      if hasattr(self, 'fn_ListBox_notifyMove'): return self.fn_ListBox_notifyMove
      else: return self.fn_unset_ListBox_notifyMove
   @notifyMove.setter
   def notifyMove(self, value):
      self.fn_ListBox_notifyMove = value
      lib.Instance_setMethod(self.impl, "NotifyMove".encode('u8'), cb_ListBox_notifyMove)

   def fn_unset_ListBox_notifyMoved(self, _ec_window, listBox, row, mods):
      return lib.ListBox_notifyMoved(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if row is None else row.impl, mods)

   @property
   def notifyMoved(self):
      if hasattr(self, 'fn_ListBox_notifyMoved'): return self.fn_ListBox_notifyMoved
      else: return self.fn_unset_ListBox_notifyMoved
   @notifyMoved.setter
   def notifyMoved(self, value):
      self.fn_ListBox_notifyMoved = value
      lib.Instance_setMethod(self.impl, "NotifyMoved".encode('u8'), cb_ListBox_notifyMoved)

   def fn_unset_ListBox_notifyMovedField(self, _ec_window, listBox, field, mods):
      return lib.ListBox_notifyMovedField(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if field is None else field.impl, mods)

   @property
   def notifyMovedField(self):
      if hasattr(self, 'fn_ListBox_notifyMovedField'): return self.fn_ListBox_notifyMovedField
      else: return self.fn_unset_ListBox_notifyMovedField
   @notifyMovedField.setter
   def notifyMovedField(self, value):
      self.fn_ListBox_notifyMovedField = value
      lib.Instance_setMethod(self.impl, "NotifyMovedField".encode('u8'), cb_ListBox_notifyMovedField)

   def fn_unset_ListBox_notifyReclick(self, _ec_window, listBox, row, mods):
      return lib.ListBox_notifyReclick(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if row is None else row.impl, mods)

   @property
   def notifyReclick(self):
      if hasattr(self, 'fn_ListBox_notifyReclick'): return self.fn_ListBox_notifyReclick
      else: return self.fn_unset_ListBox_notifyReclick
   @notifyReclick.setter
   def notifyReclick(self, value):
      self.fn_ListBox_notifyReclick = value
      lib.Instance_setMethod(self.impl, "NotifyReclick".encode('u8'), cb_ListBox_notifyReclick)

   def fn_unset_ListBox_notifyResized(self, _ec_window, listBox, field, mods):
      return lib.ListBox_notifyResized(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if field is None else field.impl, mods)

   @property
   def notifyResized(self):
      if hasattr(self, 'fn_ListBox_notifyResized'): return self.fn_ListBox_notifyResized
      else: return self.fn_unset_ListBox_notifyResized
   @notifyResized.setter
   def notifyResized(self, value):
      self.fn_ListBox_notifyResized = value
      lib.Instance_setMethod(self.impl, "NotifyResized".encode('u8'), cb_ListBox_notifyResized)

   def fn_unset_ListBox_notifyRightClick(self, _ec_window, listBox, x, y, mods):
      return lib.ListBox_notifyRightClick(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, x, y, mods)

   @property
   def notifyRightClick(self):
      if hasattr(self, 'fn_ListBox_notifyRightClick'): return self.fn_ListBox_notifyRightClick
      else: return self.fn_unset_ListBox_notifyRightClick
   @notifyRightClick.setter
   def notifyRightClick(self, value):
      self.fn_ListBox_notifyRightClick = value
      lib.Instance_setMethod(self.impl, "NotifyRightClick".encode('u8'), cb_ListBox_notifyRightClick)

   def fn_unset_ListBox_notifySelect(self, _ec_window, listBox, row, mods):
      return lib.ListBox_notifySelect(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if row is None else row.impl, mods)

   @property
   def notifySelect(self):
      if hasattr(self, 'fn_ListBox_notifySelect'): return self.fn_ListBox_notifySelect
      else: return self.fn_unset_ListBox_notifySelect
   @notifySelect.setter
   def notifySelect(self, value):
      self.fn_ListBox_notifySelect = value
      lib.Instance_setMethod(self.impl, "NotifySelect".encode('u8'), cb_ListBox_notifySelect)

   def fn_unset_ListBox_notifySort(self, _ec_window, listBox, field, mods):
      return lib.ListBox_notifySort(self.impl, _ec_window.impl, ffi.NULL if listBox is None else listBox.impl, ffi.NULL if field is None else field.impl, mods)

   @property
   def notifySort(self):
      if hasattr(self, 'fn_ListBox_notifySort'): return self.fn_ListBox_notifySort
      else: return self.fn_unset_ListBox_notifySort
   @notifySort.setter
   def notifySort(self, value):
      self.fn_ListBox_notifySort = value
      lib.Instance_setMethod(self.impl, "NotifySort".encode('u8'), cb_ListBox_notifySort)

   def removeField(self, field = None):
      if field is not None and not isinstance(field, DataField): field = DataField(field)
      field = ffi.NULL if field is None else field.impl
      lib.ListBox_removeField(self.impl, field)

   def selectRow(self, row = None):
      if row is not None and not isinstance(row, DataRow): row = DataRow(row)
      row = ffi.NULL if row is None else row.impl
      lib.ListBox_selectRow(self.impl, row)

   def setData(self, field, data):
      if field is not None and not isinstance(field, DataField): field = DataField(field)
      field = ffi.NULL if field is None else field.impl
      return lib.ListBox_setData(self.impl, field, data)

   def sort(self, field, order):
      if field is not None and not isinstance(field, DataField): field = DataField(field)
      field = ffi.NULL if field is None else field.impl
      lib.ListBox_sort(self.impl, field, order)

   def sortAlsoBy(self, field, order):
      if field is not None and not isinstance(field, DataField): field = DataField(field)
      field = ffi.NULL if field is None else field.impl
      lib.ListBox_sortAlsoBy(self.impl, field, order)

   def stopEditing(self, save):
      lib.ListBox_stopEditing(self.impl, save)

class Menu(Instance):
   class_members = [
                      'parent',
                      'text',
                      'hotKey',
                      'hasMargin',
                      'copyText',
                   ]

   def init_args(self, args, kwArgs): init_args(Menu, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def parent(self): return None
   @parent.setter
   def parent(self, value):
      if not isinstance(value, Menu): value = Menu(value)
      lib.Menu_set_parent(self.impl, value.impl)

   @property
   def text(self): return None
   @text.setter
   def text(self, value):
      lib.Menu_set_text(self.impl, value.encode('u8'))

   @property
   def hotKey(self): return None
   @hotKey.setter
   def hotKey(self, value):
      if not isinstance(value, Key): value = Key(value)
      lib.Menu_set_hotKey(self.impl, value.impl)

   @property
   def hasMargin(self): return None
   @hasMargin.setter
   def hasMargin(self, value):
      lib.Menu_set_hasMargin(self.impl, value)

   @property
   def copyText(self): return None
   @copyText.setter
   def copyText(self, value):
      lib.Menu_set_copyText(self.impl, value)

   def addDynamic(self, addedItem, master, persistent):
      if addedItem is not None and not isinstance(addedItem, MenuItem): addedItem = MenuItem(addedItem)
      addedItem = ffi.NULL if addedItem is None else addedItem.impl
      if master is not None and not isinstance(master, Window): master = Window(master)
      master = ffi.NULL if master is None else master.impl
      lib.Menu_addDynamic(self.impl, addedItem, master, persistent)

   def addItem(self, item = None):
      if item is not None and not isinstance(item, MenuItem): item = MenuItem(item)
      item = ffi.NULL if item is None else item.impl
      lib.Menu_addItem(self.impl, item)

   def addSubMenu(self, subMenu = None):
      if subMenu is not None and not isinstance(subMenu, Menu): subMenu = Menu(subMenu)
      subMenu = ffi.NULL if subMenu is None else subMenu.impl
      lib.Menu_addSubMenu(self.impl, subMenu)

   def clean(self, window = None):
      if window is not None and not isinstance(window, Window): window = Window(window)
      window = ffi.NULL if window is None else window.impl
      lib.Menu_clean(self.impl, window)

   def clear(self):
      lib.Menu_clear(self.impl)

   def findItem(self, notifySelect, id):
      return pyOrNewObject(MenuItem, lib.Menu_findItem(self.impl, id))

   def findMenu(self, name):
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      return pyOrNewObject(Menu, lib.Menu_findMenu(self.impl, name))

   def merge(self, menuBeingMerged, menuBar, window = None):
      if menuBeingMerged is not None and not isinstance(menuBeingMerged, Menu): menuBeingMerged = Menu(menuBeingMerged)
      menuBeingMerged = ffi.NULL if menuBeingMerged is None else menuBeingMerged.impl
      if window is not None and not isinstance(window, Window): window = Window(window)
      window = ffi.NULL if window is None else window.impl
      lib.Menu_merge(self.impl, menuBeingMerged, menuBar, window)

   def removeItem(self, item = None):
      if item is not None and not isinstance(item, MenuItem): item = MenuItem(item)
      item = ffi.NULL if item is None else item.impl
      lib.Menu_removeItem(self.impl, item)

class MenuDivider(MenuItem):
   class_members = []

   def init_args(self, args, kwArgs): init_args(MenuDivider, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class MenuPlacement(MenuItem):
   class_members = []

   def init_args(self, args, kwArgs): init_args(MenuPlacement, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class OldArray(Instance):
   class_members = [
                      'type',
                      'size',
                      'data',
                   ]

   def init_args(self, args, kwArgs): init_args(OldArray, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def type(self): return Class(impl = IPTR(lib, ffi, self, OldArray).type)
   @type.setter
   def type(self, value):
      if not isinstance(value, Class): value = Class(value)
      IPTR(lib, ffi, self, OldArray).type = value.impl

   @property
   def size(self): return lib.OldArray_get_size(self.impl)
   @size.setter
   def size(self, value):
      lib.OldArray_set_size(self.impl, value)

   @property
   def data(self): return None
   @data.setter
   def data(self, value):
      lib.OldArray_set_data(self.impl, value)

@ffi.callback("eC_bool(eC_Window, eC_PaneSplitter)")
def cb_PaneSplitter_notifyResized(__e, splitter):
   panesplitter = pyOrNewObject(PaneSplitter, panesplitter)
   return panesplitter.fn_PaneSplitter_notifyResized(pyOrNewObject(PaneSplitter, __e), splitter)

class PaneSplitter(Window):
   class_members = [
                      'toolSize',
                      'toolGap',
                      'leftPane',
                      'rightPane',
                      'topPane',
                      'bottomPane',
                      'scaleSplit',
                      'orientation',
                      'split',
                      'notifyResized',
                   ]

   def init_args(self, args, kwArgs): init_args(PaneSplitter, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def toolSize(self): return lib.PaneSplitter_get_toolSize(self.impl)
   @toolSize.setter
   def toolSize(self, value):
      lib.PaneSplitter_set_toolSize(self.impl, value)

   @property
   def toolGap(self): return lib.PaneSplitter_get_toolGap(self.impl)
   @toolGap.setter
   def toolGap(self, value):
      lib.PaneSplitter_set_toolGap(self.impl, value)

   @property
   def leftPane(self): return pyOrNewObject(Window, lib.PaneSplitter_get_leftPane(self.impl))
   @leftPane.setter
   def leftPane(self, value):
      if not isinstance(value, Window): value = Window(value)
      lib.PaneSplitter_set_leftPane(self.impl, value.impl)

   @property
   def rightPane(self): return pyOrNewObject(Window, lib.PaneSplitter_get_rightPane(self.impl))
   @rightPane.setter
   def rightPane(self, value):
      if not isinstance(value, Window): value = Window(value)
      lib.PaneSplitter_set_rightPane(self.impl, value.impl)

   @property
   def topPane(self): return pyOrNewObject(Window, lib.PaneSplitter_get_topPane(self.impl))
   @topPane.setter
   def topPane(self, value):
      if not isinstance(value, Window): value = Window(value)
      lib.PaneSplitter_set_topPane(self.impl, value.impl)

   @property
   def bottomPane(self): return pyOrNewObject(Window, lib.PaneSplitter_get_bottomPane(self.impl))
   @bottomPane.setter
   def bottomPane(self, value):
      if not isinstance(value, Window): value = Window(value)
      lib.PaneSplitter_set_bottomPane(self.impl, value.impl)

   @property
   def scaleSplit(self): return lib.PaneSplitter_get_scaleSplit(self.impl)
   @scaleSplit.setter
   def scaleSplit(self, value):
      lib.PaneSplitter_set_scaleSplit(self.impl, value)

   @property
   def orientation(self): return lib.PaneSplitter_get_orientation(self.impl)
   @orientation.setter
   def orientation(self, value):
      lib.PaneSplitter_set_orientation(self.impl, value)

   @property
   def split(self): return lib.PaneSplitter_get_split(self.impl)
   @split.setter
   def split(self, value):
      lib.PaneSplitter_set_split(self.impl, value)

   def fn_unset_PaneSplitter_notifyResized(self, _ec_window, splitter):
      return lib.PaneSplitter_notifyResized(self.impl, _ec_window.impl, ffi.NULL if splitter is None else splitter.impl)

   @property
   def notifyResized(self):
      if hasattr(self, 'fn_PaneSplitter_notifyResized'): return self.fn_PaneSplitter_notifyResized
      else: return self.fn_unset_PaneSplitter_notifyResized
   @notifyResized.setter
   def notifyResized(self, value):
      self.fn_PaneSplitter_notifyResized = value
      lib.Instance_setMethod(self.impl, "NotifyResized".encode('u8'), cb_PaneSplitter_notifyResized)

@ffi.callback("eC_bool(eC_Window, eC_PathBox)")
def cb_PathBox_notifyModified(__e, pathBox):
   pathbox = pyOrNewObject(PathBox, pathbox)
   return pathbox.fn_PathBox_notifyModified(pyOrNewObject(PathBox, __e), pathBox)

class PathBox(CommonControl):
   class_members = [
                      'editBox',
                      'typeExpected',
                      'browseDialog',
                      'path',
                      'slashPath',
                      'systemPath',
                      'selectionColor',
                      'selectionText',
                      'notifyModified',
                   ]

   def init_args(self, args, kwArgs): init_args(PathBox, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def editBox(self): return pyOrNewObject(EditBox, lib.PathBox_get_editBox(self.impl))

   @property
   def typeExpected(self): return None
   @typeExpected.setter
   def typeExpected(self, value):
      lib.PathBox_set_typeExpected(self.impl, value)

   @property
   def browseDialog(self): return pyOrNewObject(FileDialog, lib.PathBox_get_browseDialog(self.impl))
   @browseDialog.setter
   def browseDialog(self, value):
      if not isinstance(value, FileDialog): value = FileDialog(value)
      lib.PathBox_set_browseDialog(self.impl, value.impl)

   @property
   def path(self): value = lib.PathBox_get_path(self.impl) if self is not None and self.impl != ffi.NULL else ffi.NULL; return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @path.setter
   def path(self, value):
      if not isinstance(value, String): value = String(value)
      lib.PathBox_set_path(self.impl, value.impl.encode('u8'))

   @property
   def slashPath(self): value = lib.PathBox_get_slashPath(self.impl) if self is not None and self.impl != ffi.NULL else ffi.NULL; return None if value == ffi.NULL else ffi.string(value).decode('u8')

   @property
   def systemPath(self): value = lib.PathBox_get_systemPath(self.impl) if self is not None and self.impl != ffi.NULL else ffi.NULL; return None if value == ffi.NULL else ffi.string(value).decode('u8')

   @property
   def selectionColor(self): return Color(impl = lib.PathBox_get_selectionColor(self.impl))
   @selectionColor.setter
   def selectionColor(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.PathBox_set_selectionColor(self.impl, value.impl)

   @property
   def selectionText(self): return Color(impl = lib.PathBox_get_selectionText(self.impl))
   @selectionText.setter
   def selectionText(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.PathBox_set_selectionText(self.impl, value.impl)

   def deselect(self):
      lib.PathBox_deselect(self.impl)

   def end(self):
      lib.PathBox_end(self.impl)

   def home(self):
      lib.PathBox_home(self.impl)

   def fn_unset_PathBox_notifyModified(self, _ec_window, pathBox):
      return lib.PathBox_notifyModified(self.impl, _ec_window.impl, ffi.NULL if pathBox is None else pathBox.impl)

   @property
   def notifyModified(self):
      if hasattr(self, 'fn_PathBox_notifyModified'): return self.fn_PathBox_notifyModified
      else: return self.fn_unset_PathBox_notifyModified
   @notifyModified.setter
   def notifyModified(self, value):
      self.fn_PathBox_notifyModified = value
      lib.Instance_setMethod(self.impl, "NotifyModified".encode('u8'), cb_PathBox_notifyModified)

   def selectAll(self):
      lib.PathBox_selectAll(self.impl)

class PathTypeExpected:
   none      = lib.PathTypeExpected_none
   any       = lib.PathTypeExpected_any
   directory = lib.PathTypeExpected_directory
   file      = lib.PathTypeExpected_file

class Picture(CommonControl):
   class_members = [
                      'tint',
                      'image',
                      'filter',
                      'bitmapImage',
                   ]

   def init_args(self, args, kwArgs): init_args(Picture, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def tint(self): return None
   @tint.setter
   def tint(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.Picture_set_tint(self.impl, value.impl)

   @property
   def image(self): return pyOrNewObject(BitmapResource, lib.Picture_get_image(self.impl))
   @image.setter
   def image(self, value):
      if not isinstance(value, BitmapResource): value = BitmapResource(value)
      lib.Picture_set_image(self.impl, value.impl)

   @property
   def filter(self): return lib.Picture_get_filter(self.impl)
   @filter.setter
   def filter(self, value):
      lib.Picture_set_filter(self.impl, value)

   @property
   def bitmapImage(self): return None
   @bitmapImage.setter
   def bitmapImage(self, value):
      if not isinstance(value, Bitmap): value = Bitmap(value)
      lib.Picture_set_bitmapImage(self.impl, value.impl)

class PopupMenu(Window):
   class_members = [
                      'menu',
                      'isMenuBar',
                      'focus',
                   ]

   def init_args(self, args, kwArgs): init_args(PopupMenu, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def menu(self): return pyOrNewObject(Menu, lib.PopupMenu_get_menu(self.impl))
   @menu.setter
   def menu(self, value):
      if not isinstance(value, Menu): value = Menu(value)
      lib.PopupMenu_set_menu(self.impl, value.impl)

   @property
   def isMenuBar(self): return None
   @isMenuBar.setter
   def isMenuBar(self, value):
      lib.PopupMenu_set_isMenuBar(self.impl, value)

   @property
   def focus(self): return lib.PopupMenu_get_focus(self.impl)

class ProgressBar(CommonControl):
   class_members = [
                      'progress',
                      'range',
                   ]

   def init_args(self, args, kwArgs): init_args(ProgressBar, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def progress(self): return lib.ProgressBar_get_progress(self.impl)
   @progress.setter
   def progress(self, value):
      lib.ProgressBar_set_progress(self.impl, value)

   @property
   def range(self): return lib.ProgressBar_get_range(self.impl)
   @range.setter
   def range(self, value):
      lib.ProgressBar_set_range(self.impl, value)

class SavingDataBox(DataBox):
   class_members = []

   def init_args(self, args, kwArgs): init_args(SavingDataBox, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

@ffi.callback("void(eC_Window, eC_ScrollBar, eC_ScrollBarAction, int, eC_Key)")
def cb_ScrollBar_notifyScrolling(__e, scrollBar, action, position, key):
   scrollbar = pyOrNewObject(ScrollBar, scrollbar)
   scrollbar.fn_ScrollBar_notifyScrolling(pyOrNewObject(ScrollBar, __e), scrollBar, ScrollBarAction(impl = action), position, Key(impl = key))

class ScrollBar(CommonControl):
   class_members = [
                      'direction',
                      'windowOwned',
                      'snap',
                      'range',
                      'seen',
                      'total',
                      'lineStep',
                      'pageStep',
                      'thumbPosition',
                      'downBtn',
                      'upBtn',
                      'thumb',
                      'thumbSize',
                      'notifyScrolling',
                   ]

   def init_args(self, args, kwArgs): init_args(ScrollBar, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def direction(self): return lib.ScrollBar_get_direction(self.impl)
   @direction.setter
   def direction(self, value):
      lib.ScrollBar_set_direction(self.impl, value)

   @property
   def windowOwned(self): return None
   @windowOwned.setter
   def windowOwned(self, value):
      lib.ScrollBar_set_windowOwned(self.impl, value)

   @property
   def snap(self): return lib.ScrollBar_get_snap(self.impl)
   @snap.setter
   def snap(self, value):
      lib.ScrollBar_set_snap(self.impl, value)

   @property
   def range(self): return lib.ScrollBar_get_range(self.impl)
   @range.setter
   def range(self, value):
      lib.ScrollBar_set_range(self.impl, value)

   @property
   def seen(self): return lib.ScrollBar_get_seen(self.impl)
   @seen.setter
   def seen(self, value):
      lib.ScrollBar_set_seen(self.impl, value)

   @property
   def total(self): return lib.ScrollBar_get_total(self.impl)
   @total.setter
   def total(self, value):
      lib.ScrollBar_set_total(self.impl, value)

   @property
   def lineStep(self): return lib.ScrollBar_get_lineStep(self.impl)
   @lineStep.setter
   def lineStep(self, value):
      lib.ScrollBar_set_lineStep(self.impl, value)

   @property
   def pageStep(self): return lib.ScrollBar_get_pageStep(self.impl)
   @pageStep.setter
   def pageStep(self, value):
      lib.ScrollBar_set_pageStep(self.impl, value)

   @property
   def thumbPosition(self): return lib.ScrollBar_get_thumbPosition(self.impl)
   @thumbPosition.setter
   def thumbPosition(self, value):
      lib.ScrollBar_set_thumbPosition(self.impl, value)

   @property
   def downBtn(self): return pyOrNewObject(Button, IPTR(lib, ffi, self, ScrollBar).downBtn)
   @downBtn.setter
   def downBtn(self, value):
      if not isinstance(value, Button): value = Button(value)
      IPTR(lib, ffi, self, ScrollBar).downBtn = value.impl

   @property
   def upBtn(self): return pyOrNewObject(Button, IPTR(lib, ffi, self, ScrollBar).upBtn)
   @upBtn.setter
   def upBtn(self, value):
      if not isinstance(value, Button): value = Button(value)
      IPTR(lib, ffi, self, ScrollBar).upBtn = value.impl

   @property
   def thumb(self): return pyOrNewObject(Button, IPTR(lib, ffi, self, ScrollBar).thumb)
   @thumb.setter
   def thumb(self, value):
      if not isinstance(value, Button): value = Button(value)
      IPTR(lib, ffi, self, ScrollBar).thumb = value.impl

   @property
   def thumbSize(self): return IPTR(lib, ffi, self, ScrollBar).thumbSize
   @thumbSize.setter
   def thumbSize(self, value): IPTR(lib, ffi, self, ScrollBar).thumbSize = value

   def action(self, action, newPosition, key):
      if key is not None and not isinstance(key, Key): key = Key(key)
      if key is None: key = ffi.NULL
      return lib.ScrollBar_action(self.impl, action, newPosition, key)

   def fn_unset_ScrollBar_notifyScrolling(self, _ec_window, scrollBar, action, position, key):
      return lib.ScrollBar_notifyScrolling(self.impl, _ec_window.impl, ffi.NULL if scrollBar is None else scrollBar.impl, action, position, key)

   @property
   def notifyScrolling(self):
      if hasattr(self, 'fn_ScrollBar_notifyScrolling'): return self.fn_ScrollBar_notifyScrolling
      else: return self.fn_unset_ScrollBar_notifyScrolling
   @notifyScrolling.setter
   def notifyScrolling(self, value):
      self.fn_ScrollBar_notifyScrolling = value
      lib.Instance_setMethod(self.impl, "NotifyScrolling".encode('u8'), cb_ScrollBar_notifyScrolling)

class ScrollBarAction:
   none        = lib.ScrollBarAction_none
   up          = lib.ScrollBarAction_up
   down        = lib.ScrollBarAction_down
   pageDown    = lib.ScrollBarAction_pageDown
   pageUp      = lib.ScrollBarAction_pageUp
   setPosition = lib.ScrollBarAction_setPosition
   home        = lib.ScrollBarAction_home
   end         = lib.ScrollBarAction_end
   setRange    = lib.ScrollBarAction_setRange
   wheelUp     = lib.ScrollBarAction_wheelUp
   wheelDown   = lib.ScrollBarAction_wheelDown

class ScrollDirection:
   horizontal = lib.ScrollDirection_horizontal
   vertical   = lib.ScrollDirection_vertical

class SelectorBar(Stacker):
   class_members = [
                      'selectedButton',
                   ]

   def init_args(self, args, kwArgs): init_args(SelectorBar, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def selectedButton(self): return pyOrNewObject(SelectorButton, lib.SelectorBar_get_selectedButton(self.impl))

   def addButton(self, button = None):
      if button is not None and not isinstance(button, SelectorButton): button = SelectorButton(button)
      button = ffi.NULL if button is None else button.impl
      lib.SelectorBar_addButton(self.impl, button)

   def clear(self):
      lib.SelectorBar_clear(self.impl)

   def findButtonByID(self, id):
      return pyOrNewObject(SelectorButton, lib.SelectorBar_findButtonByID(self.impl, id))

   def removeButton(self, button = None):
      if button is not None and not isinstance(button, SelectorButton): button = SelectorButton(button)
      button = ffi.NULL if button is None else button.impl
      lib.SelectorBar_removeButton(self.impl, button)

   def select(self, button = None):
      if button is not None and not isinstance(button, SelectorButton): button = SelectorButton(button)
      button = ffi.NULL if button is None else button.impl
      lib.SelectorBar_select(self.impl, button)

class StatusBar(Window):
   class_members = [
                      'minInfoWidth',
                   ]

   def init_args(self, args, kwArgs): init_args(StatusBar, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def minInfoWidth(self): return lib.StatusBar_get_minInfoWidth(self.impl)
   @minInfoWidth.setter
   def minInfoWidth(self, value):
      lib.StatusBar_set_minInfoWidth(self.impl, value)

   def addField(self, field = None):
      if field is not None and not isinstance(field, StatusField): field = StatusField(field)
      field = ffi.NULL if field is None else field.impl
      lib.StatusBar_addField(self.impl, field)

   def clear(self):
      lib.StatusBar_clear(self.impl)

   def removeField(self, field = None):
      if field is not None and not isinstance(field, StatusField): field = StatusField(field)
      field = ffi.NULL if field is None else field.impl
      lib.StatusBar_removeField(self.impl, field)

class StatusField(Instance):
   class_members = [
                      'statusBar',
                      'color',
                      'backColor',
                      'bold',
                      'text',
                      'width',
                   ]

   def init_args(self, args, kwArgs): init_args(StatusField, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def statusBar(self): return None
   @statusBar.setter
   def statusBar(self, value):
      if not isinstance(value, StatusBar): value = StatusBar(value)
      lib.StatusField_set_statusBar(self.impl, value.impl)

   @property
   def color(self): return None
   @color.setter
   def color(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.StatusField_set_color(self.impl, value.impl)

   @property
   def backColor(self): return None
   @backColor.setter
   def backColor(self, value):
      if not isinstance(value, ColorAlpha): value = ColorAlpha(value)
      lib.StatusField_set_backColor(self.impl, value.impl)

   @property
   def bold(self): return None
   @bold.setter
   def bold(self, value):
      lib.StatusField_set_bold(self.impl, value)

   @property
   def text(self): return None
   @text.setter
   def text(self, value):
      lib.StatusField_set_text(self.impl, value.encode('u8'))

   @property
   def width(self): return None
   @width.setter
   def width(self, value):
      lib.StatusField_set_width(self.impl, value)

   def setTextf(self, format, *args):
      if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
      elif format is None: format = ffi.NULL
      lib.StatusField_setTextf(self.impl, format, *ellipsisArgs(args))

class Tab(Window):
   class_members = [
                      'tabControl',
                      'isAdded',
                   ]

   def init_args(self, args, kwArgs): init_args(Tab, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def tabControl(self): return pyOrNewObject(TabControl, lib.Tab_get_tabControl(self.impl))
   @tabControl.setter
   def tabControl(self, value):
      if not isinstance(value, TabControl): value = TabControl(value)
      lib.Tab_set_tabControl(self.impl, value.impl)

   @property
   def isAdded(self): return lib.Tab_get_isAdded(self.impl)

   def selectTab(self):
      lib.Tab_selectTab(self.impl)

class TabControl(Window):
   class_members = [
                      'placement',
                      'buttonsOffset',
                      'curTab',
                   ]

   def init_args(self, args, kwArgs): init_args(TabControl, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def placement(self): return lib.TabControl_get_placement(self.impl)
   @placement.setter
   def placement(self, value):
      lib.TabControl_set_placement(self.impl, value)

   @property
   def buttonsOffset(self): return lib.TabControl_get_buttonsOffset(self.impl)
   @buttonsOffset.setter
   def buttonsOffset(self, value):
      lib.TabControl_set_buttonsOffset(self.impl, value)

   @property
   def curTab(self): return pyOrNewObject(Tab, lib.TabControl_get_curTab(self.impl))
   @curTab.setter
   def curTab(self, value):
      if not isinstance(value, Tab): value = Tab(value)
      lib.TabControl_set_curTab(self.impl, value.impl)

   def addTab(self, tab = None):
      if tab is not None and not isinstance(tab, Tab): tab = Tab(tab)
      tab = ffi.NULL if tab is None else tab.impl
      lib.TabControl_addTab(self.impl, tab)

   def removeTab(self, tab = None):
      if tab is not None and not isinstance(tab, Tab): tab = Tab(tab)
      tab = ffi.NULL if tab is None else tab.impl
      lib.TabControl_removeTab(self.impl, tab)

class TabsPlacement:
   top    = lib.TabsPlacement_top
   bottom = lib.TabsPlacement_bottom
   left   = lib.TabsPlacement_left
   right  = lib.TabsPlacement_right

class ToolBar(Stacker):
   class_members = []

   def init_args(self, args, kwArgs): init_args(ToolBar, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class ToolButton(Button):
   class_members = [
                      'menuItemPtr',
                      'menuItem',
                   ]

   def init_args(self, args, kwArgs): init_args(ToolButton, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def menuItemPtr(self): return None
   @menuItemPtr.setter
   def menuItemPtr(self, value):
      lib.ToolButton_set_menuItemPtr(self.impl, value.impl)

   @property
   def menuItem(self): return pyOrNewObject(MenuItem, lib.ToolButton_get_menuItem(self.impl))

class ToolSeparator(Window):
   class_members = []

   def init_args(self, args, kwArgs): init_args(ToolSeparator, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class ToolTip(Window):
   class_members = [
                      'tip',
                   ]

   def init_args(self, args, kwArgs): init_args(ToolTip, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def tip(self): value = lib.ToolTip_get_tip(self.impl) if self is not None and self.impl != ffi.NULL else ffi.NULL; return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @tip.setter
   def tip(self, value):
      if not isinstance(value, String): value = String(value)
      lib.ToolTip_set_tip(self.impl, value.impl.encode('u8'))

@ffi.callback("void(eC_UndoAction, void *)")
def cb_UndoAction_redo(__e, data):
   undoaction = pyOrNewObject(UndoAction, __e)
   undoaction.fn_UndoAction_redo(undoaction, data)

@ffi.callback("void(eC_UndoAction, void *)")
def cb_UndoAction_undo(__e, data):
   undoaction = pyOrNewObject(UndoAction, __e)
   undoaction.fn_UndoAction_undo(undoaction, data)

class UndoAction:
   def __init__(self, type = None, continued = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_UndoAction *", lib.Instance_new(lib.class_UndoAction))
         if isinstance(type, tuple):
            __tuple = type
            type = None
            if len(__tuple) > 0: type      = __tuple[0]
            if len(__tuple) > 1: continued = __tuple[1]
         if type is not None:      self.type      = type
         if continued is not None: self.continued = continued

   @property
   def type(self): return self.impl.type
   @type.setter
   def type(self, value): self.impl.type = value

   @property
   def continued(self): return self.impl.continued
   @continued.setter
   def continued(self, value): self.impl.continued = value

   def fn_unset_UndoAction_redo(self, data):
      return lib.UndoAction_redo(self.impl, data)

   @property
   def redo(self):
      if hasattr(self, 'fn_UndoAction_redo'): return self.fn_UndoAction_redo
      else: return self.fn_unset_UndoAction_redo
   @redo.setter
   def redo(self, value):
      self.fn_UndoAction_redo = value
      lib.Instance_setMethod(self.impl, "Redo".encode('u8'), cb_UndoAction_redo)

   def fn_unset_UndoAction_undo(self, data):
      return lib.UndoAction_undo(self.impl, data)

   @property
   def undo(self):
      if hasattr(self, 'fn_UndoAction_undo'): return self.fn_UndoAction_undo
      else: return self.fn_unset_UndoAction_undo
   @undo.setter
   def undo(self, value):
      self.fn_UndoAction_undo = value
      lib.Instance_setMethod(self.impl, "Undo".encode('u8'), cb_UndoAction_undo)

class UndoBuffer(Instance):
   class_members = [
                      'count',
                      'curAction',
                      'data',
                      'dontRecord',
                      'insideRedo',
                      'recordAsOne',
                      'firstEvent',
                   ]

   def init_args(self, args, kwArgs): init_args(UndoBuffer, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def count(self): return IPTR(lib, ffi, self, UndoBuffer).count
   @count.setter
   def count(self, value): IPTR(lib, ffi, self, UndoBuffer).count = value

   @property
   def curAction(self): return IPTR(lib, ffi, self, UndoBuffer).curAction
   @curAction.setter
   def curAction(self, value): IPTR(lib, ffi, self, UndoBuffer).curAction = value

   @property
   def data(self): return IPTR(lib, ffi, self, UndoBuffer).data
   @data.setter
   def data(self, value): IPTR(lib, ffi, self, UndoBuffer).data = value

   @property
   def dontRecord(self): return IPTR(lib, ffi, self, UndoBuffer).dontRecord
   @dontRecord.setter
   def dontRecord(self, value): IPTR(lib, ffi, self, UndoBuffer).dontRecord = value

   @property
   def insideRedo(self): return IPTR(lib, ffi, self, UndoBuffer).insideRedo
   @insideRedo.setter
   def insideRedo(self, value): IPTR(lib, ffi, self, UndoBuffer).insideRedo = value

   @property
   def recordAsOne(self): return IPTR(lib, ffi, self, UndoBuffer).recordAsOne
   @recordAsOne.setter
   def recordAsOne(self, value): IPTR(lib, ffi, self, UndoBuffer).recordAsOne = value

   @property
   def firstEvent(self): return IPTR(lib, ffi, self, UndoBuffer).firstEvent
   @firstEvent.setter
   def firstEvent(self, value): IPTR(lib, ffi, self, UndoBuffer).firstEvent = value

   def clear(self):
      lib.UndoBuffer_clear(self.impl)

   def record(self, action = None):
      if action is not None and not isinstance(action, UndoAction): action = UndoAction(action)
      action = ffi.NULL if action is None else action.impl
      lib.UndoBuffer_record(self.impl, ffi.cast("struct eC_UndoAction *", action))

   def redo(self):
      lib.UndoBuffer_redo(self.impl)

   def undo(self):
      lib.UndoBuffer_undo(self.impl)

class ColorPicker(Window):
   class_members = [
                      'color',
                      'hasAlpha',
                   ]

   def init_args(self, args, kwArgs): init_args(ColorPicker, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def color(self): return Color(impl = lib.ColorPicker_get_color(self.impl))
   @color.setter
   def color(self, value):
      if not isinstance(value, Color): value = Color(value)
      lib.ColorPicker_set_color(self.impl, value.impl)

   @property
   def hasAlpha(self): return lib.ColorPicker_get_hasAlpha(self.impl)
   @hasAlpha.setter
   def hasAlpha(self, value):
      lib.ColorPicker_set_hasAlpha(self.impl, value)

class CreateDirectoryDialog(Window):
   class_members = [
                      'currentDirectory',
                   ]

   def init_args(self, args, kwArgs): init_args(CreateDirectoryDialog, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def currentDirectory(self): value = lib.CreateDirectoryDialog_get_currentDirectory(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @currentDirectory.setter
   def currentDirectory(self, value):
      lib.CreateDirectoryDialog_set_currentDirectory(self.impl, value.encode('u8'))

class FileDialog(Window):
   class_members = [
                      'type',
                      'filePath',
                      'currentDirectory',
                      'filters',
                      'types',
                      'sizeFilters',
                      'sizeTypes',
                      'filter',
                      'fileType',
                      'mayNotExist',
                      'numSelections',
                      'multiFilePaths',
                   ]

   def init_args(self, args, kwArgs): init_args(FileDialog, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def type(self): return lib.FileDialog_get_type(self.impl)
   @type.setter
   def type(self, value):
      lib.FileDialog_set_type(self.impl, value)

   @property
   def filePath(self): value = lib.FileDialog_get_filePath(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @filePath.setter
   def filePath(self, value):
      lib.FileDialog_set_filePath(self.impl, value.encode('u8'))

   @property
   def currentDirectory(self): value = lib.FileDialog_get_currentDirectory(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @currentDirectory.setter
   def currentDirectory(self, value):
      lib.FileDialog_set_currentDirectory(self.impl, value.encode('u8'))

   @property
   def filters(self): return lib.FileDialog_get_filters(self.impl)
   @filters.setter
   def filters(self, value):
      lib.FileDialog_set_filters(self.impl, value.impl)

   @property
   def types(self): return lib.FileDialog_get_types(self.impl)
   @types.setter
   def types(self, value):
      lib.FileDialog_set_types(self.impl, value.impl)

   @property
   def sizeFilters(self): return lib.FileDialog_get_sizeFilters(self.impl)
   @sizeFilters.setter
   def sizeFilters(self, value):
      lib.FileDialog_set_sizeFilters(self.impl, value)

   @property
   def sizeTypes(self): return lib.FileDialog_get_sizeTypes(self.impl)
   @sizeTypes.setter
   def sizeTypes(self, value):
      lib.FileDialog_set_sizeTypes(self.impl, value)

   @property
   def filter(self): return lib.FileDialog_get_filter(self.impl)
   @filter.setter
   def filter(self, value):
      lib.FileDialog_set_filter(self.impl, value)

   @property
   def fileType(self): return lib.FileDialog_get_fileType(self.impl)
   @fileType.setter
   def fileType(self, value):
      lib.FileDialog_set_fileType(self.impl, value)

   @property
   def mayNotExist(self): return lib.FileDialog_get_mayNotExist(self.impl)
   @mayNotExist.setter
   def mayNotExist(self, value):
      lib.FileDialog_set_mayNotExist(self.impl, value)

   @property
   def numSelections(self): return lib.FileDialog_get_numSelections(self.impl)

   @property
   def multiFilePaths(self): return lib.FileDialog_get_multiFilePaths(self.impl)

class FileDialogType:
   open      = lib.FileDialogType_open
   save      = lib.FileDialogType_save
   selectDir = lib.FileDialogType_selectDir
   multiOpen = lib.FileDialogType_multiOpen

class FileFilter(Struct):
   def __init__(self, name = None, extensions = None, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_FileFilter *", impl)
      else:
         if isinstance(name, tuple):
            __tuple = name
            name = None
            if len(__tuple) > 0: name       = __tuple[0]
            if len(__tuple) > 1: extensions = __tuple[1]
         self.impl = ffi.new("eC_FileFilter *", { 'name' : name, 'extensions' : extensions })

   @property
   def name(self): return self.impl.name
   @name.setter
   def name(self, value):
      if isinstance(value, str): value = ffi.new("char[]", value.encode('u8'))
      elif value is None: value = ffi.NULL
      self.impl.name = value

   @property
   def extensions(self): return self.impl.extensions
   @extensions.setter
   def extensions(self, value):
      if isinstance(value, str): value = ffi.new("char[]", value.encode('u8'))
      elif value is None: value = ffi.NULL
      self.impl.extensions = value

   def validateFileName(self, name):
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      return lib.FileFilter_validateFileName(ffi.cast("eC_FileFilter *", self.impl), name)

class FileForceExtension:
   never         = lib.FileForceExtension_never
   always        = lib.FileForceExtension_always
   whenNoneGiven = lib.FileForceExtension_whenNoneGiven

class FileName(Struct):
   def __init__(self, name = None, type = 0, indent = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_FileName *", impl)
      else:
         if isinstance(name, tuple):
            __tuple = name
            name = None
            if len(__tuple) > 0: name   = __tuple[0]
            if len(__tuple) > 1: type   = __tuple[1]
            if len(__tuple) > 2: indent = __tuple[2]
         self.impl = ffi.new("eC_FileName *", { 'name' : name, 'type' : type, 'indent' : indent })

   @property
   def name(self): return self.impl.name
   @name.setter
   def name(self, value):
      if isinstance(value, str): value = ffi.new("char[]", value.encode('u8'))
      elif value is None: value = ffi.NULL
      self.impl.name = value

   @property
   def type(self): return self.impl.type
   @type.setter
   def type(self, value): self.impl.type = value

   @property
   def indent(self): return self.impl.indent
   @indent.setter
   def indent(self, value): self.impl.indent = value

class FileNameType:
   folder                = lib.FileNameType_folder
   folderOpen            = lib.FileNameType_folderOpen
   computer              = lib.FileNameType_computer
   drive                 = lib.FileNameType_drive
   netDrive              = lib.FileNameType_netDrive
   cdrom                 = lib.FileNameType_cdrom
   removable             = lib.FileNameType_removable
   floppy                = lib.FileNameType_floppy
   network               = lib.FileNameType_network
   server                = lib.FileNameType_server
   share                 = lib.FileNameType_share
   normalFile            = lib.FileNameType_normalFile
   ewsFile               = lib.FileNameType_ewsFile
   epjFile               = lib.FileNameType_epjFile
   ecFile                = lib.FileNameType_ecFile
   ehFile                = lib.FileNameType_ehFile
   cFile                 = lib.FileNameType_cFile
   hFile                 = lib.FileNameType_hFile
   cppFile               = lib.FileNameType_cppFile
   hppFile               = lib.FileNameType_hppFile
   textFile              = lib.FileNameType_textFile
   webFile               = lib.FileNameType_webFile
   pictureFile           = lib.FileNameType_pictureFile
   soundFile             = lib.FileNameType_soundFile
   archiveFile           = lib.FileNameType_archiveFile
   packageFile           = lib.FileNameType_packageFile
   opticalMediaImageFile = lib.FileNameType_opticalMediaImageFile

   @property
   def isFolderType(self): return lib.FileNameType_get_isFolderType(self.impl)

   @property
   def isFileType(self): return lib.FileNameType_get_isFileType(self.impl)

   def selectByExtension(extension):
      if isinstance(extension, str): extension = ffi.new("char[]", extension.encode('u8'))
      elif extension is None: extension = ffi.NULL
      return lib.FileNameType_selectByExtension(extension)

class FileType(Struct):
   def __init__(self, name = None, typeExtension = None, forceExtension = 0, impl = None):
      if impl is not None:
         self.impl = ffi.new("eC_FileType *", impl)
      else:
         if isinstance(name, tuple):
            __tuple = name
            name = None
            if len(__tuple) > 0: name           = __tuple[0]
            if len(__tuple) > 1: typeExtension  = __tuple[1]
            if len(__tuple) > 2: forceExtension = __tuple[2]
         self.impl = ffi.new("eC_FileType *", { 'name' : name, 'typeExtension' : typeExtension, 'forceExtension' : forceExtension })

   @property
   def name(self): return self.impl.name
   @name.setter
   def name(self, value):
      if isinstance(value, str): value = ffi.new("char[]", value.encode('u8'))
      elif value is None: value = ffi.NULL
      self.impl.name = value

   @property
   def typeExtension(self): return self.impl.typeExtension
   @typeExtension.setter
   def typeExtension(self, value):
      if isinstance(value, str): value = ffi.new("char[]", value.encode('u8'))
      elif value is None: value = ffi.NULL
      self.impl.typeExtension = value

   @property
   def forceExtension(self): return self.impl.forceExtension
   @forceExtension.setter
   def forceExtension(self, value): self.impl.forceExtension = value

class FindDialog(Window):
   class_members = [
                      'editBox',
                      'searchString',
                      'wholeWord',
                      'matchCase',
                      'searchUp',
                   ]

   def init_args(self, args, kwArgs): init_args(FindDialog, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def editBox(self): return None
   @editBox.setter
   def editBox(self, value):
      if not isinstance(value, EditBox): value = EditBox(value)
      lib.FindDialog_set_editBox(self.impl, value.impl)

   @property
   def searchString(self): value = lib.FindDialog_get_searchString(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @searchString.setter
   def searchString(self, value):
      lib.FindDialog_set_searchString(self.impl, value.encode('u8'))

   @property
   def wholeWord(self): return lib.FindDialog_get_wholeWord(self.impl)
   @wholeWord.setter
   def wholeWord(self, value):
      lib.FindDialog_set_wholeWord(self.impl, value)

   @property
   def matchCase(self): return lib.FindDialog_get_matchCase(self.impl)
   @matchCase.setter
   def matchCase(self, value):
      lib.FindDialog_set_matchCase(self.impl, value)

   @property
   def searchUp(self): return lib.FindDialog_get_searchUp(self.impl)
   @searchUp.setter
   def searchUp(self, value):
      lib.FindDialog_set_searchUp(self.impl, value)

class GoToDialog(Window):
   class_members = [
                      'line',
                      'editBox',
                   ]

   def init_args(self, args, kwArgs): init_args(GoToDialog, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def line(self): return lib.GoToDialog_get_line(self.impl)
   @line.setter
   def line(self, value):
      lib.GoToDialog_set_line(self.impl, value)

   @property
   def editBox(self): return pyOrNewObject(EditBox, lib.GoToDialog_get_editBox(self.impl))
   @editBox.setter
   def editBox(self, value):
      if not isinstance(value, EditBox): value = EditBox(value)
      lib.GoToDialog_set_editBox(self.impl, value.impl)

class MessageBox(Window):
   class_members = [
                      'type',
                      'contents',
                   ]

   def init_args(self, args, kwArgs): init_args(MessageBox, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def type(self): return None
   @type.setter
   def type(self, value):
      lib.MessageBox_set_type(self.impl, value)

   @property
   def contents(self): return None
   @contents.setter
   def contents(self, value):
      lib.MessageBox_set_contents(self.impl, value.encode('u8'))

class MessageBoxType:
   ok          = lib.MessageBoxType_ok
   yesNo       = lib.MessageBoxType_yesNo
   okCancel    = lib.MessageBoxType_okCancel
   yesNoCancel = lib.MessageBoxType_yesNoCancel

class ReplaceDialog(Window):
   class_members = [
                      'editBox',
                      'searchString',
                      'replaceString',
                      'wholeWord',
                      'matchCase',
                   ]

   def init_args(self, args, kwArgs): init_args(ReplaceDialog, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def editBox(self): return None
   @editBox.setter
   def editBox(self, value):
      if not isinstance(value, EditBox): value = EditBox(value)
      lib.ReplaceDialog_set_editBox(self.impl, value.impl)

   @property
   def searchString(self): value = lib.ReplaceDialog_get_searchString(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @searchString.setter
   def searchString(self, value):
      lib.ReplaceDialog_set_searchString(self.impl, value.encode('u8'))

   @property
   def replaceString(self): value = lib.ReplaceDialog_get_replaceString(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')
   @replaceString.setter
   def replaceString(self, value):
      lib.ReplaceDialog_set_replaceString(self.impl, value.encode('u8'))

   @property
   def wholeWord(self): return lib.ReplaceDialog_get_wholeWord(self.impl)
   @wholeWord.setter
   def wholeWord(self, value):
      lib.ReplaceDialog_set_wholeWord(self.impl, value)

   @property
   def matchCase(self): return lib.ReplaceDialog_get_matchCase(self.impl)
   @matchCase.setter
   def matchCase(self, value):
      lib.ReplaceDialog_set_matchCase(self.impl, value)

class WindowList(Window):
   class_members = []

   def init_args(self, args, kwArgs): init_args(WindowList, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

@ffi.callback("void(eC_Service)")
def cb_Service_onAccept(__e):
   service = pyOrNewObject(Service, __e)
   service.fn_Service_onAccept(service)

class Service(Instance):
   class_members = [
                      'port',
                      'firstClient',
                      'processAlone',
                      'started',
                      'onAccept',
                   ]

   def init_args(self, args, kwArgs): init_args(Service, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def port(self): return lib.Service_get_port(self.impl)
   @port.setter
   def port(self, value):
      lib.Service_set_port(self.impl, value)

   @property
   def firstClient(self): return pyOrNewObject(Socket, lib.Service_get_firstClient(self.impl))

   @property
   def processAlone(self): return lib.Service_get_processAlone(self.impl)
   @processAlone.setter
   def processAlone(self, value):
      lib.Service_set_processAlone(self.impl, value)

   @property
   def started(self): return lib.Service_get_started(self.impl)

   def fn_unset_Service_onAccept(self):
      return lib.Service_onAccept(self.impl)

   @property
   def onAccept(self):
      if hasattr(self, 'fn_Service_onAccept'): return self.fn_Service_onAccept
      else: return self.fn_unset_Service_onAccept
   @onAccept.setter
   def onAccept(self, value):
      self.fn_Service_onAccept = value
      lib.Instance_setMethod(self.impl, "OnAccept".encode('u8'), cb_Service_onAccept)

   def process(self):
      return lib.Service_process(self.impl)

   def processTimeOut(self, timeOut):
      if timeOut is not None and not isinstance(timeOut, Time): timeOut = Seconds(timeOut)
      if timeOut is None: timeOut = ffi.NULL
      return lib.Service_processTimeOut(self.impl, timeOut.impl)

   def start(self):
      return lib.Service_start(self.impl)

   def stop(self):
      return lib.Service_stop(self.impl)

@ffi.callback("void(eC_Socket)")
def cb_Socket_onConnect(__e):
   socket = pyOrNewObject(Socket, __e)
   socket.fn_Socket_onConnect(socket)

@ffi.callback("void(eC_Socket, int)")
def cb_Socket_onDisconnect(__e, code):
   socket = pyOrNewObject(Socket, __e)
   socket.fn_Socket_onDisconnect(socket, code)

@ffi.callback("eC_bool(eC_Socket, int)")
def cb_Socket_onEstablishConnection(__e, s):
   socket = pyOrNewObject(Socket, __e)
   return socket.fn_Socket_onEstablishConnection(socket, s)

@ffi.callback("uint(eC_Socket, const byte *, uint)")
def cb_Socket_onReceive(__e, buffer, count):
   socket = pyOrNewObject(Socket, __e)
   return socket.fn_Socket_onReceive(socket, buffer, count)

@ffi.callback("void(eC_Socket, eC_Packet *)")
def cb_Socket_onReceivePacket(__e, packet):
   socket = pyOrNewObject(Socket, __e)
   socket.fn_Socket_onReceivePacket(socket, Packet(impl = packet))

@ffi.callback("int(eC_Socket, byte *, int, uint)")
def cb_Socket_receiveData(__e, buffer, count, flags):
   socket = pyOrNewObject(Socket, __e)
   return socket.fn_Socket_receiveData(socket, buffer, count, flags)

@ffi.callback("int(eC_Socket, const byte *, int, uint)")
def cb_Socket_sendData(__e, buffer, count, flags):
   socket = pyOrNewObject(Socket, __e)
   return socket.fn_Socket_sendData(socket, buffer, count, flags)

class Socket(Instance):
   class_members = [
                      'service',
                      'inetAddress',
                      'inetPort',
                      'next',
                      'connected',
                      'processAlone',
                      'onConnect',
                      'onDisconnect',
                      'onEstablishConnection',
                      'onReceive',
                      'onReceivePacket',
                      'receiveData',
                      'sendData',
                   ]

   def init_args(self, args, kwArgs): init_args(Socket, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def service(self): return pyOrNewObject(Service, lib.Socket_get_service(self.impl))
   @service.setter
   def service(self, value):
      if not isinstance(value, Service): value = Service(value)
      lib.Socket_set_service(self.impl, value.impl)

   @property
   def inetAddress(self): value = lib.Socket_get_inetAddress(self.impl); return None if value == ffi.NULL else ffi.string(value).decode('u8')

   @property
   def inetPort(self): return lib.Socket_get_inetPort(self.impl)

   @property
   def next(self): return pyOrNewObject(Socket, lib.Socket_get_next(self.impl))

   @property
   def connected(self): return lib.Socket_get_connected(self.impl)

   @property
   def processAlone(self): return lib.Socket_get_processAlone(self.impl)
   @processAlone.setter
   def processAlone(self, value):
      lib.Socket_set_processAlone(self.impl, value)

   def connect(self, address, port):
      if isinstance(address, str): address = ffi.new("char[]", address.encode('u8'))
      elif address is None: address = ffi.NULL
      return lib.Socket_connect(self.impl, address, port)

   def datagramConnect(self, sendAddress, port):
      if isinstance(sendAddress, str): sendAddress = ffi.new("char[]", sendAddress.encode('u8'))
      elif sendAddress is None: sendAddress = ffi.NULL
      return lib.Socket_datagramConnect(self.impl, sendAddress, port)

   def datagramHost(self, port):
      return lib.Socket_datagramHost(self.impl, port)

   def disconnect(self, code):
      lib.Socket_disconnect(self.impl, code)

   def fn_unset_Socket_onConnect(self):
      return lib.Socket_onConnect(self.impl)

   @property
   def onConnect(self):
      if hasattr(self, 'fn_Socket_onConnect'): return self.fn_Socket_onConnect
      else: return self.fn_unset_Socket_onConnect
   @onConnect.setter
   def onConnect(self, value):
      self.fn_Socket_onConnect = value
      lib.Instance_setMethod(self.impl, "OnConnect".encode('u8'), cb_Socket_onConnect)

   def fn_unset_Socket_onDisconnect(self, code):
      return lib.Socket_onDisconnect(self.impl, code)

   @property
   def onDisconnect(self):
      if hasattr(self, 'fn_Socket_onDisconnect'): return self.fn_Socket_onDisconnect
      else: return self.fn_unset_Socket_onDisconnect
   @onDisconnect.setter
   def onDisconnect(self, value):
      self.fn_Socket_onDisconnect = value
      lib.Instance_setMethod(self.impl, "OnDisconnect".encode('u8'), cb_Socket_onDisconnect)

   def fn_unset_Socket_onEstablishConnection(self, s):
      return lib.Socket_onEstablishConnection(self.impl, s)

   @property
   def onEstablishConnection(self):
      if hasattr(self, 'fn_Socket_onEstablishConnection'): return self.fn_Socket_onEstablishConnection
      else: return self.fn_unset_Socket_onEstablishConnection
   @onEstablishConnection.setter
   def onEstablishConnection(self, value):
      self.fn_Socket_onEstablishConnection = value
      lib.Instance_setMethod(self.impl, "OnEstablishConnection".encode('u8'), cb_Socket_onEstablishConnection)

   def fn_unset_Socket_onReceive(self, buffer, count):
      return lib.Socket_onReceive(self.impl, buffer, count)

   @property
   def onReceive(self):
      if hasattr(self, 'fn_Socket_onReceive'): return self.fn_Socket_onReceive
      else: return self.fn_unset_Socket_onReceive
   @onReceive.setter
   def onReceive(self, value):
      self.fn_Socket_onReceive = value
      lib.Instance_setMethod(self.impl, "OnReceive".encode('u8'), cb_Socket_onReceive)

   def fn_unset_Socket_onReceivePacket(self, packet):
      return lib.Socket_onReceivePacket(self.impl, ffi.NULL if packet is None else packet.impl)

   @property
   def onReceivePacket(self):
      if hasattr(self, 'fn_Socket_onReceivePacket'): return self.fn_Socket_onReceivePacket
      else: return self.fn_unset_Socket_onReceivePacket
   @onReceivePacket.setter
   def onReceivePacket(self, value):
      self.fn_Socket_onReceivePacket = value
      lib.Instance_setMethod(self.impl, "OnReceivePacket".encode('u8'), cb_Socket_onReceivePacket)

   def process(self):
      return lib.Socket_process(self.impl)

   def processTimeOut(self, timeOut):
      if timeOut is not None and not isinstance(timeOut, Time): timeOut = Seconds(timeOut)
      if timeOut is None: timeOut = ffi.NULL
      return lib.Socket_processTimeOut(self.impl, timeOut.impl)

   def fn_unset_Socket_receiveData(self, buffer, count, flags):
      return lib.Socket_receiveData(self.impl, buffer, count, flags)

   @property
   def receiveData(self):
      if hasattr(self, 'fn_Socket_receiveData'): return self.fn_Socket_receiveData
      else: return self.fn_unset_Socket_receiveData
   @receiveData.setter
   def receiveData(self, value):
      self.fn_Socket_receiveData = value
      lib.Instance_setMethod(self.impl, "ReceiveData".encode('u8'), cb_Socket_receiveData)

   def send(self, buffer, size):
      if hasattr(buffer, 'impl'): buffer = buffer.impl
      if buffer is None: buffer = ffi.NULL
      return lib.Socket_send(self.impl, buffer, size)

   def fn_unset_Socket_sendData(self, buffer, count, flags):
      return lib.Socket_sendData(self.impl, buffer, count, flags)

   @property
   def sendData(self):
      if hasattr(self, 'fn_Socket_sendData'): return self.fn_Socket_sendData
      else: return self.fn_unset_Socket_sendData
   @sendData.setter
   def sendData(self, value):
      self.fn_Socket_sendData = value
      lib.Instance_setMethod(self.impl, "SendData".encode('u8'), cb_Socket_sendData)

   def sendPacket(self, packet = None):
      if packet is not None and not isinstance(packet, Packet): packet = Packet(packet)
      packet = ffi.NULL if packet is None else packet.impl
      return lib.Socket_sendPacket(self.impl, ffi.cast("struct eC_Packet *", packet))

   def sendString(self, string):
      if isinstance(string, str): string = ffi.new("char[]", string.encode('u8'))
      elif string is None: string = ffi.NULL
      return lib.Socket_sendString(self.impl, string)

   def sendf(self, format, *args):
      if isinstance(format, str): format = ffi.new("char[]", format.encode('u8'))
      elif format is None: format = ffi.NULL
      return lib.Socket_sendf(self.impl, format, *ellipsisArgs(args))

   def safeDecRef(self):
      lib.Socket_safeDecRef(self.impl)

   def safeIncRef(self):
      lib.Socket_safeIncRef(self.impl)

@ffi.callback("void(eC_DCOMClientObject, uint, eC_SerialBuffer)")
def cb_DCOMClientObject_callVirtualMethod(__e, __ecereMethodID, __ecereBuffer):
   dcomclientobject = pyOrNewObject(DCOMClientObject, __e)
   dcomclientobject.fn_DCOMClientObject_callVirtualMethod(dcomclientobject, __ecereMethodID, pyOrNewObject(SerialBuffer, __ecereBuffer))

class DCOMClientObject(Socket):
   class_members = [
                      'objectID',
                      'answered',
                      '__ecereBuffer',
                      'nextCallID',
                      'callVirtualMethod',
                   ]

   def init_args(self, args, kwArgs): init_args(DCOMClientObject, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def objectID(self): return IPTR(lib, ffi, self, DCOMClientObject).objectID
   @objectID.setter
   def objectID(self, value): IPTR(lib, ffi, self, DCOMClientObject).objectID = value

   @property
   def answered(self): return IPTR(lib, ffi, self, DCOMClientObject).answered
   @answered.setter
   def answered(self, value): IPTR(lib, ffi, self, DCOMClientObject).answered = value

   @property
   def __ecereBuffer(self): return pyOrNewObject(SerialBuffer, IPTR(lib, ffi, self, DCOMClientObject).__ecereBuffer)
   @__ecereBuffer.setter
   def __ecereBuffer(self, value):
      if not isinstance(value, SerialBuffer): value = SerialBuffer(value)
      IPTR(lib, ffi, self, DCOMClientObject).__ecereBuffer = value.impl

   @property
   def nextCallID(self): return IPTR(lib, ffi, self, DCOMClientObject).nextCallID
   @nextCallID.setter
   def nextCallID(self, value): IPTR(lib, ffi, self, DCOMClientObject).nextCallID = value

   def callMethod(self, methodID, hasReturnValue):
      return lib.DCOMClientObject_callMethod(self.impl, methodID, hasReturnValue)

   def fn_unset_DCOMClientObject_callVirtualMethod(self, __ecereMethodID, __ecereBuffer):
      return lib.DCOMClientObject_callVirtualMethod(self.impl, __ecereMethodID, ffi.NULL if __ecereBuffer is None else __ecereBuffer.impl)

   @property
   def callVirtualMethod(self):
      if hasattr(self, 'fn_DCOMClientObject_callVirtualMethod'): return self.fn_DCOMClientObject_callVirtualMethod
      else: return self.fn_unset_DCOMClientObject_callVirtualMethod
   @callVirtualMethod.setter
   def callVirtualMethod(self, value):
      self.fn_DCOMClientObject_callVirtualMethod = value
      lib.Instance_setMethod(self.impl, "CallVirtualMethod".encode('u8'), cb_DCOMClientObject_callVirtualMethod)

   def connect(self, server, port):
      if isinstance(server, str): server = ffi.new("char[]", server.encode('u8'))
      elif server is None: server = ffi.NULL
      return lib.DCOMClientObject_connect(self.impl, server, port)

class DCOMSendControl(Instance):
   class_members = []

   def init_args(self, args, kwArgs): init_args(DCOMSendControl, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def resume(self):
      lib.DCOMSendControl_resume(self.impl)

   def stop(self):
      lib.DCOMSendControl_stop(self.impl)

@ffi.callback("void(eC_DCOMServerObject, uint, eC_SerialBuffer)")
def cb_DCOMServerObject_callMethod(__e, __ecereMethodID, __ecereBuffer):
   dcomserverobject = pyOrNewObject(DCOMServerObject, __e)
   dcomserverobject.fn_DCOMServerObject_callMethod(dcomserverobject, __ecereMethodID, pyOrNewObject(SerialBuffer, __ecereBuffer))

class DCOMServerObject(Instance):
   class_members = [
                      'instance',
                      'serverSocket',
                      'id',
                      'argsBuffer',
                      'returnBuffer',
                      'mutex',
                      'nextCallID',
                      'callMethod',
                   ]

   def init_args(self, args, kwArgs): init_args(DCOMServerObject, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def instance(self): return pyOrNewObject(Instance, IPTR(lib, ffi, self, DCOMServerObject).instance)
   @instance.setter
   def instance(self, value):
      if not isinstance(value, Instance): value = Instance(value)
      IPTR(lib, ffi, self, DCOMServerObject).instance = value.impl

   @property
   def serverSocket(self): return pyOrNewObject(DCOMServerSocket, IPTR(lib, ffi, self, DCOMServerObject).serverSocket)
   @serverSocket.setter
   def serverSocket(self, value):
      if not isinstance(value, DCOMServerSocket): value = DCOMServerSocket(value)
      IPTR(lib, ffi, self, DCOMServerObject).serverSocket = value.impl

   @property
   def id(self): return IPTR(lib, ffi, self, DCOMServerObject).id
   @id.setter
   def id(self, value): IPTR(lib, ffi, self, DCOMServerObject).id = value

   @property
   def argsBuffer(self): return pyOrNewObject(SerialBuffer, IPTR(lib, ffi, self, DCOMServerObject).argsBuffer)
   @argsBuffer.setter
   def argsBuffer(self, value):
      if not isinstance(value, SerialBuffer): value = SerialBuffer(value)
      IPTR(lib, ffi, self, DCOMServerObject).argsBuffer = value.impl

   @property
   def returnBuffer(self): return pyOrNewObject(SerialBuffer, IPTR(lib, ffi, self, DCOMServerObject).returnBuffer)
   @returnBuffer.setter
   def returnBuffer(self, value):
      if not isinstance(value, SerialBuffer): value = SerialBuffer(value)
      IPTR(lib, ffi, self, DCOMServerObject).returnBuffer = value.impl

   @property
   def mutex(self): return Mutex(impl = IPTR(lib, ffi, self, DCOMServerObject).mutex)
   @mutex.setter
   def mutex(self, value):
      if not isinstance(value, Mutex): value = Mutex(value)
      IPTR(lib, ffi, self, DCOMServerObject).mutex = value.impl

   @property
   def nextCallID(self): return IPTR(lib, ffi, self, DCOMServerObject).nextCallID
   @nextCallID.setter
   def nextCallID(self, value): IPTR(lib, ffi, self, DCOMServerObject).nextCallID = value

   def fn_unset_DCOMServerObject_callMethod(self, __ecereMethodID, __ecereBuffer):
      return lib.DCOMServerObject_callMethod(self.impl, __ecereMethodID, ffi.NULL if __ecereBuffer is None else __ecereBuffer.impl)

   @property
   def callMethod(self):
      if hasattr(self, 'fn_DCOMServerObject_callMethod'): return self.fn_DCOMServerObject_callMethod
      else: return self.fn_unset_DCOMServerObject_callMethod
   @callMethod.setter
   def callMethod(self, value):
      self.fn_DCOMServerObject_callMethod = value
      lib.Instance_setMethod(self.impl, "CallMethod".encode('u8'), cb_DCOMServerObject_callMethod)

   def callVirtualMethod(self, methodID, hasReturnValue):
      return lib.DCOMServerObject_callVirtualMethod(self.impl, methodID, hasReturnValue)

class DCOMServerSocket(Socket):
   class_members = []

   def init_args(self, args, kwArgs): init_args(DCOMServerSocket, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class DCOMService(Service):
   class_members = []

   def init_args(self, args, kwArgs): init_args(DCOMService, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def start(self):
      return lib.DCOMService_start(self.impl)

   def stop(self):
      return lib.DCOMService_stop(self.impl)

class DisconnectCode:
   remoteLost    = lib.DisconnectCode_remoteLost
   remoteClosed  = lib.DisconnectCode_remoteClosed
   resolveFailed = lib.DisconnectCode_resolveFailed
   connectFailed = lib.DisconnectCode_connectFailed

class FileServerConnection(Socket):
   class_members = []

   def init_args(self, args, kwArgs): init_args(FileServerConnection, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   def open(self, fileName, mode):
      if isinstance(fileName, str): fileName = ffi.new("char[]", fileName.encode('u8'))
      elif fileName is None: fileName = ffi.NULL
      return pyOrNewObject(NetworkClientFile, lib.FileServerConnection_open(self.impl, fileName, mode))

class HTTPFile(File):
   class_members = [
                      'reuseConnection',
                      'contentType',
                      'contentDisposition',
                      'httpCode',
                   ]

   def init_args(self, args, kwArgs): init_args(HTTPFile, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def reuseConnection(self): return lib.HTTPFile_get_reuseConnection(self.impl)
   @reuseConnection.setter
   def reuseConnection(self, value):
      lib.HTTPFile_set_reuseConnection(self.impl, value)

   @property
   def contentType(self): value = lib.HTTPFile_get_contentType(self.impl) if self is not None and self.impl != ffi.NULL else ffi.NULL; return None if value == ffi.NULL else ffi.string(value).decode('u8')

   @property
   def contentDisposition(self): value = lib.HTTPFile_get_contentDisposition(self.impl) if self is not None and self.impl != ffi.NULL else ffi.NULL; return None if value == ffi.NULL else ffi.string(value).decode('u8')

   @property
   def httpCode(self): return lib.HTTPFile_get_httpCode(self.impl)

   def openURL(self, name, referer, relocation):
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      if isinstance(referer, str): referer = ffi.new("char[]", referer.encode('u8'))
      elif referer is None: referer = ffi.NULL
      if isinstance(relocation, str): relocation = ffi.new("char[]", relocation.encode('u8'))
      elif relocation is None: relocation = ffi.NULL
      return lib.HTTPFile_openURL(self.impl, name, referer, relocation)

   def openURLEx(self, name, referer, relocation, acceptHeader):
      if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
      elif name is None: name = ffi.NULL
      if isinstance(referer, str): referer = ffi.new("char[]", referer.encode('u8'))
      elif referer is None: referer = ffi.NULL
      if isinstance(relocation, str): relocation = ffi.new("char[]", relocation.encode('u8'))
      elif relocation is None: relocation = ffi.NULL
      if isinstance(acceptHeader, str): acceptHeader = ffi.new("char[]", acceptHeader.encode('u8'))
      elif acceptHeader is None: acceptHeader = ffi.NULL
      return lib.HTTPFile_openURLEx(self.impl, name, referer, relocation, acceptHeader)

class NetworkClientFile(File):
   class_members = []

   def init_args(self, args, kwArgs): init_args(NetworkClientFile, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

class Packet:
   def __init__(self, size = None, impl = None):
      if impl is not None:
         self.impl = impl
      else:
         self.impl = ffi.cast("eC_Packet *", lib.Instance_new(lib.class_Packet))
         if size is not None: self.size = size

   @property
   def size(self): return self.impl.size
   @size.setter
   def size(self, value): self.impl.size = value

class SSLSocket(Socket):
   class_members = [
                      'autoEstablish',
                   ]

   def init_args(self, args, kwArgs): init_args(SSLSocket, self, args, kwArgs)
   def __init__(self, *args, **kwArgs):
      self.init_args(list(args), kwArgs)

   @property
   def autoEstablish(self): return lib.SSLSocket_get_autoEstablish(self.impl)
   @autoEstablish.setter
   def autoEstablish(self, value):
      lib.SSLSocket_set_autoEstablish(self.impl, value)

   def establishConnection(self):
      return lib.SSLSocket_establishConnection(self.impl)

class SocketType:
   tcp = lib.SocketType_tcp
   udp = lib.SocketType_udp

def connectToFileServer(hostName, port):
   if isinstance(hostName, str): hostName = ffi.new("char[]", hostName.encode('u8'))
   elif hostName is None: hostName = ffi.NULL
   return pyOrNewObject(FileServerConnection, lib.eC_connectToFileServer(hostName, port))

def fileOpenURL(name):
   if isinstance(name, str): name = ffi.new("char[]", name.encode('u8'))
   elif name is None: name = ffi.NULL
   return pyOrNewObject(HTTPFile, lib.eC_fileOpenURL(name))

def getAddressFromName(hostName, inetAddress):
   if isinstance(hostName, str): hostName = ffi.new("char[]", hostName.encode('u8'))
   elif hostName is None: hostName = ffi.NULL
   if isinstance(inetAddress, str): inetAddress = ffi.new("char[]", inetAddress.encode('u8'))
   elif inetAddress is None: inetAddress = ffi.NULL
   return lib.eC_getAddressFromName(hostName, inetAddress)

def getHostName(hostName, size):
   if isinstance(hostName, str): hostName = ffi.new("char[]", hostName.encode('u8'))
   elif hostName is None: hostName = ffi.NULL
   return lib.eC_getHostName(hostName, size)

def getNameFromAddress(inetAddress, hostName):
   if isinstance(inetAddress, str): inetAddress = ffi.new("char[]", inetAddress.encode('u8'))
   elif inetAddress is None: inetAddress = ffi.NULL
   if isinstance(hostName, str): hostName = ffi.new("char[]", hostName.encode('u8'))
   elif hostName is None: hostName = ffi.NULL
   return lib.eC_getNameFromAddress(inetAddress, hostName)

def setCurlEmbeddedCA(curlHandle):
   if hasattr(curlHandle, 'impl'): curlHandle = curlHandle.impl
   if curlHandle is None: curlHandle = ffi.NULL
   return lib.eC_setCurlEmbeddedCA(curlHandle)
